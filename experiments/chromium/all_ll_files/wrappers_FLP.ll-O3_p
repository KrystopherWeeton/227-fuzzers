; ModuleID = '../../third_party/opus/src/silk/float/wrappers_FLP.c'
source_filename = "../../third_party/opus/src/silk/float/wrappers_FLP.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"
module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"
module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"

%struct.silk_encoder_state = type { [2 x i32], i32, i32, %struct.silk_LP_state, %struct.silk_VAD_state, %struct.silk_nsq_state, [16 x i16], i32, i32, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8*, i8*, %struct.silk_NLSF_CB_struct*, [4 x i32], i32, i32, [3 x i8], i8, [3 x i32], %struct.SideInfoIndices, [320 x i8], i32, [322 x i16], i32, i32, i32, i32, i32, i32, i32, i32, i16, %struct._silk_resampler_state_struct, i32, i32, i32, i32, i32, i32, [3 x %struct.SideInfoIndices], [3 x [320 x i8]] }
%struct.silk_LP_state = type { [2 x i32], i32, i32, i32 }
%struct.silk_VAD_state = type { [2 x i32], [2 x i32], [2 x i32], [4 x i32], [4 x i32], i16, [4 x i32], [4 x i32], [4 x i32], i32 }
%struct.silk_nsq_state = type { [640 x i16], [640 x i32], [96 x i32], [24 x i32], i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.silk_NLSF_CB_struct = type { i16, i16, i16, i16, i8*, i16*, i8*, i8*, i8*, i8*, i8*, i16* }
%struct.SideInfoIndices = type { [4 x i8], [4 x i8], [17 x i8], i16, i8, i8, i8, i8, i8, i8, i8 }
%struct._silk_resampler_state_struct = type { [6 x i32], %union.anon, [48 x i16], i32, i32, i32, i32, i32, i32, i32, i32, i16* }
%union.anon = type { [36 x i32] }
%struct.silk_encoder_state_FLP = type { %struct.silk_encoder_state, %struct.silk_shape_state_FLP, [720 x float], float }
%struct.silk_shape_state_FLP = type { i8, float, float }
%struct.silk_encoder_control_FLP = type { [4 x float], [2 x [16 x float]], [20 x float], float, [4 x i32], [96 x float], [4 x float], [4 x float], [4 x float], [4 x float], float, float, float, float, float, [4 x float], [4 x i32], i8 }

@silk_LTPScales_table_Q14 = external local_unnamed_addr constant [3 x i16], align 2

; Function Attrs: nounwind ssp uwtable
define hidden void @silk_A2NLSF_FLP(i16*, float* nocapture readonly, i32) local_unnamed_addr #0 {
  %4 = alloca [16 x i32], align 16
  %5 = bitcast [16 x i32]* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* nonnull %5) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %5, i8 -86, i64 64, i1 false)
  %6 = icmp sgt i32 %2, 0
  br i1 %6, label %7, label %42

7:                                                ; preds = %3
  %8 = zext i32 %2 to i64
  %9 = and i64 %8, 1
  %10 = icmp eq i32 %2, 1
  br i1 %10, label %32, label %11

11:                                               ; preds = %7
  %12 = sub nsw i64 %8, %9
  br label %13

13:                                               ; preds = %13, %11
  %14 = phi i64 [ 0, %11 ], [ %29, %13 ]
  %15 = phi i64 [ %12, %11 ], [ %30, %13 ]
  %16 = getelementptr inbounds float, float* %1, i64 %14
  %17 = load float, float* %16, align 4
  %18 = fmul float %17, 6.553600e+04
  %19 = insertelement <4 x float> undef, float %18, i32 0
  %20 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %19) #5
  %21 = getelementptr inbounds [16 x i32], [16 x i32]* %4, i64 0, i64 %14
  store i32 %20, i32* %21, align 8
  %22 = or i64 %14, 1
  %23 = getelementptr inbounds float, float* %1, i64 %22
  %24 = load float, float* %23, align 4
  %25 = fmul float %24, 6.553600e+04
  %26 = insertelement <4 x float> undef, float %25, i32 0
  %27 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %26) #5
  %28 = getelementptr inbounds [16 x i32], [16 x i32]* %4, i64 0, i64 %22
  store i32 %27, i32* %28, align 4
  %29 = add nuw nsw i64 %14, 2
  %30 = add i64 %15, -2
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %32, label %13

32:                                               ; preds = %13, %7
  %33 = phi i64 [ 0, %7 ], [ %29, %13 ]
  %34 = icmp eq i64 %9, 0
  br i1 %34, label %42, label %35

35:                                               ; preds = %32
  %36 = getelementptr inbounds float, float* %1, i64 %33
  %37 = load float, float* %36, align 4
  %38 = fmul float %37, 6.553600e+04
  %39 = insertelement <4 x float> undef, float %38, i32 0
  %40 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %39) #5
  %41 = getelementptr inbounds [16 x i32], [16 x i32]* %4, i64 0, i64 %33
  store i32 %40, i32* %41, align 4
  br label %42

42:                                               ; preds = %35, %32, %3
  %43 = getelementptr inbounds [16 x i32], [16 x i32]* %4, i64 0, i64 0
  call void @silk_A2NLSF(i16* %0, i32* nonnull %43, i32 %2) #5
  call void @llvm.lifetime.end.p0i8(i64 64, i8* nonnull %5) #5
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #1

declare void @silk_A2NLSF(i16*, i32*, i32) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: nounwind ssp uwtable
define hidden void @silk_NLSF2A_FLP(float* nocapture, i16*, i32, i32) local_unnamed_addr #3 {
  %5 = alloca [16 x i16], align 16
  %6 = bitcast [16 x i16]* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %6) #5
  %7 = getelementptr inbounds [16 x i16], [16 x i16]* %5, i64 0, i64 0
  %8 = bitcast [16 x i16]* %5 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %8, i8 -86, i64 32, i1 false)
  call void @silk_NLSF2A(i16* nonnull %7, i16* %1, i32 %2, i32 %3) #5
  %9 = icmp sgt i32 %2, 0
  br i1 %9, label %10, label %88

10:                                               ; preds = %4
  %11 = zext i32 %2 to i64
  %12 = icmp ult i32 %2, 8
  br i1 %12, label %77, label %13

13:                                               ; preds = %10
  %14 = and i64 %11, 4294967288
  %15 = add nsw i64 %14, -8
  %16 = lshr exact i64 %15, 3
  %17 = add nuw nsw i64 %16, 1
  %18 = and i64 %17, 1
  %19 = icmp eq i64 %15, 0
  br i1 %19, label %57, label %20

20:                                               ; preds = %13
  %21 = sub nuw nsw i64 %17, %18
  br label %22

22:                                               ; preds = %22, %20
  %23 = phi i64 [ 0, %20 ], [ %54, %22 ]
  %24 = phi i64 [ %21, %20 ], [ %55, %22 ]
  %25 = getelementptr inbounds [16 x i16], [16 x i16]* %5, i64 0, i64 %23
  %26 = bitcast i16* %25 to <4 x i16>*
  %27 = load <4 x i16>, <4 x i16>* %26, align 16
  %28 = getelementptr inbounds i16, i16* %25, i64 4
  %29 = bitcast i16* %28 to <4 x i16>*
  %30 = load <4 x i16>, <4 x i16>* %29, align 8
  %31 = sitofp <4 x i16> %27 to <4 x float>
  %32 = sitofp <4 x i16> %30 to <4 x float>
  %33 = fmul <4 x float> %31, <float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000>
  %34 = fmul <4 x float> %32, <float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000>
  %35 = getelementptr inbounds float, float* %0, i64 %23
  %36 = bitcast float* %35 to <4 x float>*
  store <4 x float> %33, <4 x float>* %36, align 4
  %37 = getelementptr inbounds float, float* %35, i64 4
  %38 = bitcast float* %37 to <4 x float>*
  store <4 x float> %34, <4 x float>* %38, align 4
  %39 = or i64 %23, 8
  %40 = getelementptr inbounds [16 x i16], [16 x i16]* %5, i64 0, i64 %39
  %41 = bitcast i16* %40 to <4 x i16>*
  %42 = load <4 x i16>, <4 x i16>* %41, align 16
  %43 = getelementptr inbounds i16, i16* %40, i64 4
  %44 = bitcast i16* %43 to <4 x i16>*
  %45 = load <4 x i16>, <4 x i16>* %44, align 8
  %46 = sitofp <4 x i16> %42 to <4 x float>
  %47 = sitofp <4 x i16> %45 to <4 x float>
  %48 = fmul <4 x float> %46, <float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000>
  %49 = fmul <4 x float> %47, <float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000>
  %50 = getelementptr inbounds float, float* %0, i64 %39
  %51 = bitcast float* %50 to <4 x float>*
  store <4 x float> %48, <4 x float>* %51, align 4
  %52 = getelementptr inbounds float, float* %50, i64 4
  %53 = bitcast float* %52 to <4 x float>*
  store <4 x float> %49, <4 x float>* %53, align 4
  %54 = add i64 %23, 16
  %55 = add i64 %24, -2
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %57, label %22, !llvm.loop !2

57:                                               ; preds = %22, %13
  %58 = phi i64 [ 0, %13 ], [ %54, %22 ]
  %59 = icmp eq i64 %18, 0
  br i1 %59, label %75, label %60

60:                                               ; preds = %57
  %61 = getelementptr inbounds [16 x i16], [16 x i16]* %5, i64 0, i64 %58
  %62 = bitcast i16* %61 to <4 x i16>*
  %63 = load <4 x i16>, <4 x i16>* %62, align 16
  %64 = getelementptr inbounds i16, i16* %61, i64 4
  %65 = bitcast i16* %64 to <4 x i16>*
  %66 = load <4 x i16>, <4 x i16>* %65, align 8
  %67 = sitofp <4 x i16> %63 to <4 x float>
  %68 = sitofp <4 x i16> %66 to <4 x float>
  %69 = fmul <4 x float> %67, <float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000>
  %70 = fmul <4 x float> %68, <float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000, float 0x3F30000000000000>
  %71 = getelementptr inbounds float, float* %0, i64 %58
  %72 = bitcast float* %71 to <4 x float>*
  store <4 x float> %69, <4 x float>* %72, align 4
  %73 = getelementptr inbounds float, float* %71, i64 4
  %74 = bitcast float* %73 to <4 x float>*
  store <4 x float> %70, <4 x float>* %74, align 4
  br label %75

75:                                               ; preds = %57, %60
  %76 = icmp eq i64 %14, %11
  br i1 %76, label %88, label %77

77:                                               ; preds = %75, %10
  %78 = phi i64 [ 0, %10 ], [ %14, %75 ]
  br label %79

79:                                               ; preds = %77, %79
  %80 = phi i64 [ %86, %79 ], [ %78, %77 ]
  %81 = getelementptr inbounds [16 x i16], [16 x i16]* %5, i64 0, i64 %80
  %82 = load i16, i16* %81, align 2
  %83 = sitofp i16 %82 to float
  %84 = fmul float %83, 0x3F30000000000000
  %85 = getelementptr inbounds float, float* %0, i64 %80
  store float %84, float* %85, align 4
  %86 = add nuw nsw i64 %80, 1
  %87 = icmp eq i64 %86, %11
  br i1 %87, label %88, label %79, !llvm.loop !4

88:                                               ; preds = %79, %75, %4
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %6) #5
  ret void
}

declare void @silk_NLSF2A(i16*, i16*, i32, i32) local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define hidden void @silk_process_NLSFs_FLP(%struct.silk_encoder_state*, [16 x float]* nocapture, i16*, i16*) local_unnamed_addr #3 {
  %5 = alloca [2 x [16 x i16]], align 16
  %6 = bitcast [2 x [16 x i16]]* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 64, i8* nonnull %6) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %6, i8 -86, i64 64, i1 false)
  %7 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %5, i64 0, i64 0
  call void @silk_process_NLSFs(%struct.silk_encoder_state* %0, [16 x i16]* nonnull %7, i16* %2, i16* %3) #5
  %8 = getelementptr inbounds %struct.silk_encoder_state, %struct.silk_encoder_state* %0, i64 0, i32 35
  %9 = load i32, i32* %8, align 8
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %11, label %35

11:                                               ; preds = %4, %11
  %12 = phi i64 [ %18, %11 ], [ 0, %4 ]
  %13 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %5, i64 0, i64 0, i64 %12
  %14 = load i16, i16* %13, align 2
  %15 = sitofp i16 %14 to float
  %16 = fmul float %15, 0x3F30000000000000
  %17 = getelementptr inbounds [16 x float], [16 x float]* %1, i64 0, i64 %12
  store float %16, float* %17, align 4
  %18 = add nuw nsw i64 %12, 1
  %19 = load i32, i32* %8, align 8
  %20 = sext i32 %19 to i64
  %21 = icmp slt i64 %18, %20
  br i1 %21, label %11, label %22

22:                                               ; preds = %11
  %23 = icmp sgt i32 %19, 0
  br i1 %23, label %24, label %35

24:                                               ; preds = %22, %24
  %25 = phi i64 [ %31, %24 ], [ 0, %22 ]
  %26 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %5, i64 0, i64 1, i64 %25
  %27 = load i16, i16* %26, align 2
  %28 = sitofp i16 %27 to float
  %29 = fmul float %28, 0x3F30000000000000
  %30 = getelementptr inbounds [16 x float], [16 x float]* %1, i64 1, i64 %25
  store float %29, float* %30, align 4
  %31 = add nuw nsw i64 %25, 1
  %32 = load i32, i32* %8, align 8
  %33 = sext i32 %32 to i64
  %34 = icmp slt i64 %31, %33
  br i1 %34, label %24, label %35

35:                                               ; preds = %24, %4, %22
  call void @llvm.lifetime.end.p0i8(i64 64, i8* nonnull %6) #5
  ret void
}

declare void @silk_process_NLSFs(%struct.silk_encoder_state*, [16 x i16]*, i16*, i16*) local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define hidden void @silk_NSQ_wrapper_FLP(%struct.silk_encoder_state_FLP*, %struct.silk_encoder_control_FLP*, %struct.SideInfoIndices*, %struct.silk_nsq_state*, i8*, float* nocapture readonly) local_unnamed_addr #0 {
  %7 = alloca [320 x i16], align 16
  %8 = alloca [4 x i32], align 16
  %9 = alloca [2 x [16 x i16]], align 16
  %10 = alloca [20 x i16], align 16
  %11 = alloca [96 x i16], align 16
  %12 = alloca [4 x i32], align 16
  %13 = alloca [4 x i32], align 16
  %14 = alloca [4 x i32], align 16
  %15 = bitcast [320 x i16]* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 640, i8* nonnull %15) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %15, i8 -86, i64 640, i1 false)
  %16 = bitcast [4 x i32]* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %16) #5
  %17 = getelementptr inbounds [4 x i32], [4 x i32]* %8, i64 0, i64 0
  %18 = bitcast [2 x [16 x i16]]* %9 to i8*
  %19 = bitcast [4 x i32]* %8 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %19, i8 -86, i64 16, i1 false)
  call void @llvm.lifetime.start.p0i8(i64 64, i8* nonnull %18) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %18, i8 -86, i64 64, i1 false)
  %20 = bitcast [20 x i16]* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %20) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %20, i8 -86, i64 40, i1 false)
  %21 = bitcast [96 x i16]* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 192, i8* nonnull %21) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %21, i8 -86, i64 192, i1 false)
  %22 = bitcast [4 x i32]* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %22) #5
  %23 = getelementptr inbounds [4 x i32], [4 x i32]* %12, i64 0, i64 0
  %24 = bitcast [4 x i32]* %13 to i8*
  %25 = bitcast [4 x i32]* %12 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %25, i8 -86, i64 16, i1 false)
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %24) #5
  %26 = getelementptr inbounds [4 x i32], [4 x i32]* %13, i64 0, i64 0
  %27 = bitcast [4 x i32]* %14 to i8*
  %28 = bitcast [4 x i32]* %13 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %28, i8 -86, i64 16, i1 false)
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %27) #5
  %29 = getelementptr inbounds [4 x i32], [4 x i32]* %14, i64 0, i64 0
  %30 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0
  %31 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 20
  %32 = bitcast [4 x i32]* %14 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %32, i8 -86, i64 16, i1 false)
  %33 = load i32, i32* %31, align 4
  %34 = icmp sgt i32 %33, 0
  br i1 %34, label %35, label %120

35:                                               ; preds = %6
  %36 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 34
  %37 = load i32, i32* %36, align 4
  %38 = icmp sgt i32 %37, 0
  br i1 %38, label %39, label %88

39:                                               ; preds = %35
  %40 = sext i32 %33 to i64
  %41 = sext i32 %37 to i64
  %42 = and i64 %41, 1
  %43 = icmp eq i32 %37, 1
  %44 = sub nsw i64 %41, %42
  %45 = icmp eq i64 %42, 0
  br label %46

46:                                               ; preds = %39, %84
  %47 = phi i64 [ 0, %39 ], [ %85, %84 ]
  %48 = mul i64 %47, 24
  %49 = and i64 %48, 4294967288
  br i1 %43, label %73, label %50

50:                                               ; preds = %46, %50
  %51 = phi i64 [ %70, %50 ], [ 0, %46 ]
  %52 = phi i64 [ %71, %50 ], [ %44, %46 ]
  %53 = add nuw nsw i64 %51, %49
  %54 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 5, i64 %53
  %55 = load float, float* %54, align 4
  %56 = fmul float %55, 8.192000e+03
  %57 = insertelement <4 x float> undef, float %56, i32 0
  %58 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %57) #5
  %59 = trunc i32 %58 to i16
  %60 = getelementptr inbounds [96 x i16], [96 x i16]* %11, i64 0, i64 %53
  store i16 %59, i16* %60, align 4
  %61 = or i64 %51, 1
  %62 = add nuw nsw i64 %61, %49
  %63 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 5, i64 %62
  %64 = load float, float* %63, align 4
  %65 = fmul float %64, 8.192000e+03
  %66 = insertelement <4 x float> undef, float %65, i32 0
  %67 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %66) #5
  %68 = trunc i32 %67 to i16
  %69 = getelementptr inbounds [96 x i16], [96 x i16]* %11, i64 0, i64 %62
  store i16 %68, i16* %69, align 2
  %70 = add nuw nsw i64 %51, 2
  %71 = add i64 %52, -2
  %72 = icmp eq i64 %71, 0
  br i1 %72, label %73, label %50

73:                                               ; preds = %50, %46
  %74 = phi i64 [ 0, %46 ], [ %70, %50 ]
  br i1 %45, label %84, label %75

75:                                               ; preds = %73
  %76 = add nuw nsw i64 %74, %49
  %77 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 5, i64 %76
  %78 = load float, float* %77, align 4
  %79 = fmul float %78, 8.192000e+03
  %80 = insertelement <4 x float> undef, float %79, i32 0
  %81 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %80) #5
  %82 = trunc i32 %81 to i16
  %83 = getelementptr inbounds [96 x i16], [96 x i16]* %11, i64 0, i64 %76
  store i16 %82, i16* %83, align 2
  br label %84

84:                                               ; preds = %73, %75
  %85 = add nuw nsw i64 %47, 1
  %86 = icmp slt i64 %85, %40
  br i1 %86, label %46, label %87

87:                                               ; preds = %84
  br i1 %34, label %88, label %120

88:                                               ; preds = %35, %87
  %89 = zext i32 %33 to i64
  br label %90

90:                                               ; preds = %90, %88
  %91 = phi i64 [ 0, %88 ], [ %118, %90 ]
  %92 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 7, i64 %91
  %93 = load float, float* %92, align 4
  %94 = fmul float %93, 1.638400e+04
  %95 = insertelement <4 x float> undef, float %94, i32 0
  %96 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %95) #5
  %97 = shl i32 %96, 16
  %98 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 6, i64 %91
  %99 = load float, float* %98, align 4
  %100 = fmul float %99, 1.638400e+04
  %101 = insertelement <4 x float> undef, float %100, i32 0
  %102 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %101) #5
  %103 = and i32 %102, 65535
  %104 = or i32 %103, %97
  %105 = getelementptr inbounds [4 x i32], [4 x i32]* %12, i64 0, i64 %91
  store i32 %104, i32* %105, align 4
  %106 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 8, i64 %91
  %107 = load float, float* %106, align 4
  %108 = fmul float %107, 1.638400e+04
  %109 = insertelement <4 x float> undef, float %108, i32 0
  %110 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %109) #5
  %111 = getelementptr inbounds [4 x i32], [4 x i32]* %13, i64 0, i64 %91
  store i32 %110, i32* %111, align 4
  %112 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 9, i64 %91
  %113 = load float, float* %112, align 4
  %114 = fmul float %113, 1.638400e+04
  %115 = insertelement <4 x float> undef, float %114, i32 0
  %116 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %115) #5
  %117 = getelementptr inbounds [4 x i32], [4 x i32]* %14, i64 0, i64 %91
  store i32 %116, i32* %117, align 4
  %118 = add nuw nsw i64 %91, 1
  %119 = icmp eq i64 %118, %89
  br i1 %119, label %126, label %90

120:                                              ; preds = %87, %6
  %121 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 10
  %122 = load float, float* %121, align 4
  %123 = fmul float %122, 1.024000e+03
  %124 = insertelement <4 x float> undef, float %123, i32 0
  %125 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %124) #5
  br label %135

126:                                              ; preds = %90
  %127 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 10
  %128 = load float, float* %127, align 4
  %129 = fmul float %128, 1.024000e+03
  %130 = insertelement <4 x float> undef, float %129, i32 0
  %131 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %130) #5
  br i1 %34, label %132, label %135

132:                                              ; preds = %126
  %133 = mul nsw i32 %33, 5
  %134 = sext i32 %133 to i64
  br label %183

135:                                              ; preds = %183, %120, %126
  %136 = phi i32 [ %125, %120 ], [ %131, %126 ], [ %131, %183 ]
  %137 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 35
  %138 = load i32, i32* %137, align 8
  %139 = icmp sgt i32 %138, 0
  br i1 %139, label %140, label %205

140:                                              ; preds = %135
  %141 = sext i32 %138 to i64
  %142 = and i64 %141, 1
  %143 = icmp eq i32 %138, 1
  br i1 %143, label %167, label %144

144:                                              ; preds = %140
  %145 = sub nsw i64 %141, %142
  br label %146

146:                                              ; preds = %146, %144
  %147 = phi i64 [ 0, %144 ], [ %164, %146 ]
  %148 = phi i64 [ %145, %144 ], [ %165, %146 ]
  %149 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 1, i64 0, i64 %147
  %150 = load float, float* %149, align 4
  %151 = fmul float %150, 4.096000e+03
  %152 = insertelement <4 x float> undef, float %151, i32 0
  %153 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %152) #5
  %154 = trunc i32 %153 to i16
  %155 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 0, i64 %147
  store i16 %154, i16* %155, align 4
  %156 = or i64 %147, 1
  %157 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 1, i64 0, i64 %156
  %158 = load float, float* %157, align 4
  %159 = fmul float %158, 4.096000e+03
  %160 = insertelement <4 x float> undef, float %159, i32 0
  %161 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %160) #5
  %162 = trunc i32 %161 to i16
  %163 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 0, i64 %156
  store i16 %162, i16* %163, align 2
  %164 = add nuw nsw i64 %147, 2
  %165 = add i64 %148, -2
  %166 = icmp eq i64 %165, 0
  br i1 %166, label %167, label %146

167:                                              ; preds = %146, %140
  %168 = phi i64 [ 0, %140 ], [ %164, %146 ]
  %169 = icmp eq i64 %142, 0
  br i1 %169, label %178, label %170

170:                                              ; preds = %167
  %171 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 1, i64 0, i64 %168
  %172 = load float, float* %171, align 4
  %173 = fmul float %172, 4.096000e+03
  %174 = insertelement <4 x float> undef, float %173, i32 0
  %175 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %174) #5
  %176 = trunc i32 %175 to i16
  %177 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 0, i64 %168
  store i16 %176, i16* %177, align 2
  br label %178

178:                                              ; preds = %167, %170
  %179 = and i64 %141, 1
  %180 = icmp eq i32 %138, 1
  br i1 %180, label %194, label %181

181:                                              ; preds = %178
  %182 = sub nsw i64 %141, %179
  br label %333

183:                                              ; preds = %132, %183
  %184 = phi i64 [ 0, %132 ], [ %192, %183 ]
  %185 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 2, i64 %184
  %186 = load float, float* %185, align 4
  %187 = fmul float %186, 1.638400e+04
  %188 = insertelement <4 x float> undef, float %187, i32 0
  %189 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %188) #5
  %190 = trunc i32 %189 to i16
  %191 = getelementptr inbounds [20 x i16], [20 x i16]* %10, i64 0, i64 %184
  store i16 %190, i16* %191, align 2
  %192 = add nuw nsw i64 %184, 1
  %193 = icmp slt i64 %192, %134
  br i1 %193, label %183, label %135

194:                                              ; preds = %333, %178
  %195 = phi i64 [ 0, %178 ], [ %351, %333 ]
  %196 = icmp eq i64 %179, 0
  br i1 %196, label %205, label %197

197:                                              ; preds = %194
  %198 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 1, i64 1, i64 %195
  %199 = load float, float* %198, align 4
  %200 = fmul float %199, 4.096000e+03
  %201 = insertelement <4 x float> undef, float %200, i32 0
  %202 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %201) #5
  %203 = trunc i32 %202 to i16
  %204 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 1, i64 %195
  store i16 %203, i16* %204, align 2
  br label %205

205:                                              ; preds = %197, %194, %135
  br i1 %34, label %206, label %241

206:                                              ; preds = %205
  %207 = zext i32 %33 to i64
  %208 = and i64 %207, 1
  %209 = icmp eq i32 %33, 1
  br i1 %209, label %231, label %210

210:                                              ; preds = %206
  %211 = sub nsw i64 %207, %208
  br label %212

212:                                              ; preds = %212, %210
  %213 = phi i64 [ 0, %210 ], [ %228, %212 ]
  %214 = phi i64 [ %211, %210 ], [ %229, %212 ]
  %215 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 0, i64 %213
  %216 = load float, float* %215, align 4
  %217 = fmul float %216, 6.553600e+04
  %218 = insertelement <4 x float> undef, float %217, i32 0
  %219 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %218) #5
  %220 = getelementptr inbounds [4 x i32], [4 x i32]* %8, i64 0, i64 %213
  store i32 %219, i32* %220, align 8
  %221 = or i64 %213, 1
  %222 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 0, i64 %221
  %223 = load float, float* %222, align 4
  %224 = fmul float %223, 6.553600e+04
  %225 = insertelement <4 x float> undef, float %224, i32 0
  %226 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %225) #5
  %227 = getelementptr inbounds [4 x i32], [4 x i32]* %8, i64 0, i64 %221
  store i32 %226, i32* %227, align 4
  %228 = add nuw nsw i64 %213, 2
  %229 = add i64 %214, -2
  %230 = icmp eq i64 %229, 0
  br i1 %230, label %231, label %212

231:                                              ; preds = %212, %206
  %232 = phi i64 [ 0, %206 ], [ %228, %212 ]
  %233 = icmp eq i64 %208, 0
  br i1 %233, label %241, label %234

234:                                              ; preds = %231
  %235 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 0, i64 %232
  %236 = load float, float* %235, align 4
  %237 = fmul float %236, 6.553600e+04
  %238 = insertelement <4 x float> undef, float %237, i32 0
  %239 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %238) #5
  %240 = getelementptr inbounds [4 x i32], [4 x i32]* %8, i64 0, i64 %232
  store i32 %239, i32* %240, align 4
  br label %241

241:                                              ; preds = %234, %231, %205
  %242 = getelementptr inbounds %struct.SideInfoIndices, %struct.SideInfoIndices* %2, i64 0, i32 5
  %243 = load i8, i8* %242, align 1
  %244 = icmp eq i8 %243, 2
  br i1 %244, label %245, label %252

245:                                              ; preds = %241
  %246 = getelementptr inbounds %struct.SideInfoIndices, %struct.SideInfoIndices* %2, i64 0, i32 9
  %247 = load i8, i8* %246, align 1
  %248 = sext i8 %247 to i64
  %249 = getelementptr inbounds [3 x i16], [3 x i16]* @silk_LTPScales_table_Q14, i64 0, i64 %248
  %250 = load i16, i16* %249, align 2
  %251 = sext i16 %250 to i32
  br label %252

252:                                              ; preds = %241, %245
  %253 = phi i32 [ %251, %245 ], [ 0, %241 ]
  %254 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 21
  %255 = load i32, i32* %254, align 8
  %256 = icmp sgt i32 %255, 0
  br i1 %256, label %257, label %312

257:                                              ; preds = %252
  %258 = sext i32 %255 to i64
  %259 = add nsw i64 %258, -1
  %260 = and i64 %258, 3
  %261 = icmp ult i64 %259, 3
  br i1 %261, label %297, label %262

262:                                              ; preds = %257
  %263 = sub nsw i64 %258, %260
  br label %264

264:                                              ; preds = %264, %262
  %265 = phi i64 [ 0, %262 ], [ %294, %264 ]
  %266 = phi i64 [ %263, %262 ], [ %295, %264 ]
  %267 = getelementptr inbounds float, float* %5, i64 %265
  %268 = load float, float* %267, align 4
  %269 = insertelement <4 x float> undef, float %268, i32 0
  %270 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %269) #5
  %271 = trunc i32 %270 to i16
  %272 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 %265
  store i16 %271, i16* %272, align 8
  %273 = or i64 %265, 1
  %274 = getelementptr inbounds float, float* %5, i64 %273
  %275 = load float, float* %274, align 4
  %276 = insertelement <4 x float> undef, float %275, i32 0
  %277 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %276) #5
  %278 = trunc i32 %277 to i16
  %279 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 %273
  store i16 %278, i16* %279, align 2
  %280 = or i64 %265, 2
  %281 = getelementptr inbounds float, float* %5, i64 %280
  %282 = load float, float* %281, align 4
  %283 = insertelement <4 x float> undef, float %282, i32 0
  %284 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %283) #5
  %285 = trunc i32 %284 to i16
  %286 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 %280
  store i16 %285, i16* %286, align 4
  %287 = or i64 %265, 3
  %288 = getelementptr inbounds float, float* %5, i64 %287
  %289 = load float, float* %288, align 4
  %290 = insertelement <4 x float> undef, float %289, i32 0
  %291 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %290) #5
  %292 = trunc i32 %291 to i16
  %293 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 %287
  store i16 %292, i16* %293, align 2
  %294 = add nuw nsw i64 %265, 4
  %295 = add i64 %266, -4
  %296 = icmp eq i64 %295, 0
  br i1 %296, label %297, label %264

297:                                              ; preds = %264, %257
  %298 = phi i64 [ 0, %257 ], [ %294, %264 ]
  %299 = icmp eq i64 %260, 0
  br i1 %299, label %312, label %300

300:                                              ; preds = %297, %300
  %301 = phi i64 [ %309, %300 ], [ %298, %297 ]
  %302 = phi i64 [ %310, %300 ], [ %260, %297 ]
  %303 = getelementptr inbounds float, float* %5, i64 %301
  %304 = load float, float* %303, align 4
  %305 = insertelement <4 x float> undef, float %304, i32 0
  %306 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %305) #5
  %307 = trunc i32 %306 to i16
  %308 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 %301
  store i16 %307, i16* %308, align 2
  %309 = add nuw nsw i64 %301, 1
  %310 = add i64 %302, -1
  %311 = icmp eq i64 %310, 0
  br i1 %311, label %312, label %300, !llvm.loop !6

312:                                              ; preds = %297, %300, %252
  %313 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 32
  %314 = load i32, i32* %313, align 4
  %315 = icmp sgt i32 %314, 1
  br i1 %315, label %320, label %316

316:                                              ; preds = %312
  %317 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 43
  %318 = load i32, i32* %317, align 8
  %319 = icmp sgt i32 %318, 0
  br i1 %319, label %320, label %326

320:                                              ; preds = %316, %312
  %321 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 0
  %322 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 0, i64 0
  %323 = getelementptr inbounds [20 x i16], [20 x i16]* %10, i64 0, i64 0
  %324 = getelementptr inbounds [96 x i16], [96 x i16]* %11, i64 0, i64 0
  %325 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 4, i64 0
  call void @silk_NSQ_del_dec_c(%struct.silk_encoder_state* %30, %struct.silk_nsq_state* %3, %struct.SideInfoIndices* %2, i16* nonnull %321, i8* %4, i16* nonnull %322, i16* nonnull %323, i16* nonnull %324, i32* nonnull %29, i32* nonnull %26, i32* nonnull %23, i32* nonnull %17, i32* %325, i32 %136, i32 %253) #5
  br label %332

326:                                              ; preds = %316
  %327 = getelementptr inbounds [320 x i16], [320 x i16]* %7, i64 0, i64 0
  %328 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 0, i64 0
  %329 = getelementptr inbounds [20 x i16], [20 x i16]* %10, i64 0, i64 0
  %330 = getelementptr inbounds [96 x i16], [96 x i16]* %11, i64 0, i64 0
  %331 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 4, i64 0
  call void @silk_NSQ_c(%struct.silk_encoder_state* %30, %struct.silk_nsq_state* %3, %struct.SideInfoIndices* %2, i16* nonnull %327, i8* %4, i16* nonnull %328, i16* nonnull %329, i16* nonnull %330, i32* nonnull %29, i32* nonnull %26, i32* nonnull %23, i32* nonnull %17, i32* %331, i32 %136, i32 %253) #5
  br label %332

332:                                              ; preds = %326, %320
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %27) #5
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %24) #5
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %22) #5
  call void @llvm.lifetime.end.p0i8(i64 192, i8* nonnull %21) #5
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %20) #5
  call void @llvm.lifetime.end.p0i8(i64 64, i8* nonnull %18) #5
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %16) #5
  call void @llvm.lifetime.end.p0i8(i64 640, i8* nonnull %15) #5
  ret void

333:                                              ; preds = %333, %181
  %334 = phi i64 [ 0, %181 ], [ %351, %333 ]
  %335 = phi i64 [ %182, %181 ], [ %352, %333 ]
  %336 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 1, i64 1, i64 %334
  %337 = load float, float* %336, align 4
  %338 = fmul float %337, 4.096000e+03
  %339 = insertelement <4 x float> undef, float %338, i32 0
  %340 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %339) #5
  %341 = trunc i32 %340 to i16
  %342 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 1, i64 %334
  store i16 %341, i16* %342, align 4
  %343 = or i64 %334, 1
  %344 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %1, i64 0, i32 1, i64 1, i64 %343
  %345 = load float, float* %344, align 4
  %346 = fmul float %345, 4.096000e+03
  %347 = insertelement <4 x float> undef, float %346, i32 0
  %348 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %347) #5
  %349 = trunc i32 %348 to i16
  %350 = getelementptr inbounds [2 x [16 x i16]], [2 x [16 x i16]]* %9, i64 0, i64 1, i64 %343
  store i16 %349, i16* %350, align 2
  %351 = add nuw nsw i64 %334, 2
  %352 = add i64 %335, -2
  %353 = icmp eq i64 %352, 0
  br i1 %353, label %194, label %333
}

declare void @silk_NSQ_del_dec_c(%struct.silk_encoder_state*, %struct.silk_nsq_state*, %struct.SideInfoIndices*, i16*, i8*, i16*, i16*, i16*, i32*, i32*, i32*, i32*, i32*, i32, i32) local_unnamed_addr #2

declare void @silk_NSQ_c(%struct.silk_encoder_state*, %struct.silk_nsq_state*, %struct.SideInfoIndices*, i16*, i8*, i16*, i16*, i16*, i32*, i32*, i32*, i32*, i32*, i32, i32) local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define hidden void @silk_quant_LTP_gains_FLP(float* nocapture, i8*, i8*, i32*, float* nocapture, float* nocapture readonly, float* nocapture readonly, i32, i32, i32) local_unnamed_addr #0 {
  %11 = alloca i32, align 4
  %12 = alloca [20 x i16], align 16
  %13 = alloca [100 x i32], align 16
  %14 = alloca [20 x i32], align 16
  %15 = bitcast i32* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %15) #5
  store i32 -1431655766, i32* %11, align 4
  %16 = bitcast [20 x i16]* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %16) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %16, i8 -86, i64 40, i1 false)
  %17 = bitcast [100 x i32]* %13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 400, i8* nonnull %17) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %17, i8 -86, i64 400, i1 false)
  %18 = bitcast [20 x i32]* %14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 80, i8* nonnull %18) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %18, i8 -86, i64 80, i1 false)
  %19 = mul nsw i32 %8, 5
  %20 = mul i32 %8, 25
  %21 = icmp sgt i32 %20, 0
  br i1 %21, label %22, label %38

22:                                               ; preds = %10
  %23 = zext i32 %20 to i64
  %24 = and i64 %23, 1
  %25 = icmp eq i32 %20, 1
  br i1 %25, label %28, label %26

26:                                               ; preds = %22
  %27 = sub nsw i64 %23, %24
  br label %42

28:                                               ; preds = %42, %22
  %29 = phi i64 [ 0, %22 ], [ %58, %42 ]
  %30 = icmp eq i64 %24, 0
  br i1 %30, label %38, label %31

31:                                               ; preds = %28
  %32 = getelementptr inbounds float, float* %5, i64 %29
  %33 = load float, float* %32, align 4
  %34 = fmul float %33, 1.310720e+05
  %35 = insertelement <4 x float> undef, float %34, i32 0
  %36 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %35) #5
  %37 = getelementptr inbounds [100 x i32], [100 x i32]* %13, i64 0, i64 %29
  store i32 %36, i32* %37, align 4
  br label %38

38:                                               ; preds = %31, %28, %10
  %39 = icmp sgt i32 %8, 0
  br i1 %39, label %40, label %155

40:                                               ; preds = %38
  %41 = sext i32 %19 to i64
  br label %61

42:                                               ; preds = %42, %26
  %43 = phi i64 [ 0, %26 ], [ %58, %42 ]
  %44 = phi i64 [ %27, %26 ], [ %59, %42 ]
  %45 = getelementptr inbounds float, float* %5, i64 %43
  %46 = load float, float* %45, align 4
  %47 = fmul float %46, 1.310720e+05
  %48 = insertelement <4 x float> undef, float %47, i32 0
  %49 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %48) #5
  %50 = getelementptr inbounds [100 x i32], [100 x i32]* %13, i64 0, i64 %43
  store i32 %49, i32* %50, align 8
  %51 = or i64 %43, 1
  %52 = getelementptr inbounds float, float* %5, i64 %51
  %53 = load float, float* %52, align 4
  %54 = fmul float %53, 1.310720e+05
  %55 = insertelement <4 x float> undef, float %54, i32 0
  %56 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %55) #5
  %57 = getelementptr inbounds [100 x i32], [100 x i32]* %13, i64 0, i64 %51
  store i32 %56, i32* %57, align 4
  %58 = add nuw nsw i64 %43, 2
  %59 = add i64 %44, -2
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %28, label %42

61:                                               ; preds = %40, %61
  %62 = phi i64 [ 0, %40 ], [ %69, %61 ]
  %63 = getelementptr inbounds float, float* %6, i64 %62
  %64 = load float, float* %63, align 4
  %65 = fmul float %64, 1.310720e+05
  %66 = insertelement <4 x float> undef, float %65, i32 0
  %67 = tail call i32 @llvm.x86.sse.cvtss2si(<4 x float> %66) #5
  %68 = getelementptr inbounds [20 x i32], [20 x i32]* %14, i64 0, i64 %62
  store i32 %67, i32* %68, align 4
  %69 = add nuw nsw i64 %62, 1
  %70 = icmp slt i64 %69, %41
  br i1 %70, label %61, label %71

71:                                               ; preds = %61
  %72 = getelementptr inbounds [20 x i16], [20 x i16]* %12, i64 0, i64 0
  %73 = getelementptr inbounds [100 x i32], [100 x i32]* %13, i64 0, i64 0
  %74 = getelementptr inbounds [20 x i32], [20 x i32]* %14, i64 0, i64 0
  call void @silk_quant_LTP_gains(i16* nonnull %72, i8* %1, i8* %2, i32* %3, i32* nonnull %11, i32* nonnull %73, i32* nonnull %74, i32 %7, i32 %8, i32 %9) #5
  br i1 %39, label %75, label %159

75:                                               ; preds = %71
  %76 = sext i32 %19 to i64
  %77 = icmp sgt i64 %76, 1
  %78 = select i1 %77, i64 %76, i64 1
  %79 = icmp ult i64 %78, 8
  br i1 %79, label %144, label %80

80:                                               ; preds = %75
  %81 = and i64 %78, 9223372036854775800
  %82 = add nsw i64 %81, -8
  %83 = lshr exact i64 %82, 3
  %84 = add nuw nsw i64 %83, 1
  %85 = and i64 %84, 1
  %86 = icmp eq i64 %82, 0
  br i1 %86, label %124, label %87

87:                                               ; preds = %80
  %88 = sub nuw nsw i64 %84, %85
  br label %89

89:                                               ; preds = %89, %87
  %90 = phi i64 [ 0, %87 ], [ %121, %89 ]
  %91 = phi i64 [ %88, %87 ], [ %122, %89 ]
  %92 = getelementptr inbounds [20 x i16], [20 x i16]* %12, i64 0, i64 %90
  %93 = bitcast i16* %92 to <4 x i16>*
  %94 = load <4 x i16>, <4 x i16>* %93, align 16
  %95 = getelementptr inbounds i16, i16* %92, i64 4
  %96 = bitcast i16* %95 to <4 x i16>*
  %97 = load <4 x i16>, <4 x i16>* %96, align 8
  %98 = sitofp <4 x i16> %94 to <4 x float>
  %99 = sitofp <4 x i16> %97 to <4 x float>
  %100 = fmul <4 x float> %98, <float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000>
  %101 = fmul <4 x float> %99, <float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000>
  %102 = getelementptr inbounds float, float* %0, i64 %90
  %103 = bitcast float* %102 to <4 x float>*
  store <4 x float> %100, <4 x float>* %103, align 4
  %104 = getelementptr inbounds float, float* %102, i64 4
  %105 = bitcast float* %104 to <4 x float>*
  store <4 x float> %101, <4 x float>* %105, align 4
  %106 = or i64 %90, 8
  %107 = getelementptr inbounds [20 x i16], [20 x i16]* %12, i64 0, i64 %106
  %108 = bitcast i16* %107 to <4 x i16>*
  %109 = load <4 x i16>, <4 x i16>* %108, align 16
  %110 = getelementptr inbounds i16, i16* %107, i64 4
  %111 = bitcast i16* %110 to <4 x i16>*
  %112 = load <4 x i16>, <4 x i16>* %111, align 8
  %113 = sitofp <4 x i16> %109 to <4 x float>
  %114 = sitofp <4 x i16> %112 to <4 x float>
  %115 = fmul <4 x float> %113, <float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000>
  %116 = fmul <4 x float> %114, <float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000>
  %117 = getelementptr inbounds float, float* %0, i64 %106
  %118 = bitcast float* %117 to <4 x float>*
  store <4 x float> %115, <4 x float>* %118, align 4
  %119 = getelementptr inbounds float, float* %117, i64 4
  %120 = bitcast float* %119 to <4 x float>*
  store <4 x float> %116, <4 x float>* %120, align 4
  %121 = add i64 %90, 16
  %122 = add i64 %91, -2
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %124, label %89, !llvm.loop !8

124:                                              ; preds = %89, %80
  %125 = phi i64 [ 0, %80 ], [ %121, %89 ]
  %126 = icmp eq i64 %85, 0
  br i1 %126, label %142, label %127

127:                                              ; preds = %124
  %128 = getelementptr inbounds [20 x i16], [20 x i16]* %12, i64 0, i64 %125
  %129 = bitcast i16* %128 to <4 x i16>*
  %130 = load <4 x i16>, <4 x i16>* %129, align 16
  %131 = getelementptr inbounds i16, i16* %128, i64 4
  %132 = bitcast i16* %131 to <4 x i16>*
  %133 = load <4 x i16>, <4 x i16>* %132, align 8
  %134 = sitofp <4 x i16> %130 to <4 x float>
  %135 = sitofp <4 x i16> %133 to <4 x float>
  %136 = fmul <4 x float> %134, <float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000>
  %137 = fmul <4 x float> %135, <float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000, float 0x3F10000000000000>
  %138 = getelementptr inbounds float, float* %0, i64 %125
  %139 = bitcast float* %138 to <4 x float>*
  store <4 x float> %136, <4 x float>* %139, align 4
  %140 = getelementptr inbounds float, float* %138, i64 4
  %141 = bitcast float* %140 to <4 x float>*
  store <4 x float> %137, <4 x float>* %141, align 4
  br label %142

142:                                              ; preds = %124, %127
  %143 = icmp eq i64 %78, %81
  br i1 %143, label %159, label %144

144:                                              ; preds = %142, %75
  %145 = phi i64 [ 0, %75 ], [ %81, %142 ]
  br label %146

146:                                              ; preds = %144, %146
  %147 = phi i64 [ %153, %146 ], [ %145, %144 ]
  %148 = getelementptr inbounds [20 x i16], [20 x i16]* %12, i64 0, i64 %147
  %149 = load i16, i16* %148, align 2
  %150 = sitofp i16 %149 to float
  %151 = fmul float %150, 0x3F10000000000000
  %152 = getelementptr inbounds float, float* %0, i64 %147
  store float %151, float* %152, align 4
  %153 = add nuw nsw i64 %147, 1
  %154 = icmp slt i64 %153, %76
  br i1 %154, label %146, label %159, !llvm.loop !9

155:                                              ; preds = %38
  %156 = getelementptr inbounds [20 x i16], [20 x i16]* %12, i64 0, i64 0
  %157 = getelementptr inbounds [100 x i32], [100 x i32]* %13, i64 0, i64 0
  %158 = getelementptr inbounds [20 x i32], [20 x i32]* %14, i64 0, i64 0
  call void @silk_quant_LTP_gains(i16* nonnull %156, i8* %1, i8* %2, i32* %3, i32* nonnull %11, i32* nonnull %157, i32* nonnull %158, i32 %7, i32 %8, i32 %9) #5
  br label %159

159:                                              ; preds = %146, %142, %155, %71
  %160 = load i32, i32* %11, align 4
  %161 = sitofp i32 %160 to float
  %162 = fmul float %161, 7.812500e-03
  store float %162, float* %4, align 4
  call void @llvm.lifetime.end.p0i8(i64 80, i8* nonnull %18) #5
  call void @llvm.lifetime.end.p0i8(i64 400, i8* nonnull %17) #5
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %16) #5
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %15) #5
  ret void
}

declare void @silk_quant_LTP_gains(i16*, i8*, i8*, i32*, i32*, i32*, i32*, i32, i32, i32) local_unnamed_addr #2

; Function Attrs: nounwind readnone
declare i32 @llvm.x86.sse.cvtss2si(<4 x float>) #4

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="128" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = distinct !{!2, !3}
!3 = !{!"llvm.loop.isvectorized", i32 1}
!4 = distinct !{!4, !5, !3}
!5 = !{!"llvm.loop.unroll.runtime.disable"}
!6 = distinct !{!6, !7}
!7 = !{!"llvm.loop.unroll.disable"}
!8 = distinct !{!8, !3}
!9 = distinct !{!9, !5, !3}
