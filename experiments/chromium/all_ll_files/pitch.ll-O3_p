; ModuleID = '../../third_party/opus/src/celt/pitch.c'
source_filename = "../../third_party/opus/src/celt/pitch.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"
module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"

@.str = private unnamed_addr constant [30 x i8] c"assertion failed: max_pitch>0\00", align 1
@.str.1 = private unnamed_addr constant [40 x i8] c"../../third_party/opus/src/celt/pitch.c\00", align 1
@.str.2 = private unnamed_addr constant [24 x i8] c"assertion failed: len>0\00", align 1
@second_check = internal unnamed_addr constant [16 x i32] [i32 0, i32 0, i32 3, i32 2, i32 3, i32 2, i32 5, i32 2, i32 3, i32 2, i32 3, i32 2, i32 5, i32 2, i32 3, i32 2], align 16

; Function Attrs: nounwind ssp uwtable
define hidden void @pitch_downsample(float** nocapture readonly, float* noalias, i32, i32, i32) local_unnamed_addr #0 {
  %6 = alloca [5 x float], align 16
  %7 = alloca <4 x float>, align 16
  %8 = bitcast [5 x float]* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 20, i8* nonnull %8) #4
  %9 = getelementptr inbounds [5 x float], [5 x float]* %6, i64 0, i64 0
  %10 = getelementptr inbounds [5 x float], [5 x float]* %6, i64 0, i64 4
  %11 = bitcast <4 x float>* %7 to i8*
  %12 = bitcast [5 x float]* %6 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %12, i8 -1, i64 20, i1 false)
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %11) #4
  %13 = getelementptr inbounds <4 x float>, <4 x float>* %7, i64 0, i64 0
  %14 = ashr i32 %2, 1
  %15 = icmp sgt i32 %2, 3
  %16 = bitcast <4 x float>* %7 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %16, i8 -1, i64 16, i1 false)
  %17 = load float*, float** %0, align 8
  br i1 %15, label %18, label %85

18:                                               ; preds = %5
  %19 = sext i32 %14 to i64
  %20 = icmp sgt i64 %19, 2
  %21 = select i1 %20, i64 %19, i64 2
  %22 = add nsw i64 %21, -1
  %23 = icmp ult i64 %22, 5
  br i1 %23, label %65, label %24

24:                                               ; preds = %18
  %25 = getelementptr float, float* %1, i64 1
  %26 = icmp sgt i64 %19, 2
  %27 = select i1 %26, i64 %19, i64 2
  %28 = getelementptr float, float* %1, i64 %27
  %29 = getelementptr float, float* %17, i64 1
  %30 = shl nuw nsw i64 %27, 1
  %31 = getelementptr float, float* %17, i64 %30
  %32 = icmp ult float* %25, %31
  %33 = icmp ult float* %29, %28
  %34 = and i1 %32, %33
  br i1 %34, label %65, label %35

35:                                               ; preds = %24
  %36 = and i64 %22, 3
  %37 = icmp eq i64 %36, 0
  %38 = select i1 %37, i64 4, i64 %36
  %39 = sub nsw i64 %22, %38
  %40 = add nsw i64 %39, 1
  %41 = getelementptr inbounds float, float* %17, i64 -1
  br label %42

42:                                               ; preds = %42, %35
  %43 = phi i64 [ 0, %35 ], [ %63, %42 ]
  %44 = or i64 %43, 1
  %45 = shl nuw nsw i64 %44, 1
  %46 = add nsw i64 %45, -1
  %47 = getelementptr inbounds float, float* %17, i64 %46
  %48 = bitcast float* %47 to <8 x float>*
  %49 = load <8 x float>, <8 x float>* %48, align 4
  %50 = shufflevector <8 x float> %49, <8 x float> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %51 = or i64 %45, 1
  %52 = getelementptr inbounds float, float* %41, i64 %51
  %53 = bitcast float* %52 to <8 x float>*
  %54 = load <8 x float>, <8 x float>* %53, align 4
  %55 = shufflevector <8 x float> %54, <8 x float> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %56 = shufflevector <8 x float> %54, <8 x float> undef, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  %57 = fadd <4 x float> %50, %56
  %58 = fmul <4 x float> %57, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %59 = fadd <4 x float> %55, %58
  %60 = fmul <4 x float> %59, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %61 = getelementptr inbounds float, float* %1, i64 %44
  %62 = bitcast float* %61 to <4 x float>*
  store <4 x float> %60, <4 x float>* %62, align 4, !alias.scope !2, !noalias !5
  %63 = add i64 %43, 4
  %64 = icmp eq i64 %63, %39
  br i1 %64, label %65, label %42, !llvm.loop !7

65:                                               ; preds = %42, %24, %18
  %66 = phi i64 [ 1, %24 ], [ 1, %18 ], [ %40, %42 ]
  br label %67

67:                                               ; preds = %65, %67
  %68 = phi i64 [ %83, %67 ], [ %66, %65 ]
  %69 = shl nuw nsw i64 %68, 1
  %70 = add nsw i64 %69, -1
  %71 = getelementptr inbounds float, float* %17, i64 %70
  %72 = load float, float* %71, align 4
  %73 = or i64 %69, 1
  %74 = getelementptr inbounds float, float* %17, i64 %73
  %75 = load float, float* %74, align 4
  %76 = fadd float %72, %75
  %77 = fmul float %76, 5.000000e-01
  %78 = getelementptr inbounds float, float* %17, i64 %69
  %79 = load float, float* %78, align 4
  %80 = fadd float %79, %77
  %81 = fmul float %80, 5.000000e-01
  %82 = getelementptr inbounds float, float* %1, i64 %68
  store float %81, float* %82, align 4
  %83 = add nuw nsw i64 %68, 1
  %84 = icmp slt i64 %83, %19
  br i1 %84, label %67, label %85, !llvm.loop !9

85:                                               ; preds = %67, %5
  %86 = getelementptr inbounds float, float* %17, i64 1
  %87 = load float, float* %86, align 4
  %88 = fmul float %87, 5.000000e-01
  %89 = load float, float* %17, align 4
  %90 = fadd float %88, %89
  %91 = fmul float %90, 5.000000e-01
  store float %91, float* %1, align 4
  %92 = icmp eq i32 %3, 2
  br i1 %92, label %93, label %179

93:                                               ; preds = %85
  %94 = getelementptr inbounds float*, float** %0, i64 1
  %95 = load float*, float** %94, align 8
  br i1 %15, label %96, label %170

96:                                               ; preds = %93
  %97 = sext i32 %14 to i64
  %98 = icmp sgt i64 %97, 2
  %99 = select i1 %98, i64 %97, i64 2
  %100 = add nsw i64 %99, -1
  %101 = icmp ult i64 %100, 5
  br i1 %101, label %146, label %102

102:                                              ; preds = %96
  %103 = getelementptr float, float* %1, i64 1
  %104 = icmp sgt i64 %97, 2
  %105 = select i1 %104, i64 %97, i64 2
  %106 = getelementptr float, float* %1, i64 %105
  %107 = getelementptr float, float* %95, i64 1
  %108 = shl nuw nsw i64 %105, 1
  %109 = getelementptr float, float* %95, i64 %108
  %110 = icmp ult float* %103, %109
  %111 = icmp ult float* %107, %106
  %112 = and i1 %110, %111
  br i1 %112, label %146, label %113

113:                                              ; preds = %102
  %114 = and i64 %100, 3
  %115 = icmp eq i64 %114, 0
  %116 = select i1 %115, i64 4, i64 %114
  %117 = sub nsw i64 %100, %116
  %118 = add nsw i64 %117, 1
  %119 = getelementptr inbounds float, float* %95, i64 -1
  br label %120

120:                                              ; preds = %120, %113
  %121 = phi i64 [ 0, %113 ], [ %144, %120 ]
  %122 = or i64 %121, 1
  %123 = shl nuw nsw i64 %122, 1
  %124 = add nsw i64 %123, -1
  %125 = getelementptr inbounds float, float* %95, i64 %124
  %126 = bitcast float* %125 to <8 x float>*
  %127 = load <8 x float>, <8 x float>* %126, align 4
  %128 = shufflevector <8 x float> %127, <8 x float> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %129 = or i64 %123, 1
  %130 = getelementptr inbounds float, float* %119, i64 %129
  %131 = bitcast float* %130 to <8 x float>*
  %132 = load <8 x float>, <8 x float>* %131, align 4
  %133 = shufflevector <8 x float> %132, <8 x float> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %134 = shufflevector <8 x float> %132, <8 x float> undef, <4 x i32> <i32 1, i32 3, i32 5, i32 7>
  %135 = fadd <4 x float> %128, %134
  %136 = fmul <4 x float> %135, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %137 = fadd <4 x float> %133, %136
  %138 = fmul <4 x float> %137, <float 5.000000e-01, float 5.000000e-01, float 5.000000e-01, float 5.000000e-01>
  %139 = getelementptr inbounds float, float* %1, i64 %122
  %140 = bitcast float* %139 to <4 x float>*
  %141 = load <4 x float>, <4 x float>* %140, align 4, !alias.scope !10, !noalias !13
  %142 = fadd <4 x float> %141, %138
  %143 = bitcast float* %139 to <4 x float>*
  store <4 x float> %142, <4 x float>* %143, align 4, !alias.scope !10, !noalias !13
  %144 = add i64 %121, 4
  %145 = icmp eq i64 %144, %117
  br i1 %145, label %146, label %120, !llvm.loop !15

146:                                              ; preds = %120, %102, %96
  %147 = phi i64 [ 1, %102 ], [ 1, %96 ], [ %118, %120 ]
  br label %148

148:                                              ; preds = %146, %148
  %149 = phi i64 [ %166, %148 ], [ %147, %146 ]
  %150 = shl nuw nsw i64 %149, 1
  %151 = add nsw i64 %150, -1
  %152 = getelementptr inbounds float, float* %95, i64 %151
  %153 = load float, float* %152, align 4
  %154 = or i64 %150, 1
  %155 = getelementptr inbounds float, float* %95, i64 %154
  %156 = load float, float* %155, align 4
  %157 = fadd float %153, %156
  %158 = fmul float %157, 5.000000e-01
  %159 = getelementptr inbounds float, float* %95, i64 %150
  %160 = load float, float* %159, align 4
  %161 = fadd float %160, %158
  %162 = fmul float %161, 5.000000e-01
  %163 = getelementptr inbounds float, float* %1, i64 %149
  %164 = load float, float* %163, align 4
  %165 = fadd float %164, %162
  store float %165, float* %163, align 4
  %166 = add nuw nsw i64 %149, 1
  %167 = icmp slt i64 %166, %97
  br i1 %167, label %148, label %168, !llvm.loop !16

168:                                              ; preds = %148
  %169 = load float, float* %1, align 4
  br label %170

170:                                              ; preds = %168, %93
  %171 = phi float [ %169, %168 ], [ %91, %93 ]
  %172 = getelementptr inbounds float, float* %95, i64 1
  %173 = load float, float* %172, align 4
  %174 = fmul float %173, 5.000000e-01
  %175 = load float, float* %95, align 4
  %176 = fadd float %174, %175
  %177 = fmul float %176, 5.000000e-01
  %178 = fadd float %171, %177
  store float %178, float* %1, align 4
  br label %179

179:                                              ; preds = %170, %85
  %180 = call i32 @_celt_autocorr(float* %1, float* nonnull %9, float* null, i32 0, i32 4, i32 %14, i32 %4) #4
  %181 = bitcast [5 x float]* %6 to <4 x float>*
  %182 = load <4 x float>, <4 x float>* %181, align 16
  %183 = extractelement <4 x float> %182, i32 1
  %184 = fmul float %183, 0x3F80624DE0000000
  %185 = fmul float %184, 0x3F80624DE0000000
  %186 = extractelement <4 x float> %182, i32 2
  %187 = fmul float %186, 0x3F90624DE0000000
  %188 = fmul float %187, 0x3F90624DE0000000
  %189 = extractelement <4 x float> %182, i32 3
  %190 = fmul float %189, 0x3F989374C0000000
  %191 = fmul float %190, 0x3F989374C0000000
  %192 = insertelement <4 x float> <float 0x3FF00068E0000000, float undef, float undef, float undef>, float %185, i32 1
  %193 = insertelement <4 x float> %192, float %188, i32 2
  %194 = insertelement <4 x float> %193, float %191, i32 3
  %195 = fmul <4 x float> %182, %194
  %196 = fsub <4 x float> %182, %194
  %197 = shufflevector <4 x float> %195, <4 x float> %196, <4 x i32> <i32 0, i32 5, i32 6, i32 7>
  %198 = bitcast [5 x float]* %6 to <4 x float>*
  store <4 x float> %197, <4 x float>* %198, align 16
  %199 = load float, float* %10, align 16
  %200 = fmul float %199, 0x3FA0624DE0000000
  %201 = fmul float %200, 0x3FA0624DE0000000
  %202 = fsub float %199, %201
  store float %202, float* %10, align 16
  call void @_celt_lpc(float* nonnull %13, float* nonnull %9, i32 4) #4
  %203 = load <4 x float>, <4 x float>* %7, align 16
  %204 = fmul <4 x float> %203, <float 0x3FECCCCCC0000000, float 0x3FE9EB8500000000, float 0x3FE753F7A0000000, float 0x3FE4FEC540000000>
  store <4 x float> %204, <4 x float>* %7, align 16
  %205 = extractelement <4 x float> %204, i32 0
  %206 = fadd float %205, 0x3FE99999A0000000
  %207 = fmul float %205, 0x3FE99999A0000000
  %208 = extractelement <4 x float> %204, i32 1
  %209 = fadd float %208, %207
  %210 = fmul float %208, 0x3FE99999A0000000
  %211 = extractelement <4 x float> %204, i32 2
  %212 = fadd float %211, %210
  %213 = fmul float %211, 0x3FE99999A0000000
  %214 = extractelement <4 x float> %204, i32 3
  %215 = fadd float %214, %213
  %216 = fmul float %214, 0x3FE99999A0000000
  %217 = icmp sgt i32 %2, 1
  br i1 %217, label %218, label %241

218:                                              ; preds = %179
  %219 = zext i32 %14 to i64
  br label %220

220:                                              ; preds = %220, %218
  %221 = phi i64 [ 0, %218 ], [ %239, %220 ]
  %222 = phi float [ 0.000000e+00, %218 ], [ %223, %220 ]
  %223 = phi float [ 0.000000e+00, %218 ], [ %224, %220 ]
  %224 = phi float [ 0.000000e+00, %218 ], [ %225, %220 ]
  %225 = phi float [ 0.000000e+00, %218 ], [ %226, %220 ]
  %226 = phi float [ 0.000000e+00, %218 ], [ %228, %220 ]
  %227 = getelementptr inbounds float, float* %1, i64 %221
  %228 = load float, float* %227, align 4
  %229 = fmul float %206, %226
  %230 = fadd float %229, %228
  %231 = fmul float %209, %225
  %232 = fadd float %231, %230
  %233 = fmul float %212, %224
  %234 = fadd float %233, %232
  %235 = fmul float %215, %223
  %236 = fadd float %235, %234
  %237 = fmul float %216, %222
  %238 = fadd float %237, %236
  store float %238, float* %227, align 4
  %239 = add nuw nsw i64 %221, 1
  %240 = icmp eq i64 %239, %219
  br i1 %240, label %241, label %220

241:                                              ; preds = %220, %179
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %11) #4
  call void @llvm.lifetime.end.p0i8(i64 20, i8* nonnull %8) #4
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

declare i32 @_celt_autocorr(float*, float*, float*, i32, i32, i32, i32) local_unnamed_addr #2

declare void @_celt_lpc(float*, float*, i32) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: nounwind ssp uwtable
define hidden void @celt_pitch_xcorr_c(float*, float*, float* nocapture, i32, i32, i32) local_unnamed_addr #0 {
  %7 = alloca <4 x i32>, align 16
  %8 = icmp sgt i32 %4, 0
  br i1 %8, label %9, label %15

9:                                                ; preds = %6
  %10 = add nsw i32 %4, -3
  %11 = icmp sgt i32 %10, 0
  br i1 %11, label %12, label %18

12:                                               ; preds = %9
  %13 = bitcast <4 x i32>* %7 to i8*
  %14 = bitcast <4 x i32>* %7 to float*
  br label %23

15:                                               ; preds = %6
  tail call void @celt_fatal(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.1, i64 0, i64 0), i32 251) #5
  unreachable

16:                                               ; preds = %23
  %17 = trunc i64 %29 to i32
  br label %18

18:                                               ; preds = %16, %9
  %19 = phi i32 [ 0, %9 ], [ %17, %16 ]
  %20 = icmp slt i32 %19, %4
  br i1 %20, label %21, label %40

21:                                               ; preds = %18
  %22 = zext i32 %19 to i64
  br label %32

23:                                               ; preds = %12, %23
  %24 = phi i64 [ 0, %12 ], [ %29, %23 ]
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %13) #4
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %13, i8 0, i64 16, i1 false)
  %25 = getelementptr inbounds float, float* %1, i64 %24
  call void @xcorr_kernel_sse(float* %0, float* %25, float* nonnull %14, i32 %3) #4
  %26 = getelementptr inbounds float, float* %2, i64 %24
  %27 = load <4 x i32>, <4 x i32>* %7, align 16
  %28 = bitcast float* %26 to <4 x i32>*
  store <4 x i32> %27, <4 x i32>* %28, align 4
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %13) #4
  %29 = add nuw i64 %24, 4
  %30 = trunc i64 %29 to i32
  %31 = icmp sgt i32 %10, %30
  br i1 %31, label %23, label %16

32:                                               ; preds = %32, %21
  %33 = phi i64 [ %22, %21 ], [ %37, %32 ]
  %34 = getelementptr inbounds float, float* %1, i64 %33
  %35 = call float @celt_inner_prod_sse(float* %0, float* %34, i32 %3) #4
  %36 = getelementptr inbounds float, float* %2, i64 %33
  store float %35, float* %36, align 4
  %37 = add nuw nsw i64 %33, 1
  %38 = trunc i64 %37 to i32
  %39 = icmp eq i32 %38, %4
  br i1 %39, label %40, label %32

40:                                               ; preds = %32, %18
  ret void
}

; Function Attrs: noreturn
declare void @celt_fatal(i8*, i8*, i32) local_unnamed_addr #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #1

declare void @xcorr_kernel_sse(float*, float*, float*, i32) local_unnamed_addr #2

declare float @celt_inner_prod_sse(float*, float*, i32) local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define hidden void @pitch_search(float* noalias, float* noalias, i32, i32, i32* nocapture, i32) local_unnamed_addr #0 {
  %7 = alloca <4 x i32>, align 16
  %8 = icmp sgt i32 %2, 0
  br i1 %8, label %10, label %9

9:                                                ; preds = %6
  tail call void @celt_fatal(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2, i64 0, i64 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.1, i64 0, i64 0), i32 302) #5
  unreachable

10:                                               ; preds = %6
  %11 = icmp sgt i32 %3, 0
  br i1 %11, label %13, label %12

12:                                               ; preds = %10
  tail call void @celt_fatal(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.1, i64 0, i64 0), i32 303) #5
  unreachable

13:                                               ; preds = %10
  %14 = add nuw nsw i32 %3, %2
  %15 = lshr i32 %2, 2
  %16 = zext i32 %15 to i64
  %17 = and i32 %2, -4
  %18 = zext i32 %17 to i64
  %19 = alloca float, i64 %16, align 16
  %20 = bitcast float* %19 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %20, i8 -86, i64 %18, i1 false)
  %21 = ashr i32 %14, 2
  %22 = sext i32 %21 to i64
  %23 = shl nsw i64 %22, 2
  %24 = alloca float, i64 %22, align 16
  %25 = bitcast float* %24 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %25, i8 -86, i64 %23, i1 false)
  %26 = lshr i32 %3, 1
  %27 = zext i32 %26 to i64
  %28 = shl nuw nsw i64 %27, 2
  %29 = alloca float, i64 %27, align 16
  %30 = bitcast float* %29 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %30, i8 -86, i64 %28, i1 false)
  %31 = icmp eq i32 %15, 0
  br i1 %31, label %60, label %32

32:                                               ; preds = %13
  %33 = icmp ult i32 %2, 36
  br i1 %33, label %34, label %36

34:                                               ; preds = %41, %32
  %35 = phi i64 [ 0, %32 ], [ %40, %41 ]
  br label %92

36:                                               ; preds = %32
  %37 = and i64 %16, 7
  %38 = icmp eq i64 %37, 0
  %39 = select i1 %38, i64 8, i64 %37
  %40 = sub nsw i64 %16, %39
  br label %41

41:                                               ; preds = %41, %36
  %42 = phi i64 [ 0, %36 ], [ %58, %41 ]
  %43 = shl nuw nsw i64 %42, 1
  %44 = shl i64 %42, 1
  %45 = or i64 %44, 8
  %46 = getelementptr inbounds float, float* %0, i64 %43
  %47 = getelementptr inbounds float, float* %0, i64 %45
  %48 = bitcast float* %46 to <8 x i32>*
  %49 = bitcast float* %47 to <8 x i32>*
  %50 = load <8 x i32>, <8 x i32>* %48, align 4
  %51 = load <8 x i32>, <8 x i32>* %49, align 4
  %52 = shufflevector <8 x i32> %50, <8 x i32> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %53 = shufflevector <8 x i32> %51, <8 x i32> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %54 = getelementptr inbounds float, float* %19, i64 %42
  %55 = bitcast float* %54 to <4 x i32>*
  store <4 x i32> %52, <4 x i32>* %55, align 16
  %56 = getelementptr inbounds float, float* %54, i64 4
  %57 = bitcast float* %56 to <4 x i32>*
  store <4 x i32> %53, <4 x i32>* %57, align 16
  %58 = add i64 %42, 8
  %59 = icmp eq i64 %58, %40
  br i1 %59, label %34, label %41, !llvm.loop !17

60:                                               ; preds = %92, %13
  %61 = icmp sgt i32 %14, 3
  br i1 %61, label %62, label %112

62:                                               ; preds = %60
  %63 = icmp sgt i64 %22, 1
  %64 = select i1 %63, i64 %22, i64 1
  %65 = icmp ult i64 %64, 9
  br i1 %65, label %66, label %68

66:                                               ; preds = %73, %62
  %67 = phi i64 [ 0, %62 ], [ %72, %73 ]
  br label %102

68:                                               ; preds = %62
  %69 = and i64 %64, 7
  %70 = icmp eq i64 %69, 0
  %71 = select i1 %70, i64 8, i64 %69
  %72 = sub nsw i64 %64, %71
  br label %73

73:                                               ; preds = %73, %68
  %74 = phi i64 [ 0, %68 ], [ %90, %73 ]
  %75 = shl nuw nsw i64 %74, 1
  %76 = shl i64 %74, 1
  %77 = or i64 %76, 8
  %78 = getelementptr inbounds float, float* %1, i64 %75
  %79 = getelementptr inbounds float, float* %1, i64 %77
  %80 = bitcast float* %78 to <8 x i32>*
  %81 = bitcast float* %79 to <8 x i32>*
  %82 = load <8 x i32>, <8 x i32>* %80, align 4
  %83 = load <8 x i32>, <8 x i32>* %81, align 4
  %84 = shufflevector <8 x i32> %82, <8 x i32> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %85 = shufflevector <8 x i32> %83, <8 x i32> undef, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %86 = getelementptr inbounds float, float* %24, i64 %74
  %87 = bitcast float* %86 to <4 x i32>*
  store <4 x i32> %84, <4 x i32>* %87, align 16
  %88 = getelementptr inbounds float, float* %86, i64 4
  %89 = bitcast float* %88 to <4 x i32>*
  store <4 x i32> %85, <4 x i32>* %89, align 16
  %90 = add i64 %74, 8
  %91 = icmp eq i64 %90, %72
  br i1 %91, label %66, label %73, !llvm.loop !18

92:                                               ; preds = %34, %92
  %93 = phi i64 [ %100, %92 ], [ %35, %34 ]
  %94 = shl nuw nsw i64 %93, 1
  %95 = getelementptr inbounds float, float* %0, i64 %94
  %96 = bitcast float* %95 to i32*
  %97 = load i32, i32* %96, align 4
  %98 = getelementptr inbounds float, float* %19, i64 %93
  %99 = bitcast float* %98 to i32*
  store i32 %97, i32* %99, align 4
  %100 = add nuw nsw i64 %93, 1
  %101 = icmp eq i64 %100, %16
  br i1 %101, label %60, label %92, !llvm.loop !19

102:                                              ; preds = %66, %102
  %103 = phi i64 [ %110, %102 ], [ %67, %66 ]
  %104 = shl nuw nsw i64 %103, 1
  %105 = getelementptr inbounds float, float* %1, i64 %104
  %106 = bitcast float* %105 to i32*
  %107 = load i32, i32* %106, align 4
  %108 = getelementptr inbounds float, float* %24, i64 %103
  %109 = bitcast float* %108 to i32*
  store i32 %107, i32* %109, align 4
  %110 = add nuw nsw i64 %103, 1
  %111 = icmp slt i64 %110, %22
  br i1 %111, label %102, label %112, !llvm.loop !21

112:                                              ; preds = %102, %60
  %113 = ashr i32 %3, 2
  %114 = icmp sgt i32 %3, 3
  br i1 %114, label %115, label %122

115:                                              ; preds = %112
  %116 = add nsw i32 %113, -3
  %117 = icmp sgt i32 %116, 0
  br i1 %117, label %118, label %125

118:                                              ; preds = %115
  %119 = bitcast <4 x i32>* %7 to i8*
  %120 = bitcast <4 x i32>* %7 to float*
  %121 = sext i32 %116 to i64
  br label %130

122:                                              ; preds = %112
  tail call void @celt_fatal(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.1, i64 0, i64 0), i32 251) #5
  unreachable

123:                                              ; preds = %130
  %124 = trunc i64 %136 to i32
  br label %125

125:                                              ; preds = %123, %115
  %126 = phi i32 [ 0, %115 ], [ %124, %123 ]
  %127 = icmp slt i32 %126, %113
  br i1 %127, label %128, label %146

128:                                              ; preds = %125
  %129 = zext i32 %126 to i64
  br label %138

130:                                              ; preds = %130, %118
  %131 = phi i64 [ 0, %118 ], [ %136, %130 ]
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %119) #4
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %119, i8 0, i64 16, i1 false) #4
  %132 = getelementptr inbounds float, float* %24, i64 %131
  call void @xcorr_kernel_sse(float* nonnull %19, float* %132, float* nonnull %120, i32 %15) #4
  %133 = getelementptr inbounds float, float* %29, i64 %131
  %134 = load <4 x i32>, <4 x i32>* %7, align 16
  %135 = bitcast float* %133 to <4 x i32>*
  store <4 x i32> %134, <4 x i32>* %135, align 16
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %119) #4
  %136 = add nuw nsw i64 %131, 4
  %137 = icmp slt i64 %136, %121
  br i1 %137, label %130, label %123

138:                                              ; preds = %138, %128
  %139 = phi i64 [ %129, %128 ], [ %143, %138 ]
  %140 = getelementptr inbounds float, float* %24, i64 %139
  %141 = call float @celt_inner_prod_sse(float* nonnull %19, float* %140, i32 %15) #4
  %142 = getelementptr inbounds float, float* %29, i64 %139
  store float %141, float* %142, align 4
  %143 = add nuw nsw i64 %139, 1
  %144 = trunc i64 %143 to i32
  %145 = icmp eq i32 %113, %144
  br i1 %145, label %146, label %138

146:                                              ; preds = %138, %125
  br i1 %31, label %169, label %147

147:                                              ; preds = %146
  %148 = add nsw i64 %16, -1
  %149 = and i64 %16, 3
  %150 = icmp ult i64 %148, 3
  br i1 %150, label %153, label %151

151:                                              ; preds = %147
  %152 = sub nsw i64 %16, %149
  br label %172

153:                                              ; preds = %172, %147
  %154 = phi float [ undef, %147 ], [ %194, %172 ]
  %155 = phi i64 [ 0, %147 ], [ %195, %172 ]
  %156 = phi float [ 1.000000e+00, %147 ], [ %194, %172 ]
  %157 = icmp eq i64 %149, 0
  br i1 %157, label %169, label %158

158:                                              ; preds = %153, %158
  %159 = phi i64 [ %166, %158 ], [ %155, %153 ]
  %160 = phi float [ %165, %158 ], [ %156, %153 ]
  %161 = phi i64 [ %167, %158 ], [ %149, %153 ]
  %162 = getelementptr inbounds float, float* %24, i64 %159
  %163 = load float, float* %162, align 4
  %164 = fmul float %163, %163
  %165 = fadd float %160, %164
  %166 = add nuw nsw i64 %159, 1
  %167 = add i64 %161, -1
  %168 = icmp eq i64 %167, 0
  br i1 %168, label %169, label %158, !llvm.loop !22

169:                                              ; preds = %153, %158, %146
  %170 = phi float [ 1.000000e+00, %146 ], [ %154, %153 ], [ %165, %158 ]
  %171 = zext i32 %113 to i64
  br label %198

172:                                              ; preds = %172, %151
  %173 = phi i64 [ 0, %151 ], [ %195, %172 ]
  %174 = phi float [ 1.000000e+00, %151 ], [ %194, %172 ]
  %175 = phi i64 [ %152, %151 ], [ %196, %172 ]
  %176 = getelementptr inbounds float, float* %24, i64 %173
  %177 = load float, float* %176, align 16
  %178 = fmul float %177, %177
  %179 = fadd float %174, %178
  %180 = or i64 %173, 1
  %181 = getelementptr inbounds float, float* %24, i64 %180
  %182 = load float, float* %181, align 4
  %183 = fmul float %182, %182
  %184 = fadd float %179, %183
  %185 = or i64 %173, 2
  %186 = getelementptr inbounds float, float* %24, i64 %185
  %187 = load float, float* %186, align 8
  %188 = fmul float %187, %187
  %189 = fadd float %184, %188
  %190 = or i64 %173, 3
  %191 = getelementptr inbounds float, float* %24, i64 %190
  %192 = load float, float* %191, align 4
  %193 = fmul float %192, %192
  %194 = fadd float %189, %193
  %195 = add nuw nsw i64 %173, 4
  %196 = add i64 %175, -4
  %197 = icmp eq i64 %196, 0
  br i1 %197, label %153, label %172

198:                                              ; preds = %229, %169
  %199 = phi i32 [ 1, %169 ], [ %230, %229 ]
  %200 = phi i32 [ 0, %169 ], [ %231, %229 ]
  %201 = phi i32 [ 0, %169 ], [ %232, %229 ]
  %202 = phi i64 [ 0, %169 ], [ %248, %229 ]
  %203 = phi float [ 0.000000e+00, %169 ], [ %236, %229 ]
  %204 = phi float [ 0.000000e+00, %169 ], [ %235, %229 ]
  %205 = phi float [ -1.000000e+00, %169 ], [ %234, %229 ]
  %206 = phi float [ -1.000000e+00, %169 ], [ %233, %229 ]
  %207 = phi float [ %170, %169 ], [ %247, %229 ]
  %208 = getelementptr inbounds float, float* %29, i64 %202
  %209 = load float, float* %208, align 4
  %210 = fcmp ogt float %209, 0.000000e+00
  br i1 %210, label %211, label %229

211:                                              ; preds = %198
  %212 = fmul float %209, 0x3D71979980000000
  %213 = fmul float %212, %212
  %214 = fmul float %204, %213
  %215 = fmul float %206, %207
  %216 = fcmp ogt float %214, %215
  br i1 %216, label %217, label %229

217:                                              ; preds = %211
  %218 = fmul float %203, %213
  %219 = fmul float %205, %207
  %220 = fcmp ogt float %218, %219
  %221 = trunc i64 %202 to i32
  %222 = select i1 %220, i32 %201, i32 %221
  %223 = select i1 %220, i32 %221, i32 %200
  %224 = select i1 %220, i32 %221, i32 %201
  %225 = select i1 %220, float %205, float %213
  %226 = select i1 %220, float %213, float %205
  %227 = select i1 %220, float %203, float %207
  %228 = select i1 %220, float %207, float %203
  br label %229

229:                                              ; preds = %217, %211, %198
  %230 = phi i32 [ %199, %211 ], [ %199, %198 ], [ %222, %217 ]
  %231 = phi i32 [ %200, %211 ], [ %200, %198 ], [ %223, %217 ]
  %232 = phi i32 [ %201, %211 ], [ %201, %198 ], [ %224, %217 ]
  %233 = phi float [ %206, %211 ], [ %206, %198 ], [ %225, %217 ]
  %234 = phi float [ %205, %211 ], [ %205, %198 ], [ %226, %217 ]
  %235 = phi float [ %204, %211 ], [ %204, %198 ], [ %227, %217 ]
  %236 = phi float [ %203, %211 ], [ %203, %198 ], [ %228, %217 ]
  %237 = add nuw nsw i64 %202, %16
  %238 = getelementptr inbounds float, float* %24, i64 %237
  %239 = load float, float* %238, align 4
  %240 = fmul float %239, %239
  %241 = getelementptr inbounds float, float* %24, i64 %202
  %242 = load float, float* %241, align 4
  %243 = fmul float %242, %242
  %244 = fsub float %240, %243
  %245 = fadd float %207, %244
  %246 = fcmp olt float %245, 1.000000e+00
  %247 = select i1 %246, float 1.000000e+00, float %245
  %248 = add nuw nsw i64 %202, 1
  %249 = icmp eq i64 %248, %171
  br i1 %249, label %250, label %198

250:                                              ; preds = %229
  %251 = icmp eq i32 %26, 0
  br i1 %251, label %252, label %254

252:                                              ; preds = %250
  %253 = ashr i32 %2, 1
  br label %281

254:                                              ; preds = %250
  %255 = shl nsw i32 %231, 1
  %256 = shl nsw i32 %230, 1
  %257 = ashr i32 %2, 1
  br label %258

258:                                              ; preds = %278, %254
  %259 = phi i64 [ 0, %254 ], [ %279, %278 ]
  %260 = getelementptr inbounds float, float* %29, i64 %259
  store float 0.000000e+00, float* %260, align 4
  %261 = trunc i64 %259 to i32
  %262 = sub nsw i32 %261, %255
  %263 = icmp slt i32 %262, 0
  %264 = sub nsw i32 0, %262
  %265 = select i1 %263, i32 %264, i32 %262
  %266 = icmp sgt i32 %265, 2
  br i1 %266, label %267, label %273

267:                                              ; preds = %258
  %268 = sub nsw i32 %261, %256
  %269 = icmp slt i32 %268, 0
  %270 = sub nsw i32 0, %268
  %271 = select i1 %269, i32 %270, i32 %268
  %272 = icmp sgt i32 %271, 2
  br i1 %272, label %278, label %273

273:                                              ; preds = %267, %258
  %274 = getelementptr inbounds float, float* %1, i64 %259
  %275 = call float @celt_inner_prod_sse(float* %0, float* %274, i32 %257) #4
  %276 = fcmp olt float %275, -1.000000e+00
  %277 = select i1 %276, float -1.000000e+00, float %275
  store float %277, float* %260, align 4
  br label %278

278:                                              ; preds = %267, %273
  %279 = add nuw nsw i64 %259, 1
  %280 = icmp eq i64 %279, %27
  br i1 %280, label %281, label %258

281:                                              ; preds = %278, %252
  %282 = phi i32 [ %253, %252 ], [ %257, %278 ]
  %283 = icmp sgt i32 %2, 1
  br i1 %283, label %284, label %307

284:                                              ; preds = %281
  %285 = zext i32 %282 to i64
  %286 = add nsw i64 %285, -1
  %287 = and i64 %285, 3
  %288 = icmp ult i64 %286, 3
  br i1 %288, label %291, label %289

289:                                              ; preds = %284
  %290 = sub nsw i64 %285, %287
  br label %311

291:                                              ; preds = %311, %284
  %292 = phi float [ undef, %284 ], [ %333, %311 ]
  %293 = phi i64 [ 0, %284 ], [ %334, %311 ]
  %294 = phi float [ 1.000000e+00, %284 ], [ %333, %311 ]
  %295 = icmp eq i64 %287, 0
  br i1 %295, label %307, label %296

296:                                              ; preds = %291, %296
  %297 = phi i64 [ %304, %296 ], [ %293, %291 ]
  %298 = phi float [ %303, %296 ], [ %294, %291 ]
  %299 = phi i64 [ %305, %296 ], [ %287, %291 ]
  %300 = getelementptr inbounds float, float* %1, i64 %297
  %301 = load float, float* %300, align 4
  %302 = fmul float %301, %301
  %303 = fadd float %298, %302
  %304 = add nuw nsw i64 %297, 1
  %305 = add i64 %299, -1
  %306 = icmp eq i64 %305, 0
  br i1 %306, label %307, label %296, !llvm.loop !24

307:                                              ; preds = %291, %296, %281
  %308 = phi float [ 1.000000e+00, %281 ], [ %292, %291 ], [ %303, %296 ]
  br i1 %251, label %406, label %309

309:                                              ; preds = %307
  %310 = sext i32 %282 to i64
  br label %337

311:                                              ; preds = %311, %289
  %312 = phi i64 [ 0, %289 ], [ %334, %311 ]
  %313 = phi float [ 1.000000e+00, %289 ], [ %333, %311 ]
  %314 = phi i64 [ %290, %289 ], [ %335, %311 ]
  %315 = getelementptr inbounds float, float* %1, i64 %312
  %316 = load float, float* %315, align 4
  %317 = fmul float %316, %316
  %318 = fadd float %313, %317
  %319 = or i64 %312, 1
  %320 = getelementptr inbounds float, float* %1, i64 %319
  %321 = load float, float* %320, align 4
  %322 = fmul float %321, %321
  %323 = fadd float %318, %322
  %324 = or i64 %312, 2
  %325 = getelementptr inbounds float, float* %1, i64 %324
  %326 = load float, float* %325, align 4
  %327 = fmul float %326, %326
  %328 = fadd float %323, %327
  %329 = or i64 %312, 3
  %330 = getelementptr inbounds float, float* %1, i64 %329
  %331 = load float, float* %330, align 4
  %332 = fmul float %331, %331
  %333 = fadd float %328, %332
  %334 = add nuw nsw i64 %312, 4
  %335 = add i64 %314, -4
  %336 = icmp eq i64 %335, 0
  br i1 %336, label %291, label %311

337:                                              ; preds = %360, %309
  %338 = phi i32 [ 0, %309 ], [ %361, %360 ]
  %339 = phi i64 [ 0, %309 ], [ %377, %360 ]
  %340 = phi float [ 0.000000e+00, %309 ], [ %365, %360 ]
  %341 = phi float [ 0.000000e+00, %309 ], [ %364, %360 ]
  %342 = phi float [ -1.000000e+00, %309 ], [ %363, %360 ]
  %343 = phi float [ -1.000000e+00, %309 ], [ %362, %360 ]
  %344 = phi float [ %308, %309 ], [ %376, %360 ]
  %345 = getelementptr inbounds float, float* %29, i64 %339
  %346 = load float, float* %345, align 4
  %347 = fcmp ogt float %346, 0.000000e+00
  br i1 %347, label %348, label %360

348:                                              ; preds = %337
  %349 = fmul float %346, 0x3D71979980000000
  %350 = fmul float %349, %349
  %351 = fmul float %341, %350
  %352 = fmul float %343, %344
  %353 = fcmp ogt float %351, %352
  br i1 %353, label %354, label %360

354:                                              ; preds = %348
  %355 = fmul float %340, %350
  %356 = fmul float %342, %344
  %357 = fcmp ogt float %355, %356
  br i1 %357, label %358, label %360

358:                                              ; preds = %354
  %359 = trunc i64 %339 to i32
  br label %360

360:                                              ; preds = %354, %358, %348, %337
  %361 = phi i32 [ %359, %358 ], [ %338, %348 ], [ %338, %337 ], [ %338, %354 ]
  %362 = phi float [ %342, %358 ], [ %343, %348 ], [ %343, %337 ], [ %350, %354 ]
  %363 = phi float [ %350, %358 ], [ %342, %348 ], [ %342, %337 ], [ %342, %354 ]
  %364 = phi float [ %340, %358 ], [ %341, %348 ], [ %341, %337 ], [ %344, %354 ]
  %365 = phi float [ %344, %358 ], [ %340, %348 ], [ %340, %337 ], [ %340, %354 ]
  %366 = add nsw i64 %339, %310
  %367 = getelementptr inbounds float, float* %1, i64 %366
  %368 = load float, float* %367, align 4
  %369 = fmul float %368, %368
  %370 = getelementptr inbounds float, float* %1, i64 %339
  %371 = load float, float* %370, align 4
  %372 = fmul float %371, %371
  %373 = fsub float %369, %372
  %374 = fadd float %344, %373
  %375 = fcmp olt float %374, 1.000000e+00
  %376 = select i1 %375, float 1.000000e+00, float %374
  %377 = add nuw nsw i64 %339, 1
  %378 = icmp eq i64 %377, %27
  br i1 %378, label %379, label %337

379:                                              ; preds = %360
  %380 = icmp sgt i32 %361, 0
  %381 = add nsw i32 %26, -1
  %382 = icmp slt i32 %361, %381
  %383 = and i1 %380, %382
  br i1 %383, label %384, label %406

384:                                              ; preds = %379
  %385 = add nsw i32 %361, -1
  %386 = sext i32 %385 to i64
  %387 = getelementptr inbounds float, float* %29, i64 %386
  %388 = load float, float* %387, align 4
  %389 = sext i32 %361 to i64
  %390 = getelementptr inbounds float, float* %29, i64 %389
  %391 = load float, float* %390, align 4
  %392 = add nuw nsw i32 %361, 1
  %393 = sext i32 %392 to i64
  %394 = getelementptr inbounds float, float* %29, i64 %393
  %395 = load float, float* %394, align 4
  %396 = fsub float %395, %388
  %397 = fsub float %391, %388
  %398 = fmul float %397, 0x3FE6666660000000
  %399 = fcmp ogt float %396, %398
  br i1 %399, label %406, label %400

400:                                              ; preds = %384
  %401 = fsub float %388, %395
  %402 = fsub float %391, %395
  %403 = fmul float %402, 0x3FE6666660000000
  %404 = fcmp ogt float %401, %403
  %405 = sext i1 %404 to i32
  br label %406

406:                                              ; preds = %307, %379, %384, %400
  %407 = phi i32 [ %361, %384 ], [ %361, %400 ], [ %361, %379 ], [ 0, %307 ]
  %408 = phi i32 [ 1, %384 ], [ %405, %400 ], [ 0, %379 ], [ 0, %307 ]
  %409 = shl nsw i32 %407, 1
  %410 = sub nsw i32 %409, %408
  store i32 %410, i32* %4, align 4
  ret void
}

; Function Attrs: nounwind ssp uwtable
define hidden float @remove_doubling(float*, i32, i32, i32, i32* nocapture, i32, float, i32) local_unnamed_addr #0 {
  %9 = alloca float, align 4
  %10 = alloca float, align 4
  %11 = alloca float, align 4
  %12 = bitcast float* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %12) #4
  store float 0xFFFFFFFFE0000000, float* %9, align 4
  %13 = bitcast float* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %13) #4
  store float 0xFFFFFFFFE0000000, float* %10, align 4
  %14 = bitcast float* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %14) #4
  store float 0xFFFFFFFFE0000000, float* %11, align 4
  %15 = sdiv i32 %1, 2
  %16 = sdiv i32 %2, 2
  %17 = load i32, i32* %4, align 4
  %18 = sdiv i32 %17, 2
  %19 = sdiv i32 %5, 2
  %20 = sdiv i32 %3, 2
  %21 = sext i32 %15 to i64
  %22 = getelementptr inbounds float, float* %0, i64 %21
  %23 = icmp slt i32 %18, %15
  %24 = add nsw i32 %15, -1
  %25 = select i1 %23, i32 %18, i32 %24
  store i32 %25, i32* %4, align 4
  %26 = add nsw i32 %15, 1
  %27 = sext i32 %26 to i64
  %28 = shl nsw i64 %27, 2
  %29 = alloca float, i64 %27, align 16
  %30 = bitcast float* %29 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %30, i8 -86, i64 %28, i1 false)
  %31 = sext i32 %25 to i64
  %32 = sub nsw i64 0, %31
  %33 = getelementptr inbounds float, float* %22, i64 %32
  call void @dual_inner_prod_sse(float* %22, float* %22, float* %33, i32 %20, float* nonnull %10, float* nonnull %9) #4
  %34 = bitcast float* %10 to i32*
  %35 = load i32, i32* %34, align 4
  %36 = bitcast float* %29 to i32*
  store i32 %35, i32* %36, align 16
  %37 = bitcast i32 %35 to float
  %38 = icmp slt i32 %1, 2
  br i1 %38, label %99, label %39

39:                                               ; preds = %8
  %40 = sext i32 %20 to i64
  %41 = zext i32 %26 to i64
  %42 = add nsw i64 %41, -1
  %43 = and i64 %42, 1
  %44 = icmp eq i32 %26, 2
  br i1 %44, label %81, label %45

45:                                               ; preds = %39
  %46 = sub nsw i64 %42, %43
  br label %47

47:                                               ; preds = %47, %45
  %48 = phi i64 [ 1, %45 ], [ %78, %47 ]
  %49 = phi float [ %37, %45 ], [ %74, %47 ]
  %50 = phi i64 [ %46, %45 ], [ %79, %47 ]
  %51 = sub nsw i64 0, %48
  %52 = getelementptr inbounds float, float* %22, i64 %51
  %53 = load float, float* %52, align 4
  %54 = fmul float %53, %53
  %55 = fadd float %49, %54
  %56 = sub nsw i64 %40, %48
  %57 = getelementptr inbounds float, float* %22, i64 %56
  %58 = load float, float* %57, align 4
  %59 = fmul float %58, %58
  %60 = fsub float %55, %59
  %61 = fcmp olt float %60, 0.000000e+00
  %62 = select i1 %61, float 0.000000e+00, float %60
  %63 = getelementptr inbounds float, float* %29, i64 %48
  store float %62, float* %63, align 4
  %64 = add nuw nsw i64 %48, 1
  %65 = xor i64 %48, -1
  %66 = getelementptr inbounds float, float* %22, i64 %65
  %67 = load float, float* %66, align 4
  %68 = fmul float %67, %67
  %69 = fadd float %60, %68
  %70 = sub nsw i64 %40, %64
  %71 = getelementptr inbounds float, float* %22, i64 %70
  %72 = load float, float* %71, align 4
  %73 = fmul float %72, %72
  %74 = fsub float %69, %73
  %75 = fcmp olt float %74, 0.000000e+00
  %76 = select i1 %75, float 0.000000e+00, float %74
  %77 = getelementptr inbounds float, float* %29, i64 %64
  store float %76, float* %77, align 4
  %78 = add nuw nsw i64 %48, 2
  %79 = add i64 %50, -2
  %80 = icmp eq i64 %79, 0
  br i1 %80, label %81, label %47

81:                                               ; preds = %47, %39
  %82 = phi i64 [ 1, %39 ], [ %78, %47 ]
  %83 = phi float [ %37, %39 ], [ %74, %47 ]
  %84 = icmp eq i64 %43, 0
  br i1 %84, label %99, label %85

85:                                               ; preds = %81
  %86 = sub nsw i64 0, %82
  %87 = getelementptr inbounds float, float* %22, i64 %86
  %88 = load float, float* %87, align 4
  %89 = fmul float %88, %88
  %90 = fadd float %83, %89
  %91 = sub nsw i64 %40, %82
  %92 = getelementptr inbounds float, float* %22, i64 %91
  %93 = load float, float* %92, align 4
  %94 = fmul float %93, %93
  %95 = fsub float %90, %94
  %96 = fcmp olt float %95, 0.000000e+00
  %97 = select i1 %96, float 0.000000e+00, float %95
  %98 = getelementptr inbounds float, float* %29, i64 %82
  store float %97, float* %98, align 4
  br label %99

99:                                               ; preds = %85, %81, %8
  %100 = getelementptr inbounds float, float* %29, i64 %31
  %101 = load float, float* %100, align 4
  %102 = load float, float* %9, align 4
  %103 = fmul float %101, %37
  %104 = fadd float %103, 1.000000e+00
  %105 = call float @sqrtf(float %104) #6
  %106 = fdiv float %102, %105
  %107 = shl i32 %25, 1
  %108 = fmul float %6, 5.000000e-01
  %109 = fmul float %106, 0x3FE6666660000000
  %110 = mul nsw i32 %16, 3
  %111 = shl nsw i32 %16, 1
  %112 = fmul float %106, 0x3FECCCCCC0000000
  %113 = fmul float %106, 0x3FEB333340000000
  br label %114

114:                                              ; preds = %197, %99
  %115 = phi i64 [ 2, %99 ], [ %202, %197 ]
  %116 = phi float [ %101, %99 ], [ %201, %197 ]
  %117 = phi float [ %102, %99 ], [ %200, %197 ]
  %118 = phi float [ %106, %99 ], [ %199, %197 ]
  %119 = phi i32 [ %25, %99 ], [ %198, %197 ]
  %120 = phi i32 [ 2, %99 ], [ %203, %197 ]
  %121 = trunc i64 %115 to i32
  %122 = add nsw i32 %107, %121
  %123 = trunc i64 %115 to i32
  %124 = shl i32 %123, 1
  %125 = udiv i32 %122, %124
  %126 = icmp slt i32 %125, %16
  br i1 %126, label %205, label %127

127:                                              ; preds = %114
  %128 = icmp eq i64 %115, 2
  br i1 %128, label %129, label %133

129:                                              ; preds = %127
  %130 = add nsw i32 %125, %25
  %131 = icmp sgt i32 %130, %15
  %132 = select i1 %131, i32 %25, i32 %130
  br label %139

133:                                              ; preds = %127
  %134 = getelementptr inbounds [16 x i32], [16 x i32]* @second_check, i64 0, i64 %115
  %135 = load i32, i32* %134, align 4
  %136 = mul i32 %107, %135
  %137 = add nsw i32 %136, %121
  %138 = udiv i32 %137, %124
  br label %139

139:                                              ; preds = %129, %133
  %140 = phi i32 [ %138, %133 ], [ %132, %129 ]
  %141 = sub nsw i32 0, %125
  %142 = sext i32 %141 to i64
  %143 = getelementptr inbounds float, float* %22, i64 %142
  %144 = sub nsw i32 0, %140
  %145 = sext i32 %144 to i64
  %146 = getelementptr inbounds float, float* %22, i64 %145
  call void @dual_inner_prod_sse(float* %22, float* %143, float* %146, i32 %20, float* nonnull %9, float* nonnull %11) #4
  %147 = load float, float* %9, align 4
  %148 = load float, float* %11, align 4
  %149 = fadd float %147, %148
  %150 = fmul float %149, 5.000000e-01
  store float %150, float* %9, align 4
  %151 = sext i32 %125 to i64
  %152 = getelementptr inbounds float, float* %29, i64 %151
  %153 = load float, float* %152, align 4
  %154 = sext i32 %140 to i64
  %155 = getelementptr inbounds float, float* %29, i64 %154
  %156 = load float, float* %155, align 4
  %157 = fadd float %153, %156
  %158 = fmul float %157, 5.000000e-01
  %159 = load float, float* %10, align 4
  %160 = fmul float %159, %158
  %161 = fadd float %160, 1.000000e+00
  %162 = call float @sqrtf(float %161) #6
  %163 = fdiv float %150, %162
  %164 = sub nsw i32 %125, %19
  %165 = icmp slt i32 %164, 0
  %166 = sub nsw i32 0, %164
  %167 = select i1 %165, i32 %166, i32 %164
  %168 = icmp slt i32 %167, 2
  br i1 %168, label %176, label %169

169:                                              ; preds = %139
  %170 = icmp eq i32 %167, 2
  br i1 %170, label %171, label %176

171:                                              ; preds = %169
  %172 = mul nuw nsw i32 %120, 5
  %173 = mul nsw i32 %172, %121
  %174 = icmp slt i32 %173, %25
  %175 = select i1 %174, float %108, float 0.000000e+00
  br label %176

176:                                              ; preds = %171, %169, %139
  %177 = phi float [ %6, %139 ], [ 0.000000e+00, %169 ], [ %175, %171 ]
  %178 = fsub float %109, %177
  %179 = icmp slt i32 %125, %110
  br i1 %179, label %180, label %184

180:                                              ; preds = %176
  %181 = fsub float %113, %177
  %182 = fcmp olt float %181, 0x3FD99999A0000000
  %183 = select i1 %182, float 0x3FD99999A0000000, float %181
  br label %192

184:                                              ; preds = %176
  %185 = fcmp olt float %178, 0x3FD3333340000000
  %186 = select i1 %185, float 0x3FD3333340000000, float %178
  %187 = icmp slt i32 %125, %111
  br i1 %187, label %188, label %192

188:                                              ; preds = %184
  %189 = fsub float %112, %177
  %190 = fcmp olt float %189, 5.000000e-01
  %191 = select i1 %190, float 5.000000e-01, float %189
  br label %192

192:                                              ; preds = %188, %180, %184
  %193 = phi float [ %186, %184 ], [ %183, %180 ], [ %191, %188 ]
  %194 = fcmp ogt float %163, %193
  br i1 %194, label %195, label %197

195:                                              ; preds = %192
  %196 = load float, float* %9, align 4
  br label %197

197:                                              ; preds = %195, %192
  %198 = phi i32 [ %119, %192 ], [ %125, %195 ]
  %199 = phi float [ %118, %192 ], [ %163, %195 ]
  %200 = phi float [ %117, %192 ], [ %196, %195 ]
  %201 = phi float [ %116, %192 ], [ %158, %195 ]
  %202 = add nuw nsw i64 %115, 1
  %203 = add nuw nsw i32 %120, 1
  %204 = icmp eq i64 %202, 16
  br i1 %204, label %205, label %114

205:                                              ; preds = %197, %114
  %206 = phi i32 [ %119, %114 ], [ %198, %197 ]
  %207 = phi float [ %118, %114 ], [ %199, %197 ]
  %208 = phi float [ %117, %114 ], [ %200, %197 ]
  %209 = phi float [ %116, %114 ], [ %201, %197 ]
  %210 = fcmp olt float %208, 0.000000e+00
  %211 = select i1 %210, float 0.000000e+00, float %208
  %212 = fcmp ugt float %209, %211
  br i1 %212, label %213, label %216

213:                                              ; preds = %205
  %214 = fadd float %209, 1.000000e+00
  %215 = fdiv float %211, %214
  br label %216

216:                                              ; preds = %205, %213
  %217 = phi float [ %215, %213 ], [ 1.000000e+00, %205 ]
  %218 = add i32 %206, -1
  %219 = sext i32 %218 to i64
  %220 = sub nsw i64 0, %219
  %221 = getelementptr inbounds float, float* %22, i64 %220
  %222 = call float @celt_inner_prod_sse(float* %22, float* %221, i32 %20) #4
  %223 = sext i32 %206 to i64
  %224 = sub nsw i64 0, %223
  %225 = getelementptr inbounds float, float* %22, i64 %224
  %226 = call float @celt_inner_prod_sse(float* %22, float* %225, i32 %20) #4
  %227 = add i32 %206, 1
  %228 = sext i32 %227 to i64
  %229 = sub nsw i64 0, %228
  %230 = getelementptr inbounds float, float* %22, i64 %229
  %231 = call float @celt_inner_prod_sse(float* %22, float* %230, i32 %20) #4
  %232 = fsub float %231, %222
  %233 = fsub float %226, %222
  %234 = fmul float %233, 0x3FE6666660000000
  %235 = fcmp ogt float %232, %234
  br i1 %235, label %242, label %236

236:                                              ; preds = %216
  %237 = fsub float %222, %231
  %238 = fsub float %226, %231
  %239 = fmul float %238, 0x3FE6666660000000
  %240 = fcmp ogt float %237, %239
  %241 = sext i1 %240 to i32
  br label %242

242:                                              ; preds = %236, %216
  %243 = phi i32 [ 1, %216 ], [ %241, %236 ]
  %244 = fcmp ogt float %217, %207
  %245 = select i1 %244, float %207, float %217
  %246 = shl nsw i32 %206, 1
  %247 = add nsw i32 %243, %246
  %248 = icmp slt i32 %247, %2
  %249 = select i1 %248, i32 %2, i32 %247
  store i32 %249, i32* %4, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %14) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %13) #4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %12) #4
  ret float %245
}

declare void @dual_inner_prod_sse(float*, float*, float*, i32, float*, float*) local_unnamed_addr #2

declare float @sqrtf(float) local_unnamed_addr

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }
attributes #5 = { noreturn nounwind }
attributes #6 = { nofree nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!3}
!3 = distinct !{!3, !4}
!4 = distinct !{!4, !"LVerDomain"}
!5 = !{!6}
!6 = distinct !{!6, !4}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.isvectorized", i32 1}
!9 = distinct !{!9, !8}
!10 = !{!11}
!11 = distinct !{!11, !12}
!12 = distinct !{!12, !"LVerDomain"}
!13 = !{!14}
!14 = distinct !{!14, !12}
!15 = distinct !{!15, !8}
!16 = distinct !{!16, !8}
!17 = distinct !{!17, !8}
!18 = distinct !{!18, !8}
!19 = distinct !{!19, !20, !8}
!20 = !{!"llvm.loop.unroll.runtime.disable"}
!21 = distinct !{!21, !20, !8}
!22 = distinct !{!22, !23}
!23 = !{!"llvm.loop.unroll.disable"}
!24 = distinct !{!24, !23}
