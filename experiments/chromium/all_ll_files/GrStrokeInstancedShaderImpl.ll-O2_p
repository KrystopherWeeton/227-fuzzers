; ModuleID = '../../third_party/skia/src/gpu/tessellate/GrStrokeInstancedShaderImpl.cpp'
source_filename = "../../third_party/skia/src/gpu/tessellate/GrStrokeInstancedShaderImpl.cpp"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"

%class.GrStrokeInstancedShaderImpl = type { %class.GrStrokeShaderImpl }
%class.GrStrokeShaderImpl = type { %class.GrGLSLGeometryProcessor, %class.GrResourceHandle, %class.GrResourceHandle, %class.GrResourceHandle, %class.GrResourceHandle, %class.GrResourceHandle, %class.SkString }
%class.GrGLSLGeometryProcessor = type { i32 (...)**, %class.SkTArray }
%class.SkTArray = type { %"struct.GrGLSLGeometryProcessor::TransformInfo"*, i64 }
%"struct.GrGLSLGeometryProcessor::TransformInfo" = type { %class.GrShaderVar, %class.GrShaderVar, %class.GrFragmentProcessor* }
%class.GrShaderVar = type { i32, i32, i32, %class.SkString, %class.SkString, %class.SkString }
%class.GrFragmentProcessor = type <{ %class.GrProcessor, %class.SkSTArray, %class.GrFragmentProcessor*, i32, %"struct.SkSL::SampleUsage", [4 x i8] }>
%class.GrProcessor = type { i32 (...)**, i32, i32 }
%class.SkSTArray = type { %class.SkAlignedSTStorage, %class.SkTArray.1 }
%class.SkAlignedSTStorage = type { [8 x i8] }
%class.SkTArray.1 = type { %"class.std::__1::unique_ptr"*, i64 }
%"class.std::__1::unique_ptr" = type { %"class.std::__1::__compressed_pair" }
%"class.std::__1::__compressed_pair" = type { %"struct.std::__1::__compressed_pair_elem" }
%"struct.std::__1::__compressed_pair_elem" = type { %class.GrFragmentProcessor* }
%"struct.SkSL::SampleUsage" = type <{ i32, i8, [3 x i8] }>
%class.GrResourceHandle = type { i32 }
%class.SkString = type { %class.sk_sp }
%class.sk_sp = type { %"struct.SkString::Rec"* }
%"struct.SkString::Rec" = type <{ i32, %"struct.std::__1::atomic", i8, [3 x i8] }>
%"struct.std::__1::atomic" = type { %"struct.std::__1::__atomic_base" }
%"struct.std::__1::__atomic_base" = type { %"struct.std::__1::__atomic_base.0" }
%"struct.std::__1::__atomic_base.0" = type { %"struct.std::__1::__cxx_atomic_impl" }
%"struct.std::__1::__cxx_atomic_impl" = type { %"struct.std::__1::__cxx_atomic_base_impl" }
%"struct.std::__1::__cxx_atomic_base_impl" = type { i32 }
%"struct.GrGLSLGeometryProcessor::EmitArgs" = type { %class.GrGLSLVertexBuilder*, %class.GrGLSLGeometryBuilder*, %class.GrGLSLFPFragmentBuilder*, %class.GrGLSLVaryingHandler*, %class.GrGLSLUniformHandler*, %class.GrShaderCaps*, %class.GrGeometryProcessor*, i8*, i8*, %class.GrResourceHandle.22*, %"class.GrGLSLGeometryProcessor::FPCoordTransformHandler"* }
%class.GrGLSLVertexBuilder = type { %class.GrGLSLVertexGeoBuilder.base, [12 x i8] }
%class.GrGLSLVertexGeoBuilder.base = type { %class.GrGLSLShaderBuilder.base }
%class.GrGLSLShaderBuilder.base = type <{ i32 (...)**, %class.GrGLSLProgramBuilder*, %"class.SkSL::String", %class.SkSTArray.6, %class.SkString, %class.SkString, %class.SkString, %class.SkSTArray.9, [8 x i8], %class.GrTBlockList, %class.GrTBlockList, i32, [4 x i8], [2 x %class.SkSTArray.18], i32, i8, [3 x i8], i32 }>
%class.GrGLSLProgramBuilder = type opaque
%"class.SkSL::String" = type { %"class.std::__1::basic_string" }
%"class.std::__1::basic_string" = type { %"class.std::__1::__compressed_pair.3" }
%"class.std::__1::__compressed_pair.3" = type { %"struct.std::__1::__compressed_pair_elem.4" }
%"struct.std::__1::__compressed_pair_elem.4" = type { %"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep" }
%"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep" = type { %union.anon }
%union.anon = type { %"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long" }
%"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long" = type { i8*, i64, i64 }
%class.SkSTArray.6 = type { %class.SkAlignedSTStorage.7, %class.SkTArray.8 }
%class.SkAlignedSTStorage.7 = type { [120 x i8] }
%class.SkTArray.8 = type { %class.SkString*, i64 }
%class.SkSTArray.9 = type { %class.SkAlignedSTStorage.10, %class.SkTArray.11 }
%class.SkAlignedSTStorage.10 = type { [16 x i8] }
%class.SkTArray.11 = type { %"class.std::__1::unique_ptr.12"*, i64 }
%"class.std::__1::unique_ptr.12" = type { %"class.std::__1::__compressed_pair.13" }
%"class.std::__1::__compressed_pair.13" = type { %"struct.std::__1::__compressed_pair_elem.14" }
%"struct.std::__1::__compressed_pair_elem.14" = type { %"class.SkSL::Statement"* }
%"class.SkSL::Statement" = type { %"class.SkSL::IRNode" }
%"class.SkSL::IRNode" = type { i32 (...)**, i32, i32 }
%class.GrTBlockList = type { %class.GrSBlockAllocator }
%class.GrSBlockAllocator = type { [88 x i8], [8 x i8] }
%class.SkSTArray.18 = type { %class.SkAlignedSTStorage.19, %class.SkTArray.8 }
%class.SkAlignedSTStorage.19 = type { [8 x i8] }
%class.GrGLSLGeometryBuilder = type { %class.GrGLSLVertexGeoBuilder.base, i32, [8 x i8] }
%class.GrGLSLFPFragmentBuilder = type <{ i32 (...)**, [4 x i8], [4 x i8], %class.GrGLSLShaderBuilder.base, [12 x i8] }>
%class.GrGLSLVaryingHandler = type { i32 (...)**, [8 x i8], %class.GrTBlockList.20, %class.GrTBlockList, %class.GrTBlockList, %class.GrTBlockList, %class.GrTBlockList, %class.GrTBlockList, %class.GrTBlockList, %class.GrGLSLProgramBuilder*, i8* }
%class.GrTBlockList.20 = type { %class.GrSBlockAllocator.21 }
%class.GrSBlockAllocator.21 = type { [80 x i8] }
%class.GrGLSLUniformHandler = type { i32 (...)**, %class.GrGLSLProgramBuilder* }
%class.GrShaderCaps = type <{ %class.SkRefCnt.base, i32, i56, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i32, i32, i32, [4 x i8] }>
%class.SkRefCnt.base = type { %class.SkRefCntBase.base }
%class.SkRefCntBase.base = type <{ i32 (...)**, %"struct.std::__1::atomic" }>
%class.GrGeometryProcessor = type <{ %class.GrProcessor, %class.GrNonAtomicRef, i32, %"class.GrGeometryProcessor::AttributeSet", %"class.GrGeometryProcessor::AttributeSet", i32, [4 x i8] }>
%class.GrNonAtomicRef = type { i32 }
%"class.GrGeometryProcessor::AttributeSet" = type { %"class.GrGeometryProcessor::Attribute"*, i32, i32, i64 }
%"class.GrGeometryProcessor::Attribute" = type { i8*, i32, i32 }
%class.GrResourceHandle.22 = type { i32 }
%"class.GrGLSLGeometryProcessor::FPCoordTransformHandler" = type { %"class.GrFragmentProcessor::CIter", %class.SkTArray.26* }
%"class.GrFragmentProcessor::CIter" = type { %class.SkSTArray.23 }
%class.SkSTArray.23 = type { %class.SkAlignedSTStorage.24, %class.SkTArray.25 }
%class.SkAlignedSTStorage.24 = type { [32 x i8] }
%class.SkTArray.25 = type { %class.GrFragmentProcessor**, i64 }
%class.SkTArray.26 = type { %class.GrShaderVar*, i64 }
%"struct.GrGLSLGeometryProcessor::GrGPArgs" = type { %class.GrShaderVar, %class.GrShaderVar }
%class.GrGLSLVarying = type { i32, i32, i8*, i8*, i8*, i8* }
%class.GrStrokeShader = type <{ %class.GrPathShader.base, i32, i32, %class.SkStrokeRec, %struct.SkRGBA4f, [4 x i8], %class.SkSTArray.27, float, [4 x i8] }>
%class.GrPathShader.base = type { %class.GrGeometryProcessor.base, %class.SkMatrix, i8, i32 }
%class.GrGeometryProcessor.base = type <{ %class.GrProcessor, %class.GrNonAtomicRef, i32, %"class.GrGeometryProcessor::AttributeSet", %"class.GrGeometryProcessor::AttributeSet", i32 }>
%class.SkMatrix = type { [9 x float], i32 }
%class.SkStrokeRec = type { float, float, float, i32 }
%struct.SkRGBA4f = type { float, float, float, float }
%class.SkSTArray.27 = type { %class.SkAlignedSTStorage.28, %class.SkTArray.29 }
%class.SkAlignedSTStorage.28 = type { [80 x i8] }
%class.SkTArray.29 = type { %"class.GrGeometryProcessor::Attribute"*, i64 }
%class.GrGLSLShaderBuilder = type <{ i32 (...)**, %class.GrGLSLProgramBuilder*, %"class.SkSL::String", %class.SkSTArray.6, %class.SkString, %class.SkString, %class.SkString, %class.SkSTArray.9, [8 x i8], %class.GrTBlockList, %class.GrTBlockList, i32, [4 x i8], [2 x %class.SkSTArray.18], i32, i8, [3 x i8], i32, [12 x i8] }>
%class.GrGLSLVertexGeoBuilder = type { %class.GrGLSLShaderBuilder.base, [12 x i8] }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%class.GrGLSLProgramDataManager = type { i32 (...)** }

$_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz = comdat any

$_ZN18GrStrokeShaderImplD2Ev = comdat any

$_ZN27GrStrokeInstancedShaderImplD0Ev = comdat any

$_ZNK23GrGLSLGeometryProcessor24getTessControlShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps = comdat any

$_ZNK23GrGLSLGeometryProcessor27getTessEvaluationShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps = comdat any

$_ZN23GrGLSLGeometryProcessorD2Ev = comdat any

$_ZN23GrGLSLGeometryProcessorD0Ev = comdat any

$_ZN23GrGLSLGeometryProcessor13TransformInfoD2Ev = comdat any

$_ZTV23GrGLSLGeometryProcessor = comdat any

@.str = private unnamed_addr constant [29 x i8] c"MAX_PARAMETRIC_SEGMENTS_LOG2\00", align 1
@.str.1 = private unnamed_addr constant [6 x i8] c"float\00", align 1
@.str.2 = private unnamed_addr constant [3 x i8] c"PI\00", align 1
@.str.3 = private unnamed_addr constant [21 x i8] c"3.141592653589793238\00", align 1
@_ZN18GrStrokeShaderImpl29kNumRadialSegmentsPerRadianFnE = external local_unnamed_addr global i8*, align 8
@_ZN18GrStrokeShaderImpl8kAtan2FnE = external local_unnamed_addr global i8*, align 8
@_ZN18GrStrokeShaderImpl23kCosineBetweenVectorsFnE = external local_unnamed_addr global i8*, align 8
@_ZN18GrStrokeShaderImpl14kMiterExtentFnE = external local_unnamed_addr global i8*, align 8
@_ZN18GrStrokeShaderImpl15kUncheckedMixFnE = external local_unnamed_addr global i8*, align 8
@.str.4 = private unnamed_addr constant [16 x i8] c"tessControlArgs\00", align 1
@.str.5 = private unnamed_addr constant [165 x i8] c"\0A        float PARAMETRIC_PRECISION = %s.x;\0A        float NUM_RADIAL_SEGMENTS_PER_RADIAN = %s.y;\0A        float JOIN_TYPE = %s.z;\0A        float STROKE_RADIUS = %s.w;\00", align 1
@.str.6 = private unnamed_addr constant [20 x i8] c"parametricPrecision\00", align 1
@.str.7 = private unnamed_addr constant [273 x i8] c"\0A        float PARAMETRIC_PRECISION = %s;\0A        float STROKE_RADIUS = dynamicStrokeAttr.x;\0A        float NUM_RADIAL_SEGMENTS_PER_RADIAN = num_radial_segments_per_radian(\0A                PARAMETRIC_PRECISION, STROKE_RADIUS);\0A        float JOIN_TYPE = dynamicStrokeAttr.y;\00", align 1
@.str.8 = private unnamed_addr constant [13 x i8] c"dynamicColor\00", align 1
@.str.9 = private unnamed_addr constant [23 x i8] c"%s = dynamicColorAttr;\00", align 1
@.str.10 = private unnamed_addr constant [50 x i8] c"\0A        float NUM_TOTAL_EDGES = abs(argsAttr.z);\00", align 1
@.str.11 = private unnamed_addr constant [10 x i8] c"edgeCount\00", align 1
@.str.12 = private unnamed_addr constant [37 x i8] c"\0A        float NUM_TOTAL_EDGES = %s;\00", align 1
@.str.13 = private unnamed_addr constant [13 x i8] c"affineMatrix\00", align 1
@.str.14 = private unnamed_addr constant [10 x i8] c"translate\00", align 1
@.str.15 = private unnamed_addr constant [40 x i8] c"float2x2 AFFINE_MATRIX = float2x2(%s);\0A\00", align 1
@.str.16 = private unnamed_addr constant [24 x i8] c"float2 TRANSLATE = %s;\0A\00", align 1
@.str.17 = private unnamed_addr constant [333 x i8] c"\0A    float4x2 P = float4x2(pts01Attr, pts23Attr);\0A    float2 lastControlPoint = argsAttr.xy;\0A    float w = -1;  // w<0 means the curve is an integral cubic.\0A    if (isinf(P[3].y)) {\0A        w = P[3].x;  // The curve is actually a conic.\0A        P[3] = P[2];  // Setting p3 equal to p2 works for the remaining rotational logic.\0A    }\00", align 1
@.str.18 = private unnamed_addr constant [93 x i8] c"\0A        P = AFFINE_MATRIX * P;\0A        lastControlPoint = AFFINE_MATRIX * lastControlPoint;\00", align 1
@.str.19 = private unnamed_addr constant [914 x i8] c"\0A    // Find how many parametric segments this stroke requires.\0A    float numParametricSegments = min(wangs_formula(PARAMETRIC_PRECISION,\0A                                                    P[0], P[1], P[2], P[3], w),\0A                                      float(1 << MAX_PARAMETRIC_SEGMENTS_LOG2));\0A    if (P[0] == P[1] && P[2] == P[3]) {\0A        // This is how we describe lines, but Wang's formula does not return 1 in this case.\0A        numParametricSegments = 1;\0A    }\0A\0A    // Find the starting and ending tangents.\0A    float2 tan0 = ((P[0] == P[1]) ? (P[1] == P[2]) ? P[3] : P[2] : P[1]) - P[0];\0A    float2 tan1 = P[3] - ((P[3] == P[2]) ? (P[2] == P[1]) ? P[0] : P[1] : P[2]);\0A    if (tan0 == float2(0)) {\0A        // The stroke is a point. This special case tells us to draw a stroke-width circle as a\0A        // 180 degree point stroke instead.\0A        tan0 = float2(1,0);\0A        tan1 = float2(-1,0);\0A    }\00", align 1
@.str.20 = private unnamed_addr constant [839 x i8] c"\0A        // Determine how many edges to give to the round join. We emit the first and final edges\0A        // of the join twice: once full width and once restricted to half width. This guarantees\0A        // perfect seaming by matching the vertices from the join as well as from the strokes on\0A        // either side.\0A        float joinRads = acos(cosine_between_vectors(P[0] - lastControlPoint, tan0));\0A        float numRadialSegmentsInJoin = max(ceil(joinRads * NUM_RADIAL_SEGMENTS_PER_RADIAN), 1);\0A        // +2 because we emit the beginning and ending edges twice (see above comment).\0A        float numEdgesInJoin = numRadialSegmentsInJoin + 2;\0A        // The stroke section needs at least two edges. Don't assign more to the join than\0A        // \22NUM_TOTAL_EDGES - 2\22.\0A        numEdgesInJoin = min(numEdgesInJoin, NUM_TOTAL_EDGES - 2);\00", align 1
@.str.21 = private unnamed_addr constant [346 x i8] c"\0A            // Negative argsAttr.z means the join is an internal chop or circle, and both of\0A            // those have empty joins. All we need is a bevel join.\0A            if (argsAttr.z < 0) {\0A                // +2 because we emit the beginning and ending edges twice (see above comment).\0A                numEdgesInJoin = 1 + 2;\0A            }\00", align 1
@.str.22 = private unnamed_addr constant [314 x i8] c"\0A            if (JOIN_TYPE >= 0 /*Is the join not a round type?*/) {\0A                // Bevel and miter joins get 1 and 2 segments respectively.\0A                // +2 because we emit the beginning and ending edges twice (see above comments).\0A                numEdgesInJoin = sign(JOIN_TYPE) + 1 + 2;\0A            }\00", align 1
@.str.23 = private unnamed_addr constant [36 x i8] c"\0A        float numEdgesInJoin = %i;\00", align 1
@.str.24 = private unnamed_addr constant [3726 x i8] c"\0A    // Find which direction the curve turns.\0A    // NOTE: Since the curve is not allowed to inflect, we can just check F'(.5) x F''(.5).\0A    // NOTE: F'(.5) x F''(.5) has the same sign as (P2 - P0) x (P3 - P1)\0A    float turn = cross(P[2] - P[0], P[3] - P[1]);\0A    float combinedEdgeID = float(sk_VertexID >> 1) - numEdgesInJoin;\0A    if (combinedEdgeID < 0) {\0A        tan1 = tan0;\0A        // Don't let tan0 become zero. The code as-is isn't built to handle that case. tan0=0\0A        // means the join is disabled, and to disable it with the existing code we can leave\0A        // tan0 equal to tan1.\0A        if (lastControlPoint != P[0]) {\0A            tan0 = P[0] - lastControlPoint;\0A        }\0A        turn = cross(tan0, tan1);\0A    }\0A\0A    // Calculate the curve's starting angle and rotation.\0A    float cosTheta = cosine_between_vectors(tan0, tan1);\0A    float rotation = acos(cosTheta);\0A    if (turn < 0) {\0A        // Adjust sign of rotation to match the direction the curve turns.\0A        rotation = -rotation;\0A    }\0A\0A    float numRadialSegments;\0A    float strokeOutset = ((sk_VertexID & 1) == 0) ? +1 : -1;\0A    if (combinedEdgeID < 0) {\0A        // We belong to the preceding join. The first and final edges get duplicated, so we only\0A        // have \22numEdgesInJoin - 2\22 segments.\0A        numRadialSegments = numEdgesInJoin - 2;\0A        numParametricSegments = 1;  // Joins don't have parametric segments.\0A        P = float4x2(P[0], P[0], P[0], P[0]);  // Colocate all points on the junction point.\0A        // Shift combinedEdgeID to the range [-1, numRadialSegments]. This duplicates the first\0A        // edge and lands one edge at the very end of the join. (The duplicated final edge will\0A        // actually come from the section of our strip that belongs to the stroke.)\0A        combinedEdgeID += numRadialSegments + 1;\0A        // We normally restrict the join on one side of the junction, but if the tangents are\0A        // nearly equivalent this could theoretically result in bad seaming and/or cracks on the\0A        // side we don't put it on. If the tangents are nearly equivalent then we leave the join\0A        // double-sided.\0A        float sinEpsilon = 1e-2;  // ~= sin(180deg / 3000)\0A        bool tangentsNearlyParallel =\0A                (abs(turn) * inversesqrt(dot(tan0, tan0) * dot(tan1, tan1))) < sinEpsilon;\0A        if (!tangentsNearlyParallel || dot(tan0, tan1) < 0) {\0A            // There are two edges colocated at the beginning. Leave the first one double sided\0A            // for seaming with the previous stroke. (The double sided edge at the end will\0A            // actually come from the section of our strip that belongs to the stroke.)\0A            if (combinedEdgeID >= 0) {\0A                strokeOutset = (turn < 0) ? min(strokeOutset, 0) : max(strokeOutset, 0);\0A            }\0A        }\0A        combinedEdgeID = max(combinedEdgeID, 0);\0A    } else {\0A        // We belong to the stroke.\0A        float maxCombinedSegments = NUM_TOTAL_EDGES - numEdgesInJoin - 1;\0A        numRadialSegments = max(ceil(abs(rotation) * NUM_RADIAL_SEGMENTS_PER_RADIAN), 1);\0A        numRadialSegments = min(numRadialSegments, maxCombinedSegments);\0A        numParametricSegments = min(numParametricSegments,\0A                                    maxCombinedSegments - numRadialSegments + 1);\0A    }\0A\0A    // Additional parameters for emitTessellationCode().\0A    float angle0 = atan2(tan0);\0A    float radsPerSegment = rotation / numRadialSegments;\0A    float numCombinedSegments = numParametricSegments + numRadialSegments - 1;\0A    bool isFinalEdge = (combinedEdgeID >= numCombinedSegments);\0A    if (combinedEdgeID > numCombinedSegments) {\0A        strokeOutset = 0;  // The strip has more edges than we need. Drop this one.\0A    }\00", align 1
@.str.25 = private unnamed_addr constant [232 x i8] c"\0A        // Vertices #4 and #5 belong to the edge of the join that extends to the miter point.\0A        if ((sk_VertexID | 1) == (4 | 5) && %s) {\0A            strokeOutset *= miter_extent(cosTheta, JOIN_TYPE/*miterLimit*/);\0A        }\00", align 1
@.str.26 = private unnamed_addr constant [43 x i8] c"JOIN_TYPE > 0/*Is the join a miter type?*/\00", align 1
@.str.27 = private unnamed_addr constant [5 x i8] c"true\00", align 1
@_ZTV27GrStrokeInstancedShaderImpl = hidden unnamed_addr constant { [8 x i8*] } { [8 x i8*] [i8* null, i8* null, i8* bitcast (void (%class.GrStrokeShaderImpl*)* @_ZN18GrStrokeShaderImplD2Ev to i8*), i8* bitcast (void (%class.GrStrokeInstancedShaderImpl*)* @_ZN27GrStrokeInstancedShaderImplD0Ev to i8*), i8* bitcast (void (%class.GrStrokeShaderImpl*, %class.GrGLSLProgramDataManager*, %class.GrShaderCaps*, %class.GrGeometryProcessor*)* @_ZN18GrStrokeShaderImpl7setDataERK24GrGLSLProgramDataManagerRK12GrShaderCapsRK19GrGeometryProcessor to i8*), i8* bitcast (void (%class.SkString*, %class.GrGLSLGeometryProcessor*, %class.GrGeometryProcessor*, i8*, %class.GrGLSLUniformHandler*, %class.GrShaderCaps*)* @_ZNK23GrGLSLGeometryProcessor24getTessControlShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps to i8*), i8* bitcast (void (%class.SkString*, %class.GrGLSLGeometryProcessor*, %class.GrGeometryProcessor*, i8*, %class.GrGLSLUniformHandler*, %class.GrShaderCaps*)* @_ZNK23GrGLSLGeometryProcessor27getTessEvaluationShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps to i8*), i8* bitcast (void (%class.GrStrokeInstancedShaderImpl*, %"struct.GrGLSLGeometryProcessor::EmitArgs"*, %"struct.GrGLSLGeometryProcessor::GrGPArgs"*)* @_ZN27GrStrokeInstancedShaderImpl10onEmitCodeERN23GrGLSLGeometryProcessor8EmitArgsEPNS0_8GrGPArgsE to i8*)] }, align 8
@.str.28 = private unnamed_addr constant [20 x i8] c"const int %s = %i;\0A\00", align 1
@.str.29 = private unnamed_addr constant [19 x i8] c"const %s %s = %s;\0A\00", align 1
@.str.30 = private unnamed_addr constant [648 x i8] c"\0A    float length_pow2(float2 v) {\0A        return dot(v, v);\0A    }\0A    float wangs_formula(float parametricPrecision, float2 p0, float2 p1, float2 p2, float2 p3,\0A                        float w) {\0A        const float CUBIC_TERM_POW2 = %f;\0A        float l0 = length_pow2(fma(float2(-2), p1, p2) + p0);\0A        float l1 = length_pow2(fma(float2(-2), p2, p3) + p1);\0A        float m = CUBIC_TERM_POW2 * max(l0, l1);\0A        // FIXME: Use the better formula from GrWangsFormula::conic().\0A        const float QUAD_TERM_POW2 = %f;\0A        m = (w >= 0.0) ? QUAD_TERM_POW2 * l0 : m;\0A        return max(ceil(sqrt(parametricPrecision * sqrt(m))), 1.0);\0A    }\00", align 1
@_ZTV18GrStrokeShaderImpl = external unnamed_addr constant { [8 x i8*] }, align 8
@_ZTV23GrGLSLGeometryProcessor = linkonce_odr hidden unnamed_addr constant { [8 x i8*] } { [8 x i8*] [i8* null, i8* null, i8* bitcast (void (%class.GrGLSLGeometryProcessor*)* @_ZN23GrGLSLGeometryProcessorD2Ev to i8*), i8* bitcast (void (%class.GrGLSLGeometryProcessor*)* @_ZN23GrGLSLGeometryProcessorD0Ev to i8*), i8* bitcast (void ()* @__cxa_pure_virtual to i8*), i8* bitcast (void (%class.SkString*, %class.GrGLSLGeometryProcessor*, %class.GrGeometryProcessor*, i8*, %class.GrGLSLUniformHandler*, %class.GrShaderCaps*)* @_ZNK23GrGLSLGeometryProcessor24getTessControlShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps to i8*), i8* bitcast (void (%class.SkString*, %class.GrGLSLGeometryProcessor*, %class.GrGeometryProcessor*, i8*, %class.GrGLSLUniformHandler*, %class.GrShaderCaps*)* @_ZNK23GrGLSLGeometryProcessor27getTessEvaluationShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps to i8*), i8* bitcast (void ()* @__cxa_pure_virtual to i8*)] }, comdat, align 8
@.str.32 = private unnamed_addr constant [62 x i8] c"../../third_party/skia/src/gpu/glsl/GrGLSLGeometryProcessor.h\00", align 1
@.str.33 = private unnamed_addr constant [17 x i8] c"Not implemented.\00", align 1
@switch.table._ZN27GrStrokeInstancedShaderImpl10onEmitCodeERN23GrGLSLGeometryProcessor8EmitArgsEPNS0_8GrGPArgsE = private unnamed_addr constant [3 x i32] [i32 4, i32 3, i32 3], align 4

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN27GrStrokeInstancedShaderImpl10onEmitCodeERN23GrGLSLGeometryProcessor8EmitArgsEPNS0_8GrGPArgsE(%class.GrStrokeInstancedShaderImpl*, %"struct.GrGLSLGeometryProcessor::EmitArgs"* dereferenceable(88), %"struct.GrGLSLGeometryProcessor::GrGPArgs"*) unnamed_addr #0 align 2 {
  %4 = alloca %class.SkString, align 8
  %5 = alloca i8*, align 8
  %6 = alloca i8*, align 8
  %7 = alloca %class.GrGLSLVarying, align 8
  %8 = alloca i8*, align 8
  %9 = alloca i8*, align 8
  %10 = alloca i8*, align 8
  %11 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 6
  %12 = bitcast %class.GrGeometryProcessor** %11 to %class.GrStrokeShader**
  %13 = load %class.GrStrokeShader*, %class.GrStrokeShader** %12, align 8
  %14 = getelementptr inbounds %class.GrStrokeShader, %class.GrStrokeShader* %13, i64 0, i32 3
  %15 = getelementptr inbounds %class.GrStrokeShader, %class.GrStrokeShader* %13, i64 0, i32 3, i32 3
  %16 = load i32, i32* %15, align 4
  %17 = lshr i32 %16, 16
  %18 = trunc i32 %17 to i8
  %19 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 3
  %20 = load %class.GrGLSLVaryingHandler*, %class.GrGLSLVaryingHandler** %19, align 8
  %21 = bitcast %class.GrStrokeShader* %13 to %class.GrGeometryProcessor*
  tail call void @_ZN20GrGLSLVaryingHandler14emitAttributesERK19GrGeometryProcessor(%class.GrGLSLVaryingHandler* %20, %class.GrGeometryProcessor* dereferenceable(80) %21) #5
  %22 = bitcast %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1 to %class.GrGLSLShaderBuilder**
  %23 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %24 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %23, i64 0, i32 3, i32 0, i32 0, i64 120
  %25 = bitcast i8* %24 to %class.SkString**
  %26 = load %class.SkString*, %class.SkString** %25, align 8
  %27 = getelementptr inbounds %class.SkString, %class.SkString* %26, i64 1
  tail call void (%class.SkString*, i8*, ...) @_ZN8SkString7appendfEPKcz(%class.SkString* %27, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i64 0, i64 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str, i64 0, i64 0), i32 10) #5
  %28 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %29 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %28, i64 0, i32 3, i32 0, i32 0, i64 120
  %30 = bitcast i8* %29 to %class.SkString**
  %31 = load %class.SkString*, %class.SkString** %30, align 8
  %32 = getelementptr inbounds %class.SkString, %class.SkString* %31, i64 1
  tail call void (%class.SkString*, i8*, ...) @_ZN8SkString7appendfEPKcz(%class.SkString* %32, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.29, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.1, i64 0, i64 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.2, i64 0, i64 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.3, i64 0, i64 0)) #5
  %33 = getelementptr inbounds %class.GrStrokeShader, %class.GrStrokeShader* %13, i64 0, i32 2
  %34 = load i32, i32* %33, align 8
  %35 = and i32 %34, 2
  %36 = icmp eq i32 %35, 0
  %37 = bitcast %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1 to %class.GrGLSLVertexGeoBuilder**
  br i1 %36, label %44, label %38

38:                                               ; preds = %3
  %39 = load %class.GrGLSLVertexGeoBuilder*, %class.GrGLSLVertexGeoBuilder** %37, align 8
  %40 = load i8*, i8** @_ZN18GrStrokeShaderImpl29kNumRadialSegmentsPerRadianFnE, align 8
  %41 = getelementptr inbounds %class.GrGLSLVertexGeoBuilder, %class.GrGLSLVertexGeoBuilder* %39, i64 0, i32 0, i32 3, i32 1, i32 0
  %42 = load %class.SkString*, %class.SkString** %41, align 8
  %43 = getelementptr inbounds %class.SkString, %class.SkString* %42, i64 7
  tail call void @_ZN8SkString6insertEmPKc(%class.SkString* %43, i64 -1, i8* %40) #5
  br label %44

44:                                               ; preds = %3, %38
  %45 = load %class.GrGLSLVertexGeoBuilder*, %class.GrGLSLVertexGeoBuilder** %37, align 8
  %46 = load i8*, i8** @_ZN18GrStrokeShaderImpl8kAtan2FnE, align 8
  %47 = getelementptr inbounds %class.GrGLSLVertexGeoBuilder, %class.GrGLSLVertexGeoBuilder* %45, i64 0, i32 0, i32 3, i32 1, i32 0
  %48 = load %class.SkString*, %class.SkString** %47, align 8
  %49 = getelementptr inbounds %class.SkString, %class.SkString* %48, i64 7
  tail call void @_ZN8SkString6insertEmPKc(%class.SkString* %49, i64 -1, i8* %46) #5
  %50 = load %class.GrGLSLVertexGeoBuilder*, %class.GrGLSLVertexGeoBuilder** %37, align 8
  %51 = load i8*, i8** @_ZN18GrStrokeShaderImpl23kCosineBetweenVectorsFnE, align 8
  %52 = getelementptr inbounds %class.GrGLSLVertexGeoBuilder, %class.GrGLSLVertexGeoBuilder* %50, i64 0, i32 0, i32 3, i32 1, i32 0
  %53 = load %class.SkString*, %class.SkString** %52, align 8
  %54 = getelementptr inbounds %class.SkString, %class.SkString* %53, i64 7
  tail call void @_ZN8SkString6insertEmPKc(%class.SkString* %54, i64 -1, i8* %51) #5
  %55 = load %class.GrGLSLVertexGeoBuilder*, %class.GrGLSLVertexGeoBuilder** %37, align 8
  %56 = load i8*, i8** @_ZN18GrStrokeShaderImpl14kMiterExtentFnE, align 8
  %57 = getelementptr inbounds %class.GrGLSLVertexGeoBuilder, %class.GrGLSLVertexGeoBuilder* %55, i64 0, i32 0, i32 3, i32 1, i32 0
  %58 = load %class.SkString*, %class.SkString** %57, align 8
  %59 = getelementptr inbounds %class.SkString, %class.SkString* %58, i64 7
  tail call void @_ZN8SkString6insertEmPKc(%class.SkString* %59, i64 -1, i8* %56) #5
  %60 = load %class.GrGLSLVertexGeoBuilder*, %class.GrGLSLVertexGeoBuilder** %37, align 8
  %61 = load i8*, i8** @_ZN18GrStrokeShaderImpl15kUncheckedMixFnE, align 8
  %62 = getelementptr inbounds %class.GrGLSLVertexGeoBuilder, %class.GrGLSLVertexGeoBuilder* %60, i64 0, i32 0, i32 3, i32 1, i32 0
  %63 = load %class.SkString*, %class.SkString** %62, align 8
  %64 = getelementptr inbounds %class.SkString, %class.SkString* %63, i64 7
  tail call void @_ZN8SkString6insertEmPKc(%class.SkString* %64, i64 -1, i8* %61) #5
  %65 = load %class.GrGLSLVertexGeoBuilder*, %class.GrGLSLVertexGeoBuilder** %37, align 8
  %66 = bitcast %class.SkString* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %66) #5
  %67 = getelementptr inbounds %class.SkString, %class.SkString* %4, i64 0, i32 0, i32 0
  store %"struct.SkString::Rec"* inttoptr (i64 -6148914691236517206 to %"struct.SkString::Rec"*), %"struct.SkString::Rec"** %67, align 8, !alias.scope !2
  call void @_ZN8SkStringC1Ev(%class.SkString* nonnull %4) #5
  call void (%class.SkString*, i8*, ...) @_ZN8SkString7appendfEPKcz(%class.SkString* nonnull %4, i8* getelementptr inbounds ([648 x i8], [648 x i8]* @.str.30, i64 0, i64 0), double 5.625000e-01, double 6.250000e-02) #5
  %68 = load %"struct.SkString::Rec"*, %"struct.SkString::Rec"** %67, align 8
  %69 = getelementptr inbounds %"struct.SkString::Rec", %"struct.SkString::Rec"* %68, i64 0, i32 2
  %70 = getelementptr inbounds %class.GrGLSLVertexGeoBuilder, %class.GrGLSLVertexGeoBuilder* %65, i64 0, i32 0, i32 3, i32 1, i32 0
  %71 = load %class.SkString*, %class.SkString** %70, align 8
  %72 = getelementptr inbounds %class.SkString, %class.SkString* %71, i64 7
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %72, i64 -1, i8* %69) #5
  call void @_ZN8SkStringD1Ev(%class.SkString* nonnull %4) #5
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %66) #5
  %73 = load i32, i32* %33, align 8
  %74 = and i32 %73, 2
  %75 = icmp eq i32 %74, 0
  br i1 %75, label %76, label %88

76:                                               ; preds = %44
  %77 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %77) #5
  store i8* inttoptr (i64 -6148914691236517206 to i8*), i8** %5, align 8
  %78 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 4
  %79 = load %class.GrGLSLUniformHandler*, %class.GrGLSLUniformHandler** %78, align 8
  %80 = bitcast %class.GrGLSLUniformHandler* %79 to i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)***
  %81 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)**, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*** %80, align 8
  %82 = getelementptr inbounds i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %81, i64 13
  %83 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %82, align 8
  %84 = call i32 %83(%class.GrGLSLUniformHandler* %79, %class.GrFragmentProcessor* null, i32 1, i32 24, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.4, i64 0, i64 0), i1 zeroext true, i32 0, i8** nonnull %5) #5
  %85 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 1, i32 0
  store i32 %84, i32* %85, align 8
  %86 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %87 = load i8*, i8** %5, align 8
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %86, i8* getelementptr inbounds ([165 x i8], [165 x i8]* @.str.5, i64 0, i64 0), i8* %87, i8* %87, i8* %87, i8* %87)
  br label %100

88:                                               ; preds = %44
  %89 = bitcast i8** %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %89) #5
  store i8* inttoptr (i64 -6148914691236517206 to i8*), i8** %6, align 8
  %90 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 4
  %91 = load %class.GrGLSLUniformHandler*, %class.GrGLSLUniformHandler** %90, align 8
  %92 = bitcast %class.GrGLSLUniformHandler* %91 to i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)***
  %93 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)**, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*** %92, align 8
  %94 = getelementptr inbounds i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %93, i64 13
  %95 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %94, align 8
  %96 = call i32 %95(%class.GrGLSLUniformHandler* %91, %class.GrFragmentProcessor* null, i32 1, i32 21, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.6, i64 0, i64 0), i1 zeroext true, i32 0, i8** nonnull %6) #5
  %97 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 1, i32 0
  store i32 %96, i32* %97, align 8
  %98 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %99 = load i8*, i8** %6, align 8
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %98, i8* getelementptr inbounds ([273 x i8], [273 x i8]* @.str.7, i64 0, i64 0), i8* %99)
  br label %100

100:                                              ; preds = %88, %76
  %101 = phi i8* [ %89, %88 ], [ %77, %76 ]
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %101) #5
  %102 = load i32, i32* %33, align 8
  %103 = and i32 %102, 4
  %104 = icmp eq i32 %103, 0
  br i1 %104, label %118, label %105

105:                                              ; preds = %100
  %106 = bitcast %class.GrGLSLVarying* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 40, i8* nonnull %106) #5
  %107 = getelementptr inbounds %class.GrGLSLVarying, %class.GrGLSLVarying* %7, i64 0, i32 0
  %108 = getelementptr inbounds %class.GrGLSLVarying, %class.GrGLSLVarying* %7, i64 0, i32 1
  %109 = getelementptr inbounds %class.GrGLSLVarying, %class.GrGLSLVarying* %7, i64 0, i32 2
  %110 = getelementptr inbounds %class.GrGLSLVarying, %class.GrGLSLVarying* %7, i64 0, i32 5
  store i32 31, i32* %107, align 8
  %111 = bitcast i32* %108 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %111, i8 0, i64 36, i1 false)
  %112 = load %class.GrGLSLVaryingHandler*, %class.GrGLSLVaryingHandler** %19, align 8
  call void @_ZN20GrGLSLVaryingHandler10addVaryingEPKcP13GrGLSLVaryingNS_13InterpolationE(%class.GrGLSLVaryingHandler* %112, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.8, i64 0, i64 0), %class.GrGLSLVarying* nonnull %7, i32 0) #5
  %113 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %114 = load i8*, i8** %109, align 8
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %113, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.9, i64 0, i64 0), i8* %114)
  %115 = load i8*, i8** %110, align 8
  %116 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 6
  %117 = call dereferenceable(8) %class.SkString* @_ZN8SkStringaSEPKc(%class.SkString* %116, i8* %115) #5
  call void @llvm.lifetime.end.p0i8(i64 40, i8* nonnull %106) #5
  br label %118

118:                                              ; preds = %100, %105
  %119 = getelementptr inbounds %class.GrStrokeShader, %class.GrStrokeShader* %13, i64 0, i32 1
  %120 = load i32, i32* %119, align 4
  %121 = icmp eq i32 %120, 1
  br i1 %121, label %122, label %131

122:                                              ; preds = %118
  %123 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %124 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %123, i64 0, i32 3, i32 0, i32 0, i64 120
  %125 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %123, i64 0, i32 14
  %126 = load i32, i32* %125, align 8
  %127 = bitcast i8* %124 to %class.SkString**
  %128 = load %class.SkString*, %class.SkString** %127, align 8
  %129 = sext i32 %126 to i64
  %130 = getelementptr inbounds %class.SkString, %class.SkString* %128, i64 %129
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %130, i64 -1, i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.10, i64 0, i64 0)) #5
  br label %143

131:                                              ; preds = %118
  %132 = bitcast i8** %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %132) #5
  store i8* inttoptr (i64 -6148914691236517206 to i8*), i8** %8, align 8
  %133 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 4
  %134 = load %class.GrGLSLUniformHandler*, %class.GrGLSLUniformHandler** %133, align 8
  %135 = bitcast %class.GrGLSLUniformHandler* %134 to i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)***
  %136 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)**, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*** %135, align 8
  %137 = getelementptr inbounds i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %136, i64 13
  %138 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %137, align 8
  %139 = call i32 %138(%class.GrGLSLUniformHandler* %134, %class.GrFragmentProcessor* null, i32 1, i32 21, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.11, i64 0, i64 0), i1 zeroext true, i32 0, i8** nonnull %8) #5
  %140 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 4, i32 0
  store i32 %139, i32* %140, align 4
  %141 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %142 = load i8*, i8** %8, align 8
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %141, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.12, i64 0, i64 0), i8* %142)
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %132) #5
  br label %143

143:                                              ; preds = %131, %122
  %144 = bitcast i8** %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %144) #5
  store i8* inttoptr (i64 -6148914691236517206 to i8*), i8** %9, align 8
  %145 = bitcast i8** %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %145) #5
  store i8* inttoptr (i64 -6148914691236517206 to i8*), i8** %10, align 8
  %146 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 4
  %147 = load %class.GrGLSLUniformHandler*, %class.GrGLSLUniformHandler** %146, align 8
  %148 = bitcast %class.GrGLSLUniformHandler* %147 to i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)***
  %149 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)**, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*** %148, align 8
  %150 = getelementptr inbounds i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %149, i64 13
  %151 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %150, align 8
  %152 = call i32 %151(%class.GrGLSLUniformHandler* %147, %class.GrFragmentProcessor* null, i32 1, i32 24, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.13, i64 0, i64 0), i1 zeroext true, i32 0, i8** nonnull %10) #5
  %153 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0
  %154 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 3, i32 0
  store i32 %152, i32* %154, align 8
  %155 = load %class.GrGLSLUniformHandler*, %class.GrGLSLUniformHandler** %146, align 8
  %156 = bitcast %class.GrGLSLUniformHandler* %155 to i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)***
  %157 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)**, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*** %156, align 8
  %158 = getelementptr inbounds i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %157, i64 13
  %159 = load i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)*, i32 (%class.GrGLSLUniformHandler*, %class.GrFragmentProcessor*, i32, i32, i8*, i1, i32, i8**)** %158, align 8
  %160 = call i32 %159(%class.GrGLSLUniformHandler* %155, %class.GrFragmentProcessor* null, i32 1, i32 22, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.14, i64 0, i64 0), i1 zeroext true, i32 0, i8** nonnull %9) #5
  %161 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 2, i32 0
  store i32 %160, i32* %161, align 4
  %162 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %163 = load i8*, i8** %10, align 8
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %162, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.15, i64 0, i64 0), i8* %163)
  %164 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %165 = load i8*, i8** %9, align 8
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %164, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.16, i64 0, i64 0), i8* %165)
  %166 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %167 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %166, i64 0, i32 3, i32 0, i32 0, i64 120
  %168 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %166, i64 0, i32 14
  %169 = load i32, i32* %168, align 8
  %170 = bitcast i8* %167 to %class.SkString**
  %171 = load %class.SkString*, %class.SkString** %170, align 8
  %172 = sext i32 %169 to i64
  %173 = getelementptr inbounds %class.SkString, %class.SkString* %171, i64 %172
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %173, i64 -1, i8* getelementptr inbounds ([333 x i8], [333 x i8]* @.str.17, i64 0, i64 0)) #5
  %174 = call i32 @_ZNK11SkStrokeRec8getStyleEv(%class.SkStrokeRec* %14) #5
  %175 = icmp eq i32 %174, 0
  br i1 %175, label %176, label %185

176:                                              ; preds = %143
  %177 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %178 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %177, i64 0, i32 3, i32 0, i32 0, i64 120
  %179 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %177, i64 0, i32 14
  %180 = load i32, i32* %179, align 8
  %181 = bitcast i8* %178 to %class.SkString**
  %182 = load %class.SkString*, %class.SkString** %181, align 8
  %183 = sext i32 %180 to i64
  %184 = getelementptr inbounds %class.SkString, %class.SkString* %182, i64 %183
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %184, i64 -1, i8* getelementptr inbounds ([93 x i8], [93 x i8]* @.str.18, i64 0, i64 0)) #5
  br label %185

185:                                              ; preds = %176, %143
  %186 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %187 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %186, i64 0, i32 3, i32 0, i32 0, i64 120
  %188 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %186, i64 0, i32 14
  %189 = load i32, i32* %188, align 8
  %190 = bitcast i8* %187 to %class.SkString**
  %191 = load %class.SkString*, %class.SkString** %190, align 8
  %192 = sext i32 %189 to i64
  %193 = getelementptr inbounds %class.SkString, %class.SkString* %191, i64 %192
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %193, i64 -1, i8* getelementptr inbounds ([914 x i8], [914 x i8]* @.str.19, i64 0, i64 0)) #5
  %194 = load i32, i32* %15, align 4
  %195 = lshr i32 %194, 16
  %196 = trunc i32 %195 to i8
  %197 = icmp eq i8 %196, 1
  br i1 %197, label %202, label %198

198:                                              ; preds = %185
  %199 = load i32, i32* %33, align 8
  %200 = and i32 %199, 2
  %201 = icmp eq i32 %200, 0
  br i1 %201, label %235, label %202

202:                                              ; preds = %198, %185
  %203 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %204 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %203, i64 0, i32 3, i32 0, i32 0, i64 120
  %205 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %203, i64 0, i32 14
  %206 = load i32, i32* %205, align 8
  %207 = bitcast i8* %204 to %class.SkString**
  %208 = load %class.SkString*, %class.SkString** %207, align 8
  %209 = sext i32 %206 to i64
  %210 = getelementptr inbounds %class.SkString, %class.SkString* %208, i64 %209
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %210, i64 -1, i8* getelementptr inbounds ([839 x i8], [839 x i8]* @.str.20, i64 0, i64 0)) #5
  %211 = load i32, i32* %119, align 4
  %212 = icmp eq i32 %211, 1
  br i1 %212, label %213, label %222

213:                                              ; preds = %202
  %214 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %215 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %214, i64 0, i32 3, i32 0, i32 0, i64 120
  %216 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %214, i64 0, i32 14
  %217 = load i32, i32* %216, align 8
  %218 = bitcast i8* %215 to %class.SkString**
  %219 = load %class.SkString*, %class.SkString** %218, align 8
  %220 = sext i32 %217 to i64
  %221 = getelementptr inbounds %class.SkString, %class.SkString* %219, i64 %220
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %221, i64 -1, i8* getelementptr inbounds ([346 x i8], [346 x i8]* @.str.21, i64 0, i64 0)) #5
  br label %222

222:                                              ; preds = %213, %202
  %223 = load i32, i32* %33, align 8
  %224 = and i32 %223, 2
  %225 = icmp eq i32 %224, 0
  br i1 %225, label %243, label %226

226:                                              ; preds = %222
  %227 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %228 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %227, i64 0, i32 3, i32 0, i32 0, i64 120
  %229 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %227, i64 0, i32 14
  %230 = load i32, i32* %229, align 8
  %231 = bitcast i8* %228 to %class.SkString**
  %232 = load %class.SkString*, %class.SkString** %231, align 8
  %233 = sext i32 %230 to i64
  %234 = getelementptr inbounds %class.SkString, %class.SkString* %232, i64 %233
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %234, i64 -1, i8* getelementptr inbounds ([314 x i8], [314 x i8]* @.str.22, i64 0, i64 0)) #5
  br label %243

235:                                              ; preds = %198
  %236 = icmp ult i8 %18, 3
  br i1 %236, label %238, label %237

237:                                              ; preds = %235
  call void @llvm.trap() #5
  unreachable

238:                                              ; preds = %235
  %239 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %240 = sext i8 %18 to i64
  %241 = getelementptr inbounds [3 x i32], [3 x i32]* @switch.table._ZN27GrStrokeInstancedShaderImpl10onEmitCodeERN23GrGLSLGeometryProcessor8EmitArgsEPNS0_8GrGPArgsE, i64 0, i64 %240
  %242 = load i32, i32* %241, align 4
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %239, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.23, i64 0, i64 0), i32 %242)
  br label %243

243:                                              ; preds = %222, %226, %238
  %244 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %245 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %244, i64 0, i32 3, i32 0, i32 0, i64 120
  %246 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %244, i64 0, i32 14
  %247 = load i32, i32* %246, align 8
  %248 = bitcast i8* %245 to %class.SkString**
  %249 = load %class.SkString*, %class.SkString** %248, align 8
  %250 = sext i32 %247 to i64
  %251 = getelementptr inbounds %class.SkString, %class.SkString* %249, i64 %250
  call void @_ZN8SkString6insertEmPKc(%class.SkString* %251, i64 -1, i8* getelementptr inbounds ([3726 x i8], [3726 x i8]* @.str.24, i64 0, i64 0)) #5
  %252 = icmp ne i8 %18, 0
  %253 = load i32, i32* %33, align 8
  %254 = and i32 %253, 2
  %255 = icmp eq i32 %254, 0
  %256 = and i1 %252, %255
  br i1 %256, label %261, label %257

257:                                              ; preds = %243
  %258 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %259 = icmp eq i32 %254, 0
  %260 = select i1 %259, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i64 0, i64 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.26, i64 0, i64 0)
  call void (%class.GrGLSLShaderBuilder*, i8*, ...) @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder* %258, i8* getelementptr inbounds ([232 x i8], [232 x i8]* @.str.25, i64 0, i64 0), i8* %260)
  br label %261

261:                                              ; preds = %243, %257
  %262 = load %class.GrGLSLShaderBuilder*, %class.GrGLSLShaderBuilder** %22, align 8
  %263 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %262, i64 0, i32 3, i32 0, i32 0, i64 120
  %264 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %262, i64 0, i32 14
  %265 = load i32, i32* %264, align 8
  %266 = bitcast i8* %263 to %class.SkString**
  %267 = load %class.SkString*, %class.SkString** %266, align 8
  %268 = sext i32 %265 to i64
  %269 = getelementptr inbounds %class.SkString, %class.SkString* %267, i64 %268
  %270 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::EmitArgs", %"struct.GrGLSLGeometryProcessor::EmitArgs"* %1, i64 0, i32 5
  %271 = load %class.GrShaderCaps*, %class.GrShaderCaps** %270, align 8
  call void @_ZNK18GrStrokeShaderImpl20emitTessellationCodeERK14GrStrokeShaderP8SkStringPN23GrGLSLGeometryProcessor8GrGPArgsERK12GrShaderCaps(%class.GrStrokeShaderImpl* %153, %class.GrStrokeShader* dereferenceable(272) %13, %class.SkString* %269, %"struct.GrGLSLGeometryProcessor::GrGPArgs"* %2, %class.GrShaderCaps* dereferenceable(144) %271) #5
  call void @_ZN18GrStrokeShaderImpl16emitFragmentCodeERK14GrStrokeShaderRKN23GrGLSLGeometryProcessor8EmitArgsE(%class.GrStrokeShaderImpl* %153, %class.GrStrokeShader* dereferenceable(272) %13, %"struct.GrGLSLGeometryProcessor::EmitArgs"* dereferenceable(88) %1) #5
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %145) #5
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %144) #5
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

declare void @_ZN20GrGLSLVaryingHandler14emitAttributesERK19GrGeometryProcessor(%class.GrGLSLVaryingHandler*, %class.GrGeometryProcessor* dereferenceable(80)) local_unnamed_addr #2

; Function Attrs: nounwind
declare void @_ZN8SkStringD1Ev(%class.SkString*) unnamed_addr #3

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZN19GrGLSLShaderBuilder11codeAppendfEPKcz(%class.GrGLSLShaderBuilder*, i8*, ...) local_unnamed_addr #0 comdat align 2 {
  %3 = alloca [1 x %struct.__va_list_tag], align 16
  %4 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %4) #5
  %5 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %3, i64 0, i64 0
  %6 = bitcast [1 x %struct.__va_list_tag]* %3 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %6, i8 -86, i64 24, i1 false)
  call void @llvm.va_start(i8* nonnull %4)
  %7 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %0, i64 0, i32 3, i32 0, i32 0, i64 120
  %8 = getelementptr inbounds %class.GrGLSLShaderBuilder, %class.GrGLSLShaderBuilder* %0, i64 0, i32 14
  %9 = load i32, i32* %8, align 8
  %10 = bitcast i8* %7 to %class.SkString**
  %11 = load %class.SkString*, %class.SkString** %10, align 8
  %12 = sext i32 %9 to i64
  %13 = getelementptr inbounds %class.SkString, %class.SkString* %11, i64 %12
  call void @_ZN8SkString12appendVAListEPKcP13__va_list_tag(%class.SkString* %13, i8* %1, %struct.__va_list_tag* nonnull %5) #5
  call void @llvm.va_end(i8* nonnull %4)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %4) #5
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #1

declare void @_ZN20GrGLSLVaryingHandler10addVaryingEPKcP13GrGLSLVaryingNS_13InterpolationE(%class.GrGLSLVaryingHandler*, i8*, %class.GrGLSLVarying*, i32) local_unnamed_addr #2

declare dereferenceable(8) %class.SkString* @_ZN8SkStringaSEPKc(%class.SkString*, i8*) local_unnamed_addr #2

declare void @_ZNK18GrStrokeShaderImpl20emitTessellationCodeERK14GrStrokeShaderP8SkStringPN23GrGLSLGeometryProcessor8GrGPArgsERK12GrShaderCaps(%class.GrStrokeShaderImpl*, %class.GrStrokeShader* dereferenceable(272), %class.SkString*, %"struct.GrGLSLGeometryProcessor::GrGPArgs"*, %class.GrShaderCaps* dereferenceable(144)) local_unnamed_addr #2

declare void @_ZN18GrStrokeShaderImpl16emitFragmentCodeERK14GrStrokeShaderRKN23GrGLSLGeometryProcessor8EmitArgsE(%class.GrStrokeShaderImpl*, %class.GrStrokeShader* dereferenceable(272), %"struct.GrGLSLGeometryProcessor::EmitArgs"* dereferenceable(88)) local_unnamed_addr #2

; Function Attrs: inlinehint nounwind ssp uwtable
define linkonce_odr hidden void @_ZN18GrStrokeShaderImplD2Ev(%class.GrStrokeShaderImpl*) unnamed_addr #4 comdat align 2 {
  %2 = getelementptr inbounds %class.GrStrokeShaderImpl, %class.GrStrokeShaderImpl* %0, i64 0, i32 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [8 x i8*] }, { [8 x i8*] }* @_ZTV18GrStrokeShaderImpl, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8
  %3 = getelementptr inbounds %class.GrStrokeShaderImpl, %class.GrStrokeShaderImpl* %0, i64 0, i32 6
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %3) #5
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [8 x i8*] }, { [8 x i8*] }* @_ZTV23GrGLSLGeometryProcessor, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8
  %4 = getelementptr inbounds %class.GrStrokeShaderImpl, %class.GrStrokeShaderImpl* %0, i64 0, i32 0, i32 1
  %5 = getelementptr inbounds %class.GrStrokeShaderImpl, %class.GrStrokeShaderImpl* %0, i64 0, i32 0, i32 1, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = and i64 %6, 4294967294
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %11, label %9

9:                                                ; preds = %1
  %10 = getelementptr inbounds %class.SkTArray, %class.SkTArray* %4, i64 0, i32 0
  br label %15

11:                                               ; preds = %15, %1
  %12 = phi i64 [ %6, %1 ], [ %20, %15 ]
  %13 = and i64 %12, 1
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %27, label %24

15:                                               ; preds = %15, %9
  %16 = phi i64 [ 0, %9 ], [ %19, %15 ]
  %17 = load %"struct.GrGLSLGeometryProcessor::TransformInfo"*, %"struct.GrGLSLGeometryProcessor::TransformInfo"** %10, align 8
  %18 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16
  tail call void @_ZN23GrGLSLGeometryProcessor13TransformInfoD2Ev(%"struct.GrGLSLGeometryProcessor::TransformInfo"* %18) #5
  %19 = add nuw nsw i64 %16, 1
  %20 = load i64, i64* %5, align 8
  %21 = lshr i64 %20, 1
  %22 = and i64 %21, 2147483647
  %23 = icmp ult i64 %19, %22
  br i1 %23, label %15, label %11

24:                                               ; preds = %11
  %25 = bitcast %class.SkTArray* %4 to i8**
  %26 = load i8*, i8** %25, align 8
  tail call void @_Z7sk_freePv(i8* %26) #5
  br label %27

27:                                               ; preds = %11, %24
  ret void
}

; Function Attrs: inlinehint nounwind ssp uwtable
define linkonce_odr hidden void @_ZN27GrStrokeInstancedShaderImplD0Ev(%class.GrStrokeInstancedShaderImpl*) unnamed_addr #4 comdat align 2 {
  %2 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [8 x i8*] }, { [8 x i8*] }* @_ZTV18GrStrokeShaderImpl, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8
  %3 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 6
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %3) #5
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [8 x i8*] }, { [8 x i8*] }* @_ZTV23GrGLSLGeometryProcessor, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8
  %4 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 0, i32 1
  %5 = getelementptr inbounds %class.GrStrokeInstancedShaderImpl, %class.GrStrokeInstancedShaderImpl* %0, i64 0, i32 0, i32 0, i32 1, i32 1
  %6 = load i64, i64* %5, align 8
  %7 = and i64 %6, 4294967294
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %11, label %9

9:                                                ; preds = %1
  %10 = getelementptr inbounds %class.SkTArray, %class.SkTArray* %4, i64 0, i32 0
  br label %15

11:                                               ; preds = %15, %1
  %12 = phi i64 [ %6, %1 ], [ %25, %15 ]
  %13 = and i64 %12, 1
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %32, label %29

15:                                               ; preds = %15, %9
  %16 = phi i64 [ 0, %9 ], [ %24, %15 ]
  %17 = load %"struct.GrGLSLGeometryProcessor::TransformInfo"*, %"struct.GrGLSLGeometryProcessor::TransformInfo"** %10, align 8
  %18 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16, i32 1, i32 5
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %18) #5
  %19 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16, i32 1, i32 4
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %19) #5
  %20 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16, i32 1, i32 3
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %20) #5
  %21 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16, i32 0, i32 5
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %21) #5
  %22 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16, i32 0, i32 4
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %22) #5
  %23 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %17, i64 %16, i32 0, i32 3
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %23) #5
  %24 = add nuw nsw i64 %16, 1
  %25 = load i64, i64* %5, align 8
  %26 = lshr i64 %25, 1
  %27 = and i64 %26, 2147483647
  %28 = icmp ult i64 %24, %27
  br i1 %28, label %15, label %11

29:                                               ; preds = %11
  %30 = bitcast %class.SkTArray* %4 to i8**
  %31 = load i8*, i8** %30, align 8
  tail call void @_Z7sk_freePv(i8* %31) #5
  br label %32

32:                                               ; preds = %11, %29
  %33 = bitcast %class.GrStrokeInstancedShaderImpl* %0 to i8*
  tail call void @_ZdlPv(i8* %33) #9
  ret void
}

declare void @_ZN18GrStrokeShaderImpl7setDataERK24GrGLSLProgramDataManagerRK12GrShaderCapsRK19GrGeometryProcessor(%class.GrStrokeShaderImpl*, %class.GrGLSLProgramDataManager* dereferenceable(8), %class.GrShaderCaps* dereferenceable(144), %class.GrGeometryProcessor* dereferenceable(80)) unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZNK23GrGLSLGeometryProcessor24getTessControlShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps(%class.SkString* noalias sret, %class.GrGLSLGeometryProcessor*, %class.GrGeometryProcessor* dereferenceable(80), i8*, %class.GrGLSLUniformHandler* dereferenceable(16), %class.GrShaderCaps* dereferenceable(144)) unnamed_addr #0 comdat align 2 {
  tail call void (i8*, i32, i8*, ...) @_Z16SkAbort_FileLinePKciS0_z(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.32, i64 0, i64 0), i32 139, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i64 0, i64 0)) #10
  unreachable
}

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZNK23GrGLSLGeometryProcessor27getTessEvaluationShaderGLSLERK19GrGeometryProcessorPKcRK20GrGLSLUniformHandlerRK12GrShaderCaps(%class.SkString* noalias sret, %class.GrGLSLGeometryProcessor*, %class.GrGeometryProcessor* dereferenceable(80), i8*, %class.GrGLSLUniformHandler* dereferenceable(16), %class.GrShaderCaps* dereferenceable(144)) unnamed_addr #0 comdat align 2 {
  tail call void (i8*, i32, i8*, ...) @_Z16SkAbort_FileLinePKciS0_z(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.32, i64 0, i64 0), i32 145, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i64 0, i64 0)) #10
  unreachable
}

declare void @_ZN8SkString7appendfEPKcz(%class.SkString*, i8*, ...) local_unnamed_addr #2

declare void @_ZN8SkString6insertEmPKc(%class.SkString*, i64, i8*) local_unnamed_addr #2

declare void @_ZN8SkStringC1Ev(%class.SkString*) unnamed_addr #2

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #5

declare void @_ZN8SkString12appendVAListEPKcP13__va_list_tag(%class.SkString*, i8*, %struct.__va_list_tag*) local_unnamed_addr #2

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #5

declare i32 @_ZNK11SkStrokeRec8getStyleEv(%class.SkStrokeRec*) local_unnamed_addr #2

; Function Attrs: cold noreturn nounwind
declare void @llvm.trap() #6

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZN23GrGLSLGeometryProcessorD2Ev(%class.GrGLSLGeometryProcessor*) unnamed_addr #0 comdat align 2 {
  %2 = getelementptr inbounds %class.GrGLSLGeometryProcessor, %class.GrGLSLGeometryProcessor* %0, i64 0, i32 0
  store i32 (...)** bitcast (i8** getelementptr inbounds ({ [8 x i8*] }, { [8 x i8*] }* @_ZTV23GrGLSLGeometryProcessor, i64 0, inrange i32 0, i64 2) to i32 (...)**), i32 (...)*** %2, align 8
  %3 = getelementptr inbounds %class.GrGLSLGeometryProcessor, %class.GrGLSLGeometryProcessor* %0, i64 0, i32 1
  %4 = getelementptr inbounds %class.GrGLSLGeometryProcessor, %class.GrGLSLGeometryProcessor* %0, i64 0, i32 1, i32 1
  %5 = load i64, i64* %4, align 8
  %6 = and i64 %5, 4294967294
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %10, label %8

8:                                                ; preds = %1
  %9 = getelementptr inbounds %class.SkTArray, %class.SkTArray* %3, i64 0, i32 0
  br label %14

10:                                               ; preds = %14, %1
  %11 = phi i64 [ %5, %1 ], [ %19, %14 ]
  %12 = and i64 %11, 1
  %13 = icmp eq i64 %12, 0
  br i1 %13, label %26, label %23

14:                                               ; preds = %14, %8
  %15 = phi i64 [ 0, %8 ], [ %18, %14 ]
  %16 = load %"struct.GrGLSLGeometryProcessor::TransformInfo"*, %"struct.GrGLSLGeometryProcessor::TransformInfo"** %9, align 8
  %17 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %16, i64 %15
  tail call void @_ZN23GrGLSLGeometryProcessor13TransformInfoD2Ev(%"struct.GrGLSLGeometryProcessor::TransformInfo"* %17) #5
  %18 = add nuw nsw i64 %15, 1
  %19 = load i64, i64* %4, align 8
  %20 = lshr i64 %19, 1
  %21 = and i64 %20, 2147483647
  %22 = icmp ult i64 %18, %21
  br i1 %22, label %14, label %10

23:                                               ; preds = %10
  %24 = bitcast %class.SkTArray* %3 to i8**
  %25 = load i8*, i8** %24, align 8
  tail call void @_Z7sk_freePv(i8* %25) #5
  br label %26

26:                                               ; preds = %10, %23
  ret void
}

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZN23GrGLSLGeometryProcessorD0Ev(%class.GrGLSLGeometryProcessor*) unnamed_addr #0 comdat align 2 {
  tail call void @llvm.trap() #10
  unreachable
}

declare void @__cxa_pure_virtual() unnamed_addr

; Function Attrs: inlinehint nounwind ssp uwtable
define linkonce_odr hidden void @_ZN23GrGLSLGeometryProcessor13TransformInfoD2Ev(%"struct.GrGLSLGeometryProcessor::TransformInfo"*) unnamed_addr #4 comdat align 2 {
  %2 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %0, i64 0, i32 1, i32 5
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %2) #5
  %3 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %0, i64 0, i32 1, i32 4
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %3) #5
  %4 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %0, i64 0, i32 1, i32 3
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %4) #5
  %5 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %0, i64 0, i32 0, i32 5
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %5) #5
  %6 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %0, i64 0, i32 0, i32 4
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %6) #5
  %7 = getelementptr inbounds %"struct.GrGLSLGeometryProcessor::TransformInfo", %"struct.GrGLSLGeometryProcessor::TransformInfo"* %0, i64 0, i32 0, i32 3
  tail call void @_ZN8SkStringD1Ev(%class.SkString* %7) #5
  ret void
}

declare void @_Z7sk_freePv(i8*) local_unnamed_addr #2

; Function Attrs: nobuiltin nounwind
declare void @_ZdlPv(i8*) local_unnamed_addr #7

; Function Attrs: noreturn
declare void @_Z16SkAbort_FileLinePKciS0_z(i8*, i32, i8*, ...) local_unnamed_addr #8

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { inlinehint nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { cold noreturn nounwind }
attributes #7 = { nobuiltin nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { builtin nounwind }
attributes #10 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!3}
!3 = distinct !{!3, !4, !"_ZN14GrWangsFormulaL7as_skslEv: argument 0"}
!4 = distinct !{!4, !"_ZN14GrWangsFormulaL7as_skslEv"}
