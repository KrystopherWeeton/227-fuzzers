; ModuleID = '../../third_party/libjxl/src/lib/jxl/ac_strategy.cc'
source_filename = "../../third_party/libjxl/src/lib/jxl/ac_strategy.cc"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"

%"struct.jxl::AcStrategy::CoeffOrderAndLut" = type { [175744 x i32], [175744 x i32] }
%"class.jxl::AcStrategyImage" = type { %"class.jxl::Plane", i8*, i64 }
%"class.jxl::Plane" = type { %"struct.jxl::PlaneBase" }
%"struct.jxl::PlaneBase" = type { i32, i32, i32, i32, i64, %"class.std::__1::unique_ptr" }
%"class.std::__1::unique_ptr" = type { %"class.std::__1::__compressed_pair" }
%"class.std::__1::__compressed_pair" = type { %"struct.std::__1::__compressed_pair_elem" }
%"struct.std::__1::__compressed_pair_elem" = type { i8* }

$_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut = comdat any

$_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut = comdat any

@_ZN3jxl10AcStrategy16CoeffOrderAndLut7kOffsetE = hidden local_unnamed_addr constant [28 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 8, i64 24, i64 26, i64 28, i64 32, i64 36, i64 44, i64 52, i64 53, i64 54, i64 55, i64 56, i64 57, i64 58, i64 122, i64 154, i64 186, i64 442, i64 570, i64 698, i64 1722, i64 2234, i64 2746], align 16
@.str = private unnamed_addr constant [23 x i8] c"%s:%d: JXL_ASSERT: %s\0A\00", align 1
@.str.1 = private unnamed_addr constant [52 x i8] c"../../third_party/libjxl/src/lib/jxl/ac_strategy.cc\00", align 1
@.str.2 = private unnamed_addr constant [101 x i8] c"(AcStrategy::CoeffOrderAndLut::kOffset[s + 1] - AcStrategy::CoeffOrderAndLut::kOffset[s]) == cx * cy\00", align 1
@_ZZN3jxl10AcStrategy10CoeffOrderEvE5order = internal unnamed_addr global %"struct.jxl::AcStrategy::CoeffOrderAndLut"* null, align 8
@_ZGVZN3jxl10AcStrategy10CoeffOrderEvE5order = internal global i64 0, align 8
@_ZN3jxl10AcStrategy15kMaxCoeffBlocksE = hidden local_unnamed_addr constant i64 32, align 8
@_ZN3jxl10AcStrategy12kMaxBlockDimE = hidden local_unnamed_addr constant i64 256, align 8
@_ZN3jxl10AcStrategy13kMaxCoeffAreaE = hidden local_unnamed_addr constant i64 65536, align 8
@_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut = linkonce_odr hidden local_unnamed_addr constant [27 x i8] c"\01\01\01\01\02\04\01\02\01\04\02\04\01\01\01\01\01\01\08\04\08\10\08\10 \10 ", comdat, align 16
@_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut = linkonce_odr hidden local_unnamed_addr constant [27 x i8] c"\01\01\01\01\02\04\02\01\04\01\04\02\01\01\01\01\01\01\08\08\04\10\10\08  \10", comdat, align 16

@_ZN3jxl10AcStrategy16CoeffOrderAndLutC1Ev = hidden unnamed_addr alias void (%"struct.jxl::AcStrategy::CoeffOrderAndLut"*), void (%"struct.jxl::AcStrategy::CoeffOrderAndLut"*)* @_ZN3jxl10AcStrategy16CoeffOrderAndLutC2Ev
@_ZN3jxl15AcStrategyImageC1Emm = hidden unnamed_addr alias void (%"class.jxl::AcStrategyImage"*, i64, i64), void (%"class.jxl::AcStrategyImage"*, i64, i64)* @_ZN3jxl15AcStrategyImageC2Emm

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN3jxl10AcStrategy16CoeffOrderAndLutC2Ev(%"struct.jxl::AcStrategy::CoeffOrderAndLut"* nocapture) unnamed_addr #0 align 2 {
  br label %5

2:                                                ; preds = %85
  %3 = icmp eq i64 %17, 27
  br i1 %3, label %4, label %5

4:                                                ; preds = %2
  ret void

5:                                                ; preds = %2, %1
  %6 = phi i64 [ 0, %1 ], [ %19, %2 ]
  %7 = phi i64 [ 0, %1 ], [ %17, %2 ]
  %8 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %7
  %9 = load i8, i8* %8, align 1
  %10 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut, i64 0, i64 %7
  %11 = load i8, i8* %10, align 1
  %12 = icmp ult i8 %11, %9
  %13 = select i1 %12, i8 %11, i8 %9
  %14 = zext i8 %13 to i64
  %15 = select i1 %12, i8 %9, i8 %11
  %16 = zext i8 %15 to i64
  %17 = add nuw nsw i64 %7, 1
  %18 = getelementptr inbounds [28 x i64], [28 x i64]* @_ZN3jxl10AcStrategy16CoeffOrderAndLut7kOffsetE, i64 0, i64 %17
  %19 = load i64, i64* %18, align 8
  %20 = sub i64 %19, %6
  %21 = mul nuw nsw i64 %16, %14
  %22 = icmp eq i64 %20, %21
  br i1 %22, label %26, label %23

23:                                               ; preds = %5
  %24 = tail call zeroext i1 (i8*, ...) @_ZN3jxl5DebugEPKcz(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.1, i64 0, i64 0), i32 42, i8* getelementptr inbounds ([101 x i8], [101 x i8]* @.str.2, i64 0, i64 0)) #5
  %25 = tail call zeroext i1 @_ZN3jxl5AbortEv() #7
  unreachable

26:                                               ; preds = %5
  %27 = shl i64 %6, 6
  %28 = getelementptr inbounds %"struct.jxl::AcStrategy::CoeffOrderAndLut", %"struct.jxl::AcStrategy::CoeffOrderAndLut"* %0, i64 0, i32 0, i64 %27
  %29 = getelementptr inbounds %"struct.jxl::AcStrategy::CoeffOrderAndLut", %"struct.jxl::AcStrategy::CoeffOrderAndLut"* %0, i64 0, i32 1, i64 %27
  %30 = udiv i8 %15, %13
  %31 = zext i8 %30 to i64
  %32 = add nsw i64 %31, -1
  %33 = tail call i64 @llvm.ctlz.i64(i64 %31, i1 true) #5, !range !2
  %34 = xor i64 %33, 63
  %35 = tail call i64 @llvm.ctpop.i64(i64 %31) #5, !range !2
  %36 = icmp ugt i64 %35, 1
  %37 = zext i1 %36 to i64
  %38 = add nuw nsw i64 %34, %37
  %39 = shl nuw nsw i64 %16, 3
  %40 = icmp eq i8 %15, 0
  br i1 %40, label %41, label %45

41:                                               ; preds = %51, %26
  %42 = phi i64 [ %20, %26 ], [ %82, %51 ]
  %43 = add nsw i64 %39, -1
  %44 = or i64 %39, 1
  br label %88

45:                                               ; preds = %26, %51
  %46 = phi i64 [ %54, %51 ], [ 1, %26 ]
  %47 = phi i64 [ %52, %51 ], [ 0, %26 ]
  %48 = phi i64 [ %82, %51 ], [ %20, %26 ]
  %49 = and i64 %47, 1
  %50 = icmp eq i64 %49, 0
  br label %55

51:                                               ; preds = %81
  %52 = add nuw nsw i64 %47, 1
  %53 = icmp ult i64 %52, %39
  %54 = add nuw nsw i64 %46, 1
  br i1 %53, label %45, label %41

55:                                               ; preds = %45, %81
  %56 = phi i64 [ 0, %45 ], [ %83, %81 ]
  %57 = phi i64 [ %48, %45 ], [ %82, %81 ]
  %58 = sub nsw i64 %47, %56
  %59 = select i1 %50, i64 %56, i64 %58
  %60 = select i1 %50, i64 %58, i64 %56
  %61 = and i64 %60, %32
  %62 = icmp eq i64 %61, 0
  br i1 %62, label %63, label %81

63:                                               ; preds = %55
  %64 = lshr i64 %60, %38
  %65 = icmp ult i64 %59, %16
  %66 = icmp ult i64 %64, %14
  %67 = and i1 %65, %66
  %68 = mul i64 %64, %16
  %69 = add i64 %68, %59
  %70 = and i1 %65, %66
  %71 = xor i1 %70, true
  %72 = zext i1 %71 to i64
  %73 = add i64 %57, %72
  %74 = select i1 %67, i64 %69, i64 %57
  %75 = trunc i64 %74 to i32
  %76 = shl i64 %68, 3
  %77 = add i64 %76, %59
  %78 = getelementptr inbounds i32, i32* %29, i64 %77
  store i32 %75, i32* %78, align 4
  %79 = trunc i64 %77 to i32
  %80 = getelementptr inbounds i32, i32* %28, i64 %74
  store i32 %79, i32* %80, align 4
  br label %81

81:                                               ; preds = %55, %63
  %82 = phi i64 [ %73, %63 ], [ %57, %55 ]
  %83 = add nuw nsw i64 %56, 1
  %84 = icmp eq i64 %83, %46
  br i1 %84, label %51, label %55

85:                                               ; preds = %115
  %86 = add i64 %89, -1
  %87 = icmp eq i64 %86, 0
  br i1 %87, label %2, label %88

88:                                               ; preds = %41, %85
  %89 = phi i64 [ %43, %41 ], [ %86, %85 ]
  %90 = phi i64 [ %39, %41 ], [ %89, %85 ]
  %91 = phi i64 [ %42, %41 ], [ %116, %85 ]
  %92 = add i64 %90, -2
  %93 = sub i64 %44, %90
  %94 = and i64 %92, 1
  %95 = icmp eq i64 %94, 0
  br label %96

96:                                               ; preds = %88, %115
  %97 = phi i64 [ 0, %88 ], [ %117, %115 ]
  %98 = phi i64 [ %91, %88 ], [ %116, %115 ]
  %99 = add i64 %93, %97
  %100 = xor i64 %97, -1
  %101 = add i64 %39, %100
  %102 = select i1 %95, i64 %101, i64 %99
  %103 = and i64 %102, %32
  %104 = icmp eq i64 %103, 0
  br i1 %104, label %105, label %115

105:                                              ; preds = %96
  %106 = select i1 %95, i64 %99, i64 %101
  %107 = lshr i64 %102, %38
  %108 = add i64 %98, 1
  %109 = trunc i64 %98 to i32
  %110 = mul i64 %39, %107
  %111 = add i64 %110, %106
  %112 = getelementptr inbounds i32, i32* %29, i64 %111
  store i32 %109, i32* %112, align 4
  %113 = trunc i64 %111 to i32
  %114 = getelementptr inbounds i32, i32* %28, i64 %98
  store i32 %113, i32* %114, align 4
  br label %115

115:                                              ; preds = %96, %105
  %116 = phi i64 [ %108, %105 ], [ %98, %96 ]
  %117 = add i64 %97, 1
  %118 = icmp ult i64 %92, %117
  br i1 %118, label %85, label %96
}

declare zeroext i1 @_ZN3jxl5DebugEPKcz(i8*, ...) local_unnamed_addr #1

; Function Attrs: noreturn
declare zeroext i1 @_ZN3jxl5AbortEv() local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define hidden %"struct.jxl::AcStrategy::CoeffOrderAndLut"* @_ZN3jxl10AcStrategy10CoeffOrderEv() local_unnamed_addr #0 align 2 {
  %1 = load atomic i8, i8* bitcast (i64* @_ZGVZN3jxl10AcStrategy10CoeffOrderEvE5order to i8*) acquire, align 8
  %2 = icmp eq i8 %1, 0
  br i1 %2, label %3, label %9, !prof !3

3:                                                ; preds = %0
  %4 = tail call i32 @__cxa_guard_acquire(i64* nonnull @_ZGVZN3jxl10AcStrategy10CoeffOrderEvE5order) #5
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %9, label %6

6:                                                ; preds = %3
  %7 = tail call i8* @_Znwm(i64 1405952) #8
  %8 = bitcast i8* %7 to %"struct.jxl::AcStrategy::CoeffOrderAndLut"*
  tail call void @_ZN3jxl10AcStrategy16CoeffOrderAndLutC2Ev(%"struct.jxl::AcStrategy::CoeffOrderAndLut"* nonnull %8)
  store i8* %7, i8** bitcast (%"struct.jxl::AcStrategy::CoeffOrderAndLut"** @_ZZN3jxl10AcStrategy10CoeffOrderEvE5order to i8**), align 8
  tail call void @__cxa_guard_release(i64* nonnull @_ZGVZN3jxl10AcStrategy10CoeffOrderEvE5order) #5
  br label %9

9:                                                ; preds = %3, %6, %0
  %10 = load %"struct.jxl::AcStrategy::CoeffOrderAndLut"*, %"struct.jxl::AcStrategy::CoeffOrderAndLut"** @_ZZN3jxl10AcStrategy10CoeffOrderEvE5order, align 8
  ret %"struct.jxl::AcStrategy::CoeffOrderAndLut"* %10
}

; Function Attrs: nofree nounwind
declare i32 @__cxa_guard_acquire(i64*) local_unnamed_addr #3

; Function Attrs: nobuiltin nofree
declare noalias nonnull i8* @_Znwm(i64) local_unnamed_addr #4

; Function Attrs: nofree nounwind
declare void @__cxa_guard_release(i64*) local_unnamed_addr #3

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN3jxl15AcStrategyImageC2Emm(%"class.jxl::AcStrategyImage"*, i64, i64) unnamed_addr #0 align 2 {
  %4 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0
  tail call void @_ZN3jxl9PlaneBaseC2Emmm(%"struct.jxl::PlaneBase"* %4, i64 %1, i64 %2, i64 1) #5
  %5 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %6 = load i8*, i8** %5, align 8
  %7 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0, i32 4
  %8 = ptrtoint i8* %6 to i64
  %9 = and i64 %8, 63
  %10 = icmp eq i64 %9, 0
  tail call void @llvm.assume(i1 %10) #5
  %11 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 1
  store i8* %6, i8** %11, align 8
  %12 = load i64, i64* %7, align 8
  %13 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 2
  store i64 %12, i64* %13, align 8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define hidden i64 @_ZNK3jxl15AcStrategyImage11CountBlocksENS_10AcStrategy4TypeE(%"class.jxl::AcStrategyImage"* nocapture readonly, i32) local_unnamed_addr #0 align 2 {
  %3 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0, i32 1
  %4 = load i32, i32* %3, align 4
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %24, label %6

6:                                                ; preds = %2
  %7 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %8 = load i8*, i8** %7, align 8
  %9 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0, i32 4
  %10 = load i64, i64* %9, align 8
  %11 = getelementptr inbounds %"class.jxl::AcStrategyImage", %"class.jxl::AcStrategyImage"* %0, i64 0, i32 0, i32 0, i32 0
  %12 = load i32, i32* %11, align 8
  %13 = icmp eq i32 %12, 0
  %14 = shl i32 %1, 1
  %15 = and i32 %14, 510
  %16 = or i32 %15, 1
  %17 = zext i32 %4 to i64
  %18 = zext i32 %12 to i64
  %19 = add nsw i64 %18, -1
  %20 = and i64 %18, 3
  %21 = icmp ult i64 %19, 3
  %22 = sub nsw i64 %18, %20
  %23 = icmp eq i64 %20, 0
  br label %26

24:                                               ; preds = %52, %2
  %25 = phi i64 [ 0, %2 ], [ %53, %52 ]
  ret i64 %25

26:                                               ; preds = %6, %52
  %27 = phi i64 [ 0, %6 ], [ %54, %52 ]
  %28 = phi i64 [ 0, %6 ], [ %53, %52 ]
  %29 = mul i64 %10, %27
  %30 = getelementptr inbounds i8, i8* %8, i64 %29
  %31 = ptrtoint i8* %30 to i64
  %32 = and i64 %31, 63
  %33 = icmp eq i64 %32, 0
  tail call void @llvm.assume(i1 %33) #5
  br i1 %13, label %52, label %34

34:                                               ; preds = %26
  br i1 %21, label %35, label %56

35:                                               ; preds = %56, %34
  %36 = phi i64 [ undef, %34 ], [ %86, %56 ]
  %37 = phi i64 [ 0, %34 ], [ %87, %56 ]
  %38 = phi i64 [ %28, %34 ], [ %86, %56 ]
  br i1 %23, label %52, label %39

39:                                               ; preds = %35, %39
  %40 = phi i64 [ %49, %39 ], [ %37, %35 ]
  %41 = phi i64 [ %48, %39 ], [ %38, %35 ]
  %42 = phi i64 [ %50, %39 ], [ %20, %35 ]
  %43 = getelementptr inbounds i8, i8* %30, i64 %40
  %44 = load i8, i8* %43, align 1
  %45 = zext i8 %44 to i32
  %46 = icmp eq i32 %16, %45
  %47 = zext i1 %46 to i64
  %48 = add i64 %41, %47
  %49 = add nuw nsw i64 %40, 1
  %50 = add i64 %42, -1
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %52, label %39, !llvm.loop !4

52:                                               ; preds = %35, %39, %26
  %53 = phi i64 [ %28, %26 ], [ %36, %35 ], [ %48, %39 ]
  %54 = add nuw nsw i64 %27, 1
  %55 = icmp ult i64 %54, %17
  br i1 %55, label %26, label %24

56:                                               ; preds = %34, %56
  %57 = phi i64 [ %87, %56 ], [ 0, %34 ]
  %58 = phi i64 [ %86, %56 ], [ %28, %34 ]
  %59 = phi i64 [ %88, %56 ], [ %22, %34 ]
  %60 = getelementptr inbounds i8, i8* %30, i64 %57
  %61 = load i8, i8* %60, align 4
  %62 = zext i8 %61 to i32
  %63 = icmp eq i32 %16, %62
  %64 = zext i1 %63 to i64
  %65 = add i64 %58, %64
  %66 = or i64 %57, 1
  %67 = getelementptr inbounds i8, i8* %30, i64 %66
  %68 = load i8, i8* %67, align 1
  %69 = zext i8 %68 to i32
  %70 = icmp eq i32 %16, %69
  %71 = zext i1 %70 to i64
  %72 = add i64 %65, %71
  %73 = or i64 %57, 2
  %74 = getelementptr inbounds i8, i8* %30, i64 %73
  %75 = load i8, i8* %74, align 2
  %76 = zext i8 %75 to i32
  %77 = icmp eq i32 %16, %76
  %78 = zext i1 %77 to i64
  %79 = add i64 %72, %78
  %80 = or i64 %57, 3
  %81 = getelementptr inbounds i8, i8* %30, i64 %80
  %82 = load i8, i8* %81, align 1
  %83 = zext i8 %82 to i32
  %84 = icmp eq i32 %16, %83
  %85 = zext i1 %84 to i64
  %86 = add i64 %79, %85
  %87 = add nuw nsw i64 %57, 4
  %88 = add i64 %59, -4
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %35, label %56
}

; Function Attrs: nounwind
declare void @llvm.assume(i1) #5

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #6

declare void @_ZN3jxl9PlaneBaseC2Emmm(%"struct.jxl::PlaneBase"*, i64, i64, i64) unnamed_addr #1

; Function Attrs: nounwind readnone speculatable
declare i64 @llvm.ctpop.i64(i64) #6

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nofree nounwind }
attributes #4 = { nobuiltin nofree "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { nounwind readnone speculatable }
attributes #7 = { noreturn nounwind }
attributes #8 = { builtin nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{i64 0, i64 65}
!3 = !{!"branch_weights", i32 1, i32 1048575}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.unroll.disable"}
