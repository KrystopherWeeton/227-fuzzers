; ModuleID = '../../third_party/boringssl/src/crypto/cipher_extra/e_aesccm.c'
source_filename = "../../third_party/boringssl/src/crypto/cipher_extra/e_aesccm.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.evp_aead_st = type { i8, i8, i8, i8, i32, i32 (%struct.evp_aead_ctx_st*, i8*, i64, i64)*, i32 (%struct.evp_aead_ctx_st*, i8*, i64, i64, i32)*, void (%struct.evp_aead_ctx_st*)*, i32 (%struct.evp_aead_ctx_st*, i8*, i64*, i64, i8*, i64, i8*, i64, i8*, i64)*, i32 (%struct.evp_aead_ctx_st*, i8*, i8*, i64*, i64, i8*, i64, i8*, i64, i8*, i64, i8*, i64)*, i32 (%struct.evp_aead_ctx_st*, i8*, i8*, i64, i8*, i64, i8*, i64, i8*, i64)*, i32 (%struct.evp_aead_ctx_st*, i8**, i64*)*, i64 (%struct.evp_aead_ctx_st*, i64, i64)* }
%struct.evp_aead_ctx_st = type { %struct.evp_aead_st*, %union.evp_aead_ctx_st_state, i8 }
%union.evp_aead_ctx_st_state = type { i64, [576 x i8] }
%struct.aes_key_st = type { [60 x i32], i32 }
%struct.gcm128_key_st = type { %struct.u128, [16 x %struct.u128], void (i64*, %struct.u128*)*, void (i64*, %struct.u128*, i8*, i64)*, void (i8*, i8*, %struct.aes_key_st*)*, i8 }
%struct.u128 = type { i64, i64 }
%struct.ccm128_state = type { %union.anon.0, %union.anon.0 }
%union.anon.0 = type { [2 x i64] }
%struct.ccm128_context = type { void (i8*, i8*, %struct.aes_key_st*)*, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)*, i32, i32 }

@aead_aes_128_ccm_bluetooth = internal constant %struct.evp_aead_st { i8 16, i8 13, i8 4, i8 4, i32 0, i32 (%struct.evp_aead_ctx_st*, i8*, i64, i64)* @aead_aes_ccm_bluetooth_init, i32 (%struct.evp_aead_ctx_st*, i8*, i64, i64, i32)* null, void (%struct.evp_aead_ctx_st*)* @aead_aes_ccm_cleanup, i32 (%struct.evp_aead_ctx_st*, i8*, i64*, i64, i8*, i64, i8*, i64, i8*, i64)* null, i32 (%struct.evp_aead_ctx_st*, i8*, i8*, i64*, i64, i8*, i64, i8*, i64, i8*, i64, i8*, i64)* @aead_aes_ccm_seal_scatter, i32 (%struct.evp_aead_ctx_st*, i8*, i8*, i64, i8*, i64, i8*, i64, i8*, i64)* @aead_aes_ccm_open_gather, i32 (%struct.evp_aead_ctx_st*, i8**, i64*)* null, i64 (%struct.evp_aead_ctx_st*, i64, i64)* null }, align 8
@aead_aes_128_ccm_bluetooth_8 = internal constant %struct.evp_aead_st { i8 16, i8 13, i8 8, i8 8, i32 0, i32 (%struct.evp_aead_ctx_st*, i8*, i64, i64)* @aead_aes_ccm_bluetooth_8_init, i32 (%struct.evp_aead_ctx_st*, i8*, i64, i64, i32)* null, void (%struct.evp_aead_ctx_st*)* @aead_aes_ccm_cleanup, i32 (%struct.evp_aead_ctx_st*, i8*, i64*, i64, i8*, i64, i8*, i64, i8*, i64)* null, i32 (%struct.evp_aead_ctx_st*, i8*, i8*, i64*, i64, i8*, i64, i8*, i64, i8*, i64, i8*, i64)* @aead_aes_ccm_seal_scatter, i32 (%struct.evp_aead_ctx_st*, i8*, i8*, i64, i8*, i64, i8*, i64, i8*, i64)* @aead_aes_ccm_open_gather, i32 (%struct.evp_aead_ctx_st*, i8**, i64*)* null, i64 (%struct.evp_aead_ctx_st*, i64, i64)* null }, align 8
@.str = private unnamed_addr constant [63 x i8] c"../../third_party/boringssl/src/crypto/cipher_extra/e_aesccm.c\00", align 1

; Function Attrs: norecurse nounwind readnone ssp uwtable
define hidden nonnull %struct.evp_aead_st* @EVP_aead_aes_128_ccm_bluetooth() local_unnamed_addr #0 {
  ret %struct.evp_aead_st* @aead_aes_128_ccm_bluetooth
}

; Function Attrs: norecurse nounwind readnone ssp uwtable
define hidden nonnull %struct.evp_aead_st* @EVP_aead_aes_128_ccm_bluetooth_8() local_unnamed_addr #0 {
  ret %struct.evp_aead_st* @aead_aes_128_ccm_bluetooth_8
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @aead_aes_ccm_bluetooth_init(%struct.evp_aead_ctx_st*, i8*, i64, i64) #1 {
  %5 = alloca void (i8*, i8*, %struct.aes_key_st*)*, align 8
  %6 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 0
  %7 = load %struct.evp_aead_st*, %struct.evp_aead_st** %6, align 8
  %8 = tail call i64 @EVP_AEAD_key_length(%struct.evp_aead_st* %7) #4
  %9 = icmp eq i64 %8, %2
  br i1 %9, label %11, label %10

10:                                               ; preds = %4
  tail call void @ERR_put_error(i32 30, i32 0, i32 102, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 295) #4
  br label %31

11:                                               ; preds = %4
  %12 = and i64 %3, -5
  %13 = icmp eq i64 %12, 0
  br i1 %13, label %15, label %14

14:                                               ; preds = %11
  tail call void @ERR_put_error(i32 30, i32 0, i32 116, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 304) #4
  br label %31

15:                                               ; preds = %11
  %16 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1
  %17 = bitcast void (i8*, i8*, %struct.aes_key_st*)** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %17) #4
  store void (i8*, i8*, %struct.aes_key_st*)* inttoptr (i64 -6148914691236517206 to void (i8*, i8*, %struct.aes_key_st*)*), void (i8*, i8*, %struct.aes_key_st*)** %5, align 8
  %18 = bitcast %union.evp_aead_ctx_st_state* %16 to %struct.aes_key_st*
  %19 = call void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* @aes_ctr_set_key(%struct.aes_key_st* %18, %struct.gcm128_key_st* null, void (i8*, i8*, %struct.aes_key_st*)** nonnull %5, i8* %1, i64 %2) #4
  %20 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 2
  store i8 4, i8* %20, align 8
  %21 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 240
  %22 = bitcast void (i8*, i8*, %struct.aes_key_st*)** %5 to i64*
  %23 = load i64, i64* %22, align 8
  %24 = bitcast i8* %21 to i64*
  store i64 %23, i64* %24, align 8
  %25 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 248
  %26 = bitcast i8* %25 to void (i8*, i8*, i64, %struct.aes_key_st*, i8*)**
  store void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* %19, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)** %26, align 8
  %27 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 256
  %28 = bitcast i8* %27 to i32*
  store i32 4, i32* %28, align 8
  %29 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 260
  %30 = bitcast i8* %29 to i32*
  store i32 2, i32* %30, align 4
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %17) #4
  br label %31

31:                                               ; preds = %10, %14, %15
  %32 = phi i32 [ 0, %10 ], [ 0, %14 ], [ 1, %15 ]
  ret i32 %32
}

; Function Attrs: norecurse nounwind readnone ssp uwtable
define internal void @aead_aes_ccm_cleanup(%struct.evp_aead_ctx_st* nocapture) #0 {
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @aead_aes_ccm_seal_scatter(%struct.evp_aead_ctx_st*, i8*, i8* nocapture, i64* nocapture, i64, i8* nocapture readonly, i64, i8*, i64, i8* nocapture readnone, i64, i8* nocapture readonly, i64) #1 {
  %14 = alloca [16 x i8], align 16
  %15 = alloca i32, align 4
  %16 = alloca %struct.ccm128_state, align 8
  %17 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1
  %18 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 240
  %19 = bitcast i8* %18 to %struct.ccm128_context*
  %20 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 260
  %21 = bitcast i8* %20 to i32*
  %22 = load i32, i32* %21, align 4
  %23 = icmp ugt i32 %22, 7
  br i1 %23, label %30, label %24

24:                                               ; preds = %13
  %25 = shl i32 %22, 3
  %26 = zext i32 %25 to i64
  %27 = lshr i64 %8, %26
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %30, label %29

29:                                               ; preds = %24
  tail call void @ERR_put_error(i32 30, i32 0, i32 117, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 332) #4
  br label %173

30:                                               ; preds = %24, %13
  %31 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 2
  %32 = load i8, i8* %31, align 8
  %33 = zext i8 %32 to i64
  %34 = icmp ugt i64 %33, %4
  br i1 %34, label %35, label %36

35:                                               ; preds = %30
  tail call void @ERR_put_error(i32 30, i32 0, i32 103, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 337) #4
  br label %173

36:                                               ; preds = %30
  %37 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 0
  %38 = load %struct.evp_aead_st*, %struct.evp_aead_st** %37, align 8
  %39 = tail call i64 @EVP_AEAD_nonce_length(%struct.evp_aead_st* %38) #4
  %40 = icmp eq i64 %39, %6
  br i1 %40, label %42, label %41

41:                                               ; preds = %36
  tail call void @ERR_put_error(i32 30, i32 0, i32 111, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 342) #4
  br label %173

42:                                               ; preds = %36
  %43 = bitcast %union.evp_aead_ctx_st_state* %17 to %struct.aes_key_st*
  %44 = load i8, i8* %31, align 8
  %45 = bitcast %struct.ccm128_state* %16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %45) #4
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %45, i8 -86, i64 32, i1 false) #4
  %46 = call fastcc i32 @ccm128_init_state(%struct.ccm128_context* %19, %struct.ccm128_state* nonnull %16, %struct.aes_key_st* %43, i8* %5, i64 %6, i8* %11, i64 %12, i64 %8) #4
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %169, label %48

48:                                               ; preds = %42
  %49 = zext i8 %44 to i64
  %50 = call fastcc i32 @ccm128_compute_mac(%struct.ccm128_context* %19, %struct.ccm128_state* nonnull %16, %struct.aes_key_st* %43, i8* %2, i64 %49, i8* %7, i64 %8) #4
  %51 = icmp eq i32 %50, 0
  br i1 %51, label %169, label %52

52:                                               ; preds = %48
  %53 = load i32, i32* %21, align 4
  %54 = icmp eq i32 %53, 0
  %55 = bitcast %struct.ccm128_state* %16 to [16 x i8]*
  br i1 %54, label %141, label %56

56:                                               ; preds = %52
  %57 = zext i32 %53 to i64
  %58 = icmp ult i32 %53, 32
  %59 = add nsw i64 %57, -1
  %60 = icmp ugt i64 %59, 15
  %61 = or i1 %58, %60
  br i1 %61, label %62, label %80

62:                                               ; preds = %139, %56
  %63 = phi i64 [ 0, %56 ], [ %81, %139 ]
  %64 = xor i64 %63, -1
  %65 = add nsw i64 %64, %57
  %66 = and i64 %57, 3
  %67 = icmp eq i64 %66, 0
  br i1 %67, label %77, label %68

68:                                               ; preds = %62, %68
  %69 = phi i64 [ %74, %68 ], [ %63, %62 ]
  %70 = phi i64 [ %75, %68 ], [ %66, %62 ]
  %71 = sub nsw i64 15, %69
  %72 = and i64 %71, 4294967295
  %73 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %72
  store i8 0, i8* %73, align 1
  %74 = add nuw nsw i64 %69, 1
  %75 = add i64 %70, -1
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %77, label %68, !llvm.loop !2

77:                                               ; preds = %68, %62
  %78 = phi i64 [ %63, %62 ], [ %74, %68 ]
  %79 = icmp ult i64 %65, 3
  br i1 %79, label %141, label %149

80:                                               ; preds = %56
  %81 = and i64 %57, 4294967264
  %82 = add nsw i64 %81, -32
  %83 = lshr exact i64 %82, 5
  %84 = add nuw nsw i64 %83, 1
  %85 = and i64 %84, 3
  %86 = icmp ult i64 %82, 96
  br i1 %86, label %123, label %87

87:                                               ; preds = %80
  %88 = sub nsw i64 %84, %85
  br label %89

89:                                               ; preds = %89, %87
  %90 = phi i64 [ 0, %87 ], [ %120, %89 ]
  %91 = phi i64 [ %88, %87 ], [ %121, %89 ]
  %92 = sub nsw i64 15, %90
  %93 = and i64 %92, 4294967183
  %94 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %93
  %95 = getelementptr inbounds i8, i8* %94, i64 -15
  %96 = bitcast i8* %95 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %96, align 1
  %97 = getelementptr inbounds i8, i8* %94, i64 -31
  %98 = bitcast i8* %97 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %98, align 1
  %99 = sub i64 4294967279, %90
  %100 = and i64 %99, 4294967279
  %101 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %100
  %102 = getelementptr inbounds i8, i8* %101, i64 -15
  %103 = bitcast i8* %102 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %103, align 1
  %104 = getelementptr inbounds i8, i8* %101, i64 -31
  %105 = bitcast i8* %104 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %105, align 1
  %106 = sub i64 4294967247, %90
  %107 = and i64 %106, 4294967247
  %108 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %107
  %109 = getelementptr inbounds i8, i8* %108, i64 -15
  %110 = bitcast i8* %109 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %110, align 1
  %111 = getelementptr inbounds i8, i8* %108, i64 -31
  %112 = bitcast i8* %111 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %112, align 1
  %113 = sub i64 4294967215, %90
  %114 = and i64 %113, 4294967215
  %115 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %114
  %116 = getelementptr inbounds i8, i8* %115, i64 -15
  %117 = bitcast i8* %116 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %117, align 1
  %118 = getelementptr inbounds i8, i8* %115, i64 -31
  %119 = bitcast i8* %118 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %119, align 1
  %120 = add i64 %90, 128
  %121 = add i64 %91, -4
  %122 = icmp eq i64 %121, 0
  br i1 %122, label %123, label %89, !llvm.loop !4

123:                                              ; preds = %89, %80
  %124 = phi i64 [ 0, %80 ], [ %120, %89 ]
  %125 = icmp eq i64 %85, 0
  br i1 %125, label %139, label %126

126:                                              ; preds = %123, %126
  %127 = phi i64 [ %136, %126 ], [ %124, %123 ]
  %128 = phi i64 [ %137, %126 ], [ %85, %123 ]
  %129 = sub nsw i64 15, %127
  %130 = and i64 %129, 4294967279
  %131 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %130
  %132 = getelementptr inbounds i8, i8* %131, i64 -15
  %133 = bitcast i8* %132 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %133, align 1
  %134 = getelementptr inbounds i8, i8* %131, i64 -31
  %135 = bitcast i8* %134 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %135, align 1
  %136 = add i64 %127, 32
  %137 = add i64 %128, -1
  %138 = icmp eq i64 %137, 0
  br i1 %138, label %139, label %126, !llvm.loop !6

139:                                              ; preds = %126, %123
  %140 = icmp eq i64 %81, %57
  br i1 %140, label %141, label %62

141:                                              ; preds = %77, %149, %139, %52
  %142 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 15
  store i8 1, i8* %142, align 1
  %143 = getelementptr inbounds [16 x i8], [16 x i8]* %14, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %143) #4
  %144 = bitcast i32* %15 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %143, i8 -86, i64 16, i1 false) #4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %144) #4
  store i32 0, i32* %15, align 4
  %145 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 248
  %146 = bitcast i8* %145 to void (i8*, i8*, i64, %struct.aes_key_st*, i8*)**
  %147 = load void (i8*, i8*, i64, %struct.aes_key_st*, i8*)*, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)** %146, align 8
  %148 = icmp eq void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* %147, null
  br i1 %148, label %166, label %165

149:                                              ; preds = %77, %149
  %150 = phi i64 [ %163, %149 ], [ %78, %77 ]
  %151 = sub nsw i64 15, %150
  %152 = and i64 %151, 4294967295
  %153 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %152
  store i8 0, i8* %153, align 1
  %154 = sub i64 14, %150
  %155 = and i64 %154, 4294967295
  %156 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %155
  store i8 0, i8* %156, align 1
  %157 = sub i64 13, %150
  %158 = and i64 %157, 4294967295
  %159 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %158
  store i8 0, i8* %159, align 1
  %160 = sub i64 12, %150
  %161 = and i64 %160, 4294967295
  %162 = getelementptr inbounds [16 x i8], [16 x i8]* %55, i64 0, i64 %161
  store i8 0, i8* %162, align 1
  %163 = add nuw nsw i64 %150, 4
  %164 = icmp eq i64 %163, %57
  br i1 %164, label %141, label %149, !llvm.loop !7

165:                                              ; preds = %141
  call void @CRYPTO_ctr128_encrypt_ctr32(i8* %7, i8* %1, i64 %8, %struct.aes_key_st* %43, i8* nonnull %45, i8* nonnull %143, i32* nonnull %15, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* nonnull %147) #4
  br label %170

166:                                              ; preds = %141
  %167 = bitcast i8* %18 to void (i8*, i8*, %struct.aes_key_st*)**
  %168 = load void (i8*, i8*, %struct.aes_key_st*)*, void (i8*, i8*, %struct.aes_key_st*)** %167, align 8
  call void @CRYPTO_ctr128_encrypt(i8* %7, i8* %1, i64 %8, %struct.aes_key_st* %43, i8* nonnull %45, i8* nonnull %143, i32* nonnull %15, void (i8*, i8*, %struct.aes_key_st*)* %168) #4
  br label %170

169:                                              ; preds = %48, %42
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %45) #4
  call void @ERR_put_error(i32 30, i32 0, i32 117, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 349) #4
  br label %173

170:                                              ; preds = %166, %165
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %144) #4
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %143) #4
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %45) #4
  %171 = load i8, i8* %31, align 8
  %172 = zext i8 %171 to i64
  store i64 %172, i64* %3, align 8
  br label %173

173:                                              ; preds = %170, %169, %41, %35, %29
  %174 = phi i32 [ 0, %29 ], [ 0, %35 ], [ 0, %41 ], [ 1, %170 ], [ 0, %169 ]
  ret i32 %174
}

; Function Attrs: nounwind ssp uwtable
define internal i32 @aead_aes_ccm_open_gather(%struct.evp_aead_ctx_st*, i8*, i8* nocapture readonly, i64, i8*, i64, i8*, i64, i8* nocapture readonly, i64) #1 {
  %11 = alloca [16 x i8], align 16
  %12 = alloca i32, align 4
  %13 = alloca %struct.ccm128_state, align 8
  %14 = alloca [16 x i8], align 16
  %15 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1
  %16 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 240
  %17 = bitcast i8* %16 to %struct.ccm128_context*
  %18 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 260
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19, align 4
  %21 = icmp ugt i32 %20, 7
  br i1 %21, label %28, label %22

22:                                               ; preds = %10
  %23 = shl i32 %20, 3
  %24 = zext i32 %23 to i64
  %25 = lshr i64 %5, %24
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %28, label %27

27:                                               ; preds = %22
  tail call void @ERR_put_error(i32 30, i32 0, i32 117, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 366) #4
  br label %176

28:                                               ; preds = %22, %10
  %29 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 0
  %30 = load %struct.evp_aead_st*, %struct.evp_aead_st** %29, align 8
  %31 = tail call i64 @EVP_AEAD_nonce_length(%struct.evp_aead_st* %30) #4
  %32 = icmp eq i64 %31, %3
  br i1 %32, label %34, label %33

33:                                               ; preds = %28
  tail call void @ERR_put_error(i32 30, i32 0, i32 111, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 371) #4
  br label %176

34:                                               ; preds = %28
  %35 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 2
  %36 = load i8, i8* %35, align 8
  %37 = zext i8 %36 to i64
  %38 = icmp eq i64 %37, %7
  br i1 %38, label %40, label %39

39:                                               ; preds = %34
  tail call void @ERR_put_error(i32 30, i32 0, i32 101, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 376) #4
  br label %176

40:                                               ; preds = %34
  %41 = getelementptr inbounds [16 x i8], [16 x i8]* %14, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %41) #4
  %42 = bitcast %union.evp_aead_ctx_st_state* %15 to %struct.aes_key_st*
  %43 = bitcast %struct.ccm128_state* %13 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %41, i8 -86, i64 16, i1 false)
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %43) #4
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %43, i8 -86, i64 32, i1 false) #4
  %44 = call fastcc i32 @ccm128_init_state(%struct.ccm128_context* %17, %struct.ccm128_state* nonnull %13, %struct.aes_key_st* %42, i8* %2, i64 %3, i8* %8, i64 %9, i64 %5) #4
  %45 = icmp eq i32 %44, 0
  br i1 %45, label %46, label %47

46:                                               ; preds = %40
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %43) #4
  br label %167

47:                                               ; preds = %40
  %48 = load i32, i32* %19, align 4
  %49 = icmp eq i32 %48, 0
  %50 = bitcast %struct.ccm128_state* %13 to [16 x i8]*
  br i1 %49, label %136, label %51

51:                                               ; preds = %47
  %52 = zext i32 %48 to i64
  %53 = icmp ult i32 %48, 32
  %54 = add nsw i64 %52, -1
  %55 = icmp ugt i64 %54, 15
  %56 = or i1 %53, %55
  br i1 %56, label %57, label %75

57:                                               ; preds = %134, %51
  %58 = phi i64 [ 0, %51 ], [ %76, %134 ]
  %59 = xor i64 %58, -1
  %60 = add nsw i64 %59, %52
  %61 = and i64 %52, 3
  %62 = icmp eq i64 %61, 0
  br i1 %62, label %72, label %63

63:                                               ; preds = %57, %63
  %64 = phi i64 [ %69, %63 ], [ %58, %57 ]
  %65 = phi i64 [ %70, %63 ], [ %61, %57 ]
  %66 = sub nsw i64 15, %64
  %67 = and i64 %66, 4294967295
  %68 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %67
  store i8 0, i8* %68, align 1
  %69 = add nuw nsw i64 %64, 1
  %70 = add i64 %65, -1
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %72, label %63, !llvm.loop !8

72:                                               ; preds = %63, %57
  %73 = phi i64 [ %58, %57 ], [ %69, %63 ]
  %74 = icmp ult i64 %60, 3
  br i1 %74, label %136, label %144

75:                                               ; preds = %51
  %76 = and i64 %52, 4294967264
  %77 = add nsw i64 %76, -32
  %78 = lshr exact i64 %77, 5
  %79 = add nuw nsw i64 %78, 1
  %80 = and i64 %79, 3
  %81 = icmp ult i64 %77, 96
  br i1 %81, label %118, label %82

82:                                               ; preds = %75
  %83 = sub nsw i64 %79, %80
  br label %84

84:                                               ; preds = %84, %82
  %85 = phi i64 [ 0, %82 ], [ %115, %84 ]
  %86 = phi i64 [ %83, %82 ], [ %116, %84 ]
  %87 = sub nsw i64 15, %85
  %88 = and i64 %87, 4294967183
  %89 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %88
  %90 = getelementptr inbounds i8, i8* %89, i64 -15
  %91 = bitcast i8* %90 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %91, align 1
  %92 = getelementptr inbounds i8, i8* %89, i64 -31
  %93 = bitcast i8* %92 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %93, align 1
  %94 = sub i64 4294967279, %85
  %95 = and i64 %94, 4294967279
  %96 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %95
  %97 = getelementptr inbounds i8, i8* %96, i64 -15
  %98 = bitcast i8* %97 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %98, align 1
  %99 = getelementptr inbounds i8, i8* %96, i64 -31
  %100 = bitcast i8* %99 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %100, align 1
  %101 = sub i64 4294967247, %85
  %102 = and i64 %101, 4294967247
  %103 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %102
  %104 = getelementptr inbounds i8, i8* %103, i64 -15
  %105 = bitcast i8* %104 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %105, align 1
  %106 = getelementptr inbounds i8, i8* %103, i64 -31
  %107 = bitcast i8* %106 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %107, align 1
  %108 = sub i64 4294967215, %85
  %109 = and i64 %108, 4294967215
  %110 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %109
  %111 = getelementptr inbounds i8, i8* %110, i64 -15
  %112 = bitcast i8* %111 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %112, align 1
  %113 = getelementptr inbounds i8, i8* %110, i64 -31
  %114 = bitcast i8* %113 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %114, align 1
  %115 = add i64 %85, 128
  %116 = add i64 %86, -4
  %117 = icmp eq i64 %116, 0
  br i1 %117, label %118, label %84, !llvm.loop !9

118:                                              ; preds = %84, %75
  %119 = phi i64 [ 0, %75 ], [ %115, %84 ]
  %120 = icmp eq i64 %80, 0
  br i1 %120, label %134, label %121

121:                                              ; preds = %118, %121
  %122 = phi i64 [ %131, %121 ], [ %119, %118 ]
  %123 = phi i64 [ %132, %121 ], [ %80, %118 ]
  %124 = sub nsw i64 15, %122
  %125 = and i64 %124, 4294967279
  %126 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %125
  %127 = getelementptr inbounds i8, i8* %126, i64 -15
  %128 = bitcast i8* %127 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %128, align 1
  %129 = getelementptr inbounds i8, i8* %126, i64 -31
  %130 = bitcast i8* %129 to <16 x i8>*
  store <16 x i8> zeroinitializer, <16 x i8>* %130, align 1
  %131 = add i64 %122, 32
  %132 = add i64 %123, -1
  %133 = icmp eq i64 %132, 0
  br i1 %133, label %134, label %121, !llvm.loop !10

134:                                              ; preds = %121, %118
  %135 = icmp eq i64 %76, %52
  br i1 %135, label %136, label %57

136:                                              ; preds = %72, %144, %134, %47
  %137 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 15
  store i8 1, i8* %137, align 1
  %138 = getelementptr inbounds [16 x i8], [16 x i8]* %11, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %138) #4
  %139 = bitcast i32* %12 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %138, i8 -86, i64 16, i1 false) #4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %139) #4
  store i32 0, i32* %12, align 4
  %140 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 248
  %141 = bitcast i8* %140 to void (i8*, i8*, i64, %struct.aes_key_st*, i8*)**
  %142 = load void (i8*, i8*, i64, %struct.aes_key_st*, i8*)*, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)** %141, align 8
  %143 = icmp eq void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* %142, null
  br i1 %143, label %161, label %160

144:                                              ; preds = %72, %144
  %145 = phi i64 [ %158, %144 ], [ %73, %72 ]
  %146 = sub nsw i64 15, %145
  %147 = and i64 %146, 4294967295
  %148 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %147
  store i8 0, i8* %148, align 1
  %149 = sub i64 14, %145
  %150 = and i64 %149, 4294967295
  %151 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %150
  store i8 0, i8* %151, align 1
  %152 = sub i64 13, %145
  %153 = and i64 %152, 4294967295
  %154 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %153
  store i8 0, i8* %154, align 1
  %155 = sub i64 12, %145
  %156 = and i64 %155, 4294967295
  %157 = getelementptr inbounds [16 x i8], [16 x i8]* %50, i64 0, i64 %156
  store i8 0, i8* %157, align 1
  %158 = add nuw nsw i64 %145, 4
  %159 = icmp eq i64 %158, %52
  br i1 %159, label %136, label %144, !llvm.loop !11

160:                                              ; preds = %136
  call void @CRYPTO_ctr128_encrypt_ctr32(i8* %4, i8* %1, i64 %5, %struct.aes_key_st* %42, i8* nonnull %43, i8* nonnull %138, i32* nonnull %12, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* nonnull %142) #4
  br label %164

161:                                              ; preds = %136
  %162 = bitcast i8* %16 to void (i8*, i8*, %struct.aes_key_st*)**
  %163 = load void (i8*, i8*, %struct.aes_key_st*)*, void (i8*, i8*, %struct.aes_key_st*)** %162, align 8
  call void @CRYPTO_ctr128_encrypt(i8* %4, i8* %1, i64 %5, %struct.aes_key_st* %42, i8* nonnull %43, i8* nonnull %138, i32* nonnull %12, void (i8*, i8*, %struct.aes_key_st*)* %163) #4
  br label %164

164:                                              ; preds = %160, %161
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %139) #4
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %138) #4
  %165 = call fastcc i32 @ccm128_compute_mac(%struct.ccm128_context* %17, %struct.ccm128_state* nonnull %13, %struct.aes_key_st* %42, i8* nonnull %41, i64 %7, i8* %1, i64 %5) #4
  %166 = icmp eq i32 %165, 0
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %43) #4
  br i1 %166, label %167, label %168

167:                                              ; preds = %46, %164
  call void @ERR_put_error(i32 30, i32 0, i32 117, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 385) #4
  br label %174

168:                                              ; preds = %164
  %169 = load i8, i8* %35, align 8
  %170 = zext i8 %169 to i64
  %171 = call i32 @CRYPTO_memcmp(i8* nonnull %41, i8* %6, i64 %170) #4
  %172 = icmp eq i32 %171, 0
  br i1 %172, label %174, label %173

173:                                              ; preds = %168
  call void @ERR_put_error(i32 30, i32 0, i32 101, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 390) #4
  br label %174

174:                                              ; preds = %168, %173, %167
  %175 = phi i32 [ 0, %173 ], [ 0, %167 ], [ 1, %168 ]
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %41) #4
  br label %176

176:                                              ; preds = %174, %39, %33, %27
  %177 = phi i32 [ 0, %27 ], [ 0, %33 ], [ 0, %39 ], [ %175, %174 ]
  ret i32 %177
}

declare i64 @EVP_AEAD_key_length(%struct.evp_aead_st*) local_unnamed_addr #2

declare void @ERR_put_error(i32, i32, i32, i8*, i32) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #3

declare void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* @aes_ctr_set_key(%struct.aes_key_st*, %struct.gcm128_key_st*, void (i8*, i8*, %struct.aes_key_st*)**, i8*, i64) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #3

declare i64 @EVP_AEAD_nonce_length(%struct.evp_aead_st*) local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define internal fastcc i32 @ccm128_init_state(%struct.ccm128_context* nocapture readonly, %struct.ccm128_state*, %struct.aes_key_st*, i8* nocapture readonly, i64, i8* nocapture readonly, i64, i64) unnamed_addr #1 {
  %9 = getelementptr inbounds %struct.ccm128_context, %struct.ccm128_context* %0, i64 0, i32 0
  %10 = load void (i8*, i8*, %struct.aes_key_st*)*, void (i8*, i8*, %struct.aes_key_st*)** %9, align 8
  %11 = getelementptr inbounds %struct.ccm128_context, %struct.ccm128_context* %0, i64 0, i32 2
  %12 = load i32, i32* %11, align 8
  %13 = getelementptr inbounds %struct.ccm128_context, %struct.ccm128_context* %0, i64 0, i32 3
  %14 = load i32, i32* %13, align 4
  %15 = icmp ugt i32 %14, 7
  br i1 %15, label %21, label %16

16:                                               ; preds = %8
  %17 = shl i32 %14, 3
  %18 = zext i32 %17 to i64
  %19 = lshr i64 %7, %18
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %21, label %352

21:                                               ; preds = %16, %8
  %22 = sub i32 15, %14
  %23 = zext i32 %22 to i64
  %24 = icmp eq i64 %23, %4
  br i1 %24, label %25, label %352

25:                                               ; preds = %21
  %26 = bitcast %struct.ccm128_state* %1 to i8*
  %27 = getelementptr inbounds i8, i8* %26, i64 1
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %27, i8 0, i64 31, i1 false) #4
  %28 = add i32 %14, 255
  %29 = add i32 %12, 62
  %30 = lshr i32 %29, 1
  %31 = shl i32 %30, 3
  %32 = or i32 %31, %28
  %33 = trunc i32 %32 to i8
  %34 = bitcast %struct.ccm128_state* %1 to [16 x i8]*
  %35 = icmp ne i64 %6, 0
  %36 = or i8 %33, 64
  %37 = select i1 %35, i8 %36, i8 %33
  store i8 %37, i8* %26, align 8
  %38 = icmp eq i64 %4, 0
  br i1 %38, label %41, label %39

39:                                               ; preds = %25
  %40 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 1
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %40, i8* align 1 %3, i64 %4, i1 false) #4
  br label %41

41:                                               ; preds = %25, %39
  %42 = icmp eq i32 %14, 0
  br i1 %42, label %122, label %43

43:                                               ; preds = %41
  %44 = zext i32 %14 to i64
  %45 = icmp ult i32 %14, 8
  %46 = add nsw i64 %44, -1
  %47 = icmp ugt i64 %46, 15
  %48 = or i1 %45, %47
  br i1 %48, label %49, label %64

49:                                               ; preds = %120, %43
  %50 = phi i64 [ 0, %43 ], [ %65, %120 ]
  %51 = xor i64 %50, -1
  %52 = and i64 %44, 1
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %60, label %54

54:                                               ; preds = %49
  %55 = trunc i64 %7 to i8
  %56 = sub nsw i64 15, %50
  %57 = and i64 %56, 4294967295
  %58 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 %57
  store i8 %55, i8* %58, align 1
  %59 = or i64 %50, 1
  br label %60

60:                                               ; preds = %49, %54
  %61 = phi i64 [ %50, %49 ], [ %59, %54 ]
  %62 = sub nsw i64 0, %44
  %63 = icmp eq i64 %51, %62
  br i1 %63, label %122, label %126

64:                                               ; preds = %43
  %65 = and i64 %44, 4294967288
  %66 = insertelement <8 x i64> undef, i64 %7, i32 0
  %67 = shufflevector <8 x i64> %66, <8 x i64> undef, <8 x i32> zeroinitializer
  %68 = add nsw i64 %65, -8
  %69 = lshr exact i64 %68, 3
  %70 = add nuw nsw i64 %69, 1
  %71 = and i64 %70, 1
  %72 = icmp eq i64 %68, 0
  br i1 %72, label %109, label %73

73:                                               ; preds = %64
  %74 = sub nuw nsw i64 %70, %71
  br label %75

75:                                               ; preds = %75, %73
  %76 = phi i64 [ 0, %73 ], [ %100, %75 ]
  %77 = phi <8 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7>, %73 ], [ %101, %75 ]
  %78 = phi i64 [ %74, %73 ], [ %102, %75 ]
  %79 = shl <8 x i64> %77, <i64 3, i64 3, i64 3, i64 3, i64 3, i64 3, i64 3, i64 3>
  %80 = and <8 x i64> %79, <i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288>
  %81 = lshr <8 x i64> %67, %80
  %82 = trunc <8 x i64> %81 to <8 x i8>
  %83 = sub nsw i64 15, %76
  %84 = and i64 %83, 4294967295
  %85 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 %84
  %86 = shufflevector <8 x i8> %82, <8 x i8> undef, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>
  %87 = getelementptr inbounds i8, i8* %85, i64 -7
  %88 = bitcast i8* %87 to <8 x i8>*
  store <8 x i8> %86, <8 x i8>* %88, align 1
  %89 = shl <8 x i64> %77, <i64 3, i64 3, i64 3, i64 3, i64 3, i64 3, i64 3, i64 3>
  %90 = add <8 x i64> %89, <i64 64, i64 64, i64 64, i64 64, i64 64, i64 64, i64 64, i64 64>
  %91 = and <8 x i64> %90, <i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288>
  %92 = lshr <8 x i64> %67, %91
  %93 = trunc <8 x i64> %92 to <8 x i8>
  %94 = sub i64 7, %76
  %95 = and i64 %94, 4294967287
  %96 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 %95
  %97 = shufflevector <8 x i8> %93, <8 x i8> undef, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>
  %98 = getelementptr inbounds i8, i8* %96, i64 -7
  %99 = bitcast i8* %98 to <8 x i8>*
  store <8 x i8> %97, <8 x i8>* %99, align 1
  %100 = add i64 %76, 16
  %101 = add <8 x i64> %77, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %102 = add i64 %78, -2
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %104, label %75, !llvm.loop !12

104:                                              ; preds = %75
  %105 = shl <8 x i64> %101, <i64 3, i64 3, i64 3, i64 3, i64 3, i64 3, i64 3, i64 3>
  %106 = and <8 x i64> %105, <i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288, i64 4294967288>
  %107 = and i64 %76, 4294967280
  %108 = xor i64 %107, 4294967295
  br label %109

109:                                              ; preds = %104, %64
  %110 = phi i64 [ 15, %64 ], [ %108, %104 ]
  %111 = phi <8 x i64> [ <i64 0, i64 8, i64 16, i64 24, i64 32, i64 40, i64 48, i64 56>, %64 ], [ %106, %104 ]
  %112 = icmp eq i64 %71, 0
  br i1 %112, label %120, label %113

113:                                              ; preds = %109
  %114 = lshr <8 x i64> %67, %111
  %115 = trunc <8 x i64> %114 to <8 x i8>
  %116 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 %110
  %117 = shufflevector <8 x i8> %115, <8 x i8> undef, <8 x i32> <i32 7, i32 6, i32 5, i32 4, i32 3, i32 2, i32 1, i32 0>
  %118 = getelementptr inbounds i8, i8* %116, i64 -7
  %119 = bitcast i8* %118 to <8 x i8>*
  store <8 x i8> %117, <8 x i8>* %119, align 1
  br label %120

120:                                              ; preds = %109, %113
  %121 = icmp eq i64 %65, %44
  br i1 %121, label %122, label %49

122:                                              ; preds = %60, %126, %120, %41
  %123 = getelementptr inbounds %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1
  %124 = bitcast %union.anon.0* %123 to [16 x i8]*
  %125 = bitcast %union.anon.0* %123 to i8*
  tail call void %10(i8* %26, i8* %125, %struct.aes_key_st* %2) #4
  br i1 %35, label %145, label %338

126:                                              ; preds = %60, %126
  %127 = phi i64 [ %143, %126 ], [ %61, %60 ]
  %128 = shl i64 %127, 3
  %129 = and i64 %128, 4294967288
  %130 = lshr i64 %7, %129
  %131 = trunc i64 %130 to i8
  %132 = sub nsw i64 15, %127
  %133 = and i64 %132, 4294967295
  %134 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 %133
  store i8 %131, i8* %134, align 1
  %135 = shl i64 %127, 3
  %136 = add i64 %135, 8
  %137 = and i64 %136, 4294967288
  %138 = lshr i64 %7, %137
  %139 = trunc i64 %138 to i8
  %140 = sub i64 14, %127
  %141 = and i64 %140, 4294967295
  %142 = getelementptr inbounds [16 x i8], [16 x i8]* %34, i64 0, i64 %141
  store i8 %139, i8* %142, align 1
  %143 = add nuw nsw i64 %127, 2
  %144 = icmp eq i64 %143, %44
  br i1 %144, label %122, label %126, !llvm.loop !13

145:                                              ; preds = %122
  %146 = icmp ult i64 %6, 65280
  br i1 %146, label %147, label %152

147:                                              ; preds = %145
  %148 = lshr i64 %6, 8
  %149 = trunc i64 %148 to i8
  %150 = load i8, i8* %125, align 8
  %151 = xor i8 %150, %149
  store i8 %151, i8* %125, align 8
  br label %213

152:                                              ; preds = %145
  %153 = icmp ult i64 %6, 4294967296
  %154 = load i8, i8* %125, align 8
  %155 = xor i8 %154, -1
  store i8 %155, i8* %125, align 8
  %156 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 1
  %157 = load i8, i8* %156, align 1
  br i1 %153, label %158, label %175

158:                                              ; preds = %152
  %159 = xor i8 %157, -2
  store i8 %159, i8* %156, align 1
  %160 = lshr i64 %6, 24
  %161 = trunc i64 %160 to i8
  %162 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 2
  %163 = load i8, i8* %162, align 2
  %164 = xor i8 %163, %161
  store i8 %164, i8* %162, align 2
  %165 = lshr i64 %6, 16
  %166 = trunc i64 %165 to i8
  %167 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 3
  %168 = load i8, i8* %167, align 1
  %169 = xor i8 %168, %166
  store i8 %169, i8* %167, align 1
  %170 = lshr i64 %6, 8
  %171 = trunc i64 %170 to i8
  %172 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 4
  %173 = load i8, i8* %172, align 4
  %174 = xor i8 %173, %171
  store i8 %174, i8* %172, align 4
  br label %213

175:                                              ; preds = %152
  %176 = xor i8 %157, -1
  store i8 %176, i8* %156, align 1
  %177 = lshr i64 %6, 56
  %178 = trunc i64 %177 to i8
  %179 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 2
  %180 = load i8, i8* %179, align 2
  %181 = xor i8 %180, %178
  store i8 %181, i8* %179, align 2
  %182 = lshr i64 %6, 48
  %183 = trunc i64 %182 to i8
  %184 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 3
  %185 = load i8, i8* %184, align 1
  %186 = xor i8 %185, %183
  store i8 %186, i8* %184, align 1
  %187 = lshr i64 %6, 40
  %188 = trunc i64 %187 to i8
  %189 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 4
  %190 = load i8, i8* %189, align 4
  %191 = xor i8 %190, %188
  store i8 %191, i8* %189, align 4
  %192 = lshr i64 %6, 32
  %193 = trunc i64 %192 to i8
  %194 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 5
  %195 = load i8, i8* %194, align 1
  %196 = xor i8 %195, %193
  store i8 %196, i8* %194, align 1
  %197 = lshr i64 %6, 24
  %198 = trunc i64 %197 to i8
  %199 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 6
  %200 = load i8, i8* %199, align 2
  %201 = xor i8 %200, %198
  store i8 %201, i8* %199, align 2
  %202 = lshr i64 %6, 16
  %203 = trunc i64 %202 to i8
  %204 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 7
  %205 = load i8, i8* %204, align 1
  %206 = xor i8 %205, %203
  store i8 %206, i8* %204, align 1
  %207 = lshr i64 %6, 8
  %208 = trunc i64 %207 to i8
  %209 = getelementptr inbounds %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1, i32 0, i64 1
  %210 = bitcast i64* %209 to i8*
  %211 = load i8, i8* %210, align 8
  %212 = xor i8 %211, %208
  store i8 %212, i8* %210, align 8
  br label %213

213:                                              ; preds = %158, %175, %147
  %214 = phi i64 [ 5, %158 ], [ 9, %175 ], [ 1, %147 ]
  %215 = phi i64 [ 6, %158 ], [ 10, %175 ], [ 2, %147 ]
  %216 = trunc i64 %6 to i8
  %217 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 %214
  %218 = load i8, i8* %217, align 1
  %219 = xor i8 %218, %216
  store i8 %219, i8* %217, align 1
  %220 = getelementptr %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1, i32 0, i64 0
  %221 = bitcast i64* %220 to i8*
  %222 = getelementptr %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1, i32 0, i64 0
  %223 = bitcast i64* %222 to i8*
  %224 = getelementptr i8, i8* %223, i64 1
  br label %225

225:                                              ; preds = %333, %213
  %226 = phi i8* [ %5, %213 ], [ %334, %333 ]
  %227 = phi i64 [ %6, %213 ], [ %335, %333 ]
  %228 = phi i64 [ 1, %213 ], [ %337, %333 ]
  %229 = phi i64 [ %215, %213 ], [ 0, %333 ]
  %230 = icmp eq i64 %227, 0
  br i1 %230, label %231, label %233

231:                                              ; preds = %225
  tail call void %10(i8* %125, i8* %125, %struct.aes_key_st* %2) #4
  %232 = add i64 %228, 1
  br label %338

233:                                              ; preds = %225
  %234 = and i64 %229, 4294967295
  %235 = add i64 %227, -1
  %236 = sub nsw i64 15, %229
  %237 = icmp ult i64 %235, %236
  %238 = select i1 %237, i64 %235, i64 %236
  %239 = add i64 %238, 1
  %240 = icmp ult i64 %239, 16
  br i1 %240, label %315, label %241

241:                                              ; preds = %233
  %242 = getelementptr i8, i8* %221, i64 %229
  %243 = add i64 %227, -1
  %244 = sub nsw i64 15, %229
  %245 = icmp ult i64 %243, %244
  %246 = select i1 %245, i64 %243, i64 %244
  %247 = add i64 %229, %246
  %248 = getelementptr i8, i8* %224, i64 %247
  %249 = getelementptr i8, i8* %226, i64 1
  %250 = getelementptr i8, i8* %249, i64 %246
  %251 = icmp ult i8* %242, %250
  %252 = icmp ult i8* %226, %248
  %253 = and i1 %251, %252
  br i1 %253, label %315, label %254

254:                                              ; preds = %241
  %255 = and i64 %239, -16
  %256 = add i64 %234, %255
  %257 = sub i64 %227, %255
  %258 = getelementptr i8, i8* %226, i64 %255
  %259 = add i64 %227, -15
  %260 = add i64 %255, -16
  %261 = lshr exact i64 %260, 4
  %262 = add nuw nsw i64 %261, 1
  %263 = and i64 %262, 1
  %264 = icmp eq i64 %260, 0
  br i1 %264, label %296, label %265

265:                                              ; preds = %254
  %266 = sub nuw nsw i64 %262, %263
  br label %267

267:                                              ; preds = %267, %265
  %268 = phi i64 [ 0, %265 ], [ %290, %267 ]
  %269 = phi i64 [ %259, %265 ], [ %291, %267 ]
  %270 = phi i64 [ %266, %265 ], [ %292, %267 ]
  %271 = add i64 %234, %268
  %272 = getelementptr i8, i8* %226, i64 %268
  %273 = bitcast i8* %272 to <16 x i8>*
  %274 = load <16 x i8>, <16 x i8>* %273, align 1, !alias.scope !14
  %275 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 %271
  %276 = bitcast i8* %275 to <16 x i8>*
  %277 = load <16 x i8>, <16 x i8>* %276, align 1, !alias.scope !17, !noalias !14
  %278 = xor <16 x i8> %277, %274
  %279 = bitcast i8* %275 to <16 x i8>*
  store <16 x i8> %278, <16 x i8>* %279, align 1, !alias.scope !17, !noalias !14
  %280 = or i64 %268, 16
  %281 = add i64 %234, %280
  %282 = getelementptr i8, i8* %226, i64 %280
  %283 = bitcast i8* %282 to <16 x i8>*
  %284 = load <16 x i8>, <16 x i8>* %283, align 1, !alias.scope !14
  %285 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 %281
  %286 = bitcast i8* %285 to <16 x i8>*
  %287 = load <16 x i8>, <16 x i8>* %286, align 1, !alias.scope !17, !noalias !14
  %288 = xor <16 x i8> %287, %284
  %289 = bitcast i8* %285 to <16 x i8>*
  store <16 x i8> %288, <16 x i8>* %289, align 1, !alias.scope !17, !noalias !14
  %290 = add i64 %268, 32
  %291 = add i64 %269, -32
  %292 = add i64 %270, -2
  %293 = icmp eq i64 %292, 0
  br i1 %293, label %294, label %267, !llvm.loop !19

294:                                              ; preds = %267
  %295 = add i64 %269, -16
  br label %296

296:                                              ; preds = %294, %254
  %297 = phi i64 [ undef, %254 ], [ %295, %294 ]
  %298 = phi i64 [ 0, %254 ], [ %290, %294 ]
  %299 = phi i64 [ %259, %254 ], [ %291, %294 ]
  %300 = icmp eq i64 %263, 0
  br i1 %300, label %311, label %301

301:                                              ; preds = %296
  %302 = add i64 %234, %298
  %303 = getelementptr i8, i8* %226, i64 %298
  %304 = bitcast i8* %303 to <16 x i8>*
  %305 = load <16 x i8>, <16 x i8>* %304, align 1, !alias.scope !14
  %306 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 %302
  %307 = bitcast i8* %306 to <16 x i8>*
  %308 = load <16 x i8>, <16 x i8>* %307, align 1, !alias.scope !17, !noalias !14
  %309 = xor <16 x i8> %308, %305
  %310 = bitcast i8* %306 to <16 x i8>*
  store <16 x i8> %309, <16 x i8>* %310, align 1, !alias.scope !17, !noalias !14
  br label %311

311:                                              ; preds = %296, %301
  %312 = phi i64 [ %297, %296 ], [ %299, %301 ]
  %313 = icmp eq i64 %239, %255
  %314 = icmp ne i64 %312, 1
  br i1 %313, label %333, label %315

315:                                              ; preds = %311, %241, %233
  %316 = phi i64 [ %234, %241 ], [ %234, %233 ], [ %256, %311 ]
  %317 = phi i64 [ %227, %241 ], [ %227, %233 ], [ %257, %311 ]
  %318 = phi i8* [ %226, %241 ], [ %226, %233 ], [ %258, %311 ]
  br label %319

319:                                              ; preds = %315, %319
  %320 = phi i64 [ %329, %319 ], [ %316, %315 ]
  %321 = phi i64 [ %328, %319 ], [ %317, %315 ]
  %322 = phi i8* [ %327, %319 ], [ %318, %315 ]
  %323 = load i8, i8* %322, align 1
  %324 = getelementptr inbounds [16 x i8], [16 x i8]* %124, i64 0, i64 %320
  %325 = load i8, i8* %324, align 1
  %326 = xor i8 %325, %323
  store i8 %326, i8* %324, align 1
  %327 = getelementptr inbounds i8, i8* %322, i64 1
  %328 = add i64 %321, -1
  %329 = add nuw nsw i64 %320, 1
  %330 = icmp ult i64 %329, 16
  %331 = icmp ne i64 %328, 0
  %332 = and i1 %331, %330
  br i1 %332, label %319, label %333, !llvm.loop !20

333:                                              ; preds = %319, %311
  %334 = phi i8* [ %258, %311 ], [ %327, %319 ]
  %335 = phi i64 [ %257, %311 ], [ %328, %319 ]
  %336 = phi i1 [ %314, %311 ], [ %331, %319 ]
  tail call void %10(i8* %125, i8* %125, %struct.aes_key_st* %2) #4
  %337 = add i64 %228, 1
  br i1 %336, label %225, label %338

338:                                              ; preds = %333, %231, %122
  %339 = phi i64 [ 1, %122 ], [ %232, %231 ], [ %337, %333 ]
  %340 = icmp ugt i64 %7, -16
  br i1 %340, label %352, label %341

341:                                              ; preds = %338
  %342 = add nuw i64 %7, 15
  %343 = lshr i64 %342, 3
  %344 = or i64 %343, 1
  %345 = add i64 %339, %344
  %346 = icmp ult i64 %345, %339
  %347 = icmp ugt i64 %345, 2305843009213693952
  %348 = or i1 %346, %347
  br i1 %348, label %352, label %349

349:                                              ; preds = %341
  %350 = load i8, i8* %26, align 8
  %351 = and i8 %350, 7
  store i8 %351, i8* %26, align 8
  br label %352

352:                                              ; preds = %16, %349, %341, %338, %21
  %353 = phi i32 [ 0, %21 ], [ 0, %16 ], [ 1, %349 ], [ 0, %341 ], [ 0, %338 ]
  ret i32 %353
}

; Function Attrs: nounwind ssp uwtable
define internal fastcc i32 @ccm128_compute_mac(%struct.ccm128_context* nocapture readonly, %struct.ccm128_state*, %struct.aes_key_st*, i8* nocapture, i64, i8* nocapture readonly, i64) unnamed_addr #1 {
  %8 = alloca <2 x i64>, align 16
  %9 = getelementptr inbounds %struct.ccm128_context, %struct.ccm128_context* %0, i64 0, i32 0
  %10 = load void (i8*, i8*, %struct.aes_key_st*)*, void (i8*, i8*, %struct.aes_key_st*)** %9, align 8
  %11 = getelementptr inbounds %struct.ccm128_context, %struct.ccm128_context* %0, i64 0, i32 2
  %12 = load i32, i32* %11, align 8
  %13 = zext i32 %12 to i64
  %14 = icmp eq i64 %13, %4
  br i1 %14, label %15, label %200

15:                                               ; preds = %7
  %16 = bitcast <2 x i64>* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %16) #4
  %17 = icmp ugt i64 %6, 15
  %18 = bitcast <2 x i64>* %8 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %18, i8 -86, i64 16, i1 false)
  br i1 %17, label %19, label %35

19:                                               ; preds = %15
  %20 = getelementptr inbounds %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1
  %21 = bitcast %union.anon.0* %20 to i8*
  %22 = bitcast %union.anon.0* %20 to <2 x i64>*
  %23 = bitcast %union.anon.0* %20 to <2 x i64>*
  br label %24

24:                                               ; preds = %19, %24
  %25 = phi i64 [ %6, %19 ], [ %31, %24 ]
  %26 = phi i8* [ %5, %19 ], [ %30, %24 ]
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 %16, i8* align 1 %26, i64 16, i1 false) #4
  %27 = load <2 x i64>, <2 x i64>* %8, align 16
  %28 = load <2 x i64>, <2 x i64>* %22, align 8
  %29 = xor <2 x i64> %28, %27
  store <2 x i64> %29, <2 x i64>* %23, align 8
  tail call void %10(i8* %21, i8* %21, %struct.aes_key_st* %2) #4
  %30 = getelementptr inbounds i8, i8* %26, i64 16
  %31 = add i64 %25, -16
  %32 = icmp ugt i64 %31, 15
  br i1 %32, label %24, label %33

33:                                               ; preds = %24
  %34 = and i64 %6, 15
  br label %35

35:                                               ; preds = %33, %15
  %36 = phi i8* [ %5, %15 ], [ %30, %33 ]
  %37 = phi i64 [ %6, %15 ], [ %34, %33 ]
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %173, label %39

39:                                               ; preds = %35
  %40 = getelementptr inbounds %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1
  %41 = bitcast %union.anon.0* %40 to [16 x i8]*
  %42 = icmp ult i64 %37, 32
  br i1 %42, label %43, label %63

43:                                               ; preds = %141, %63, %39
  %44 = phi i64 [ 0, %63 ], [ 0, %39 ], [ %74, %141 ]
  %45 = xor i64 %44, -1
  %46 = add i64 %37, %45
  %47 = and i64 %37, 3
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %60, label %49

49:                                               ; preds = %43, %49
  %50 = phi i64 [ %57, %49 ], [ %44, %43 ]
  %51 = phi i64 [ %58, %49 ], [ %47, %43 ]
  %52 = getelementptr inbounds i8, i8* %36, i64 %50
  %53 = load i8, i8* %52, align 1
  %54 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %50
  %55 = load i8, i8* %54, align 1
  %56 = xor i8 %55, %53
  store i8 %56, i8* %54, align 1
  %57 = add nuw i64 %50, 1
  %58 = add i64 %51, -1
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %60, label %49, !llvm.loop !21

60:                                               ; preds = %49, %43
  %61 = phi i64 [ %44, %43 ], [ %57, %49 ]
  %62 = icmp ult i64 %46, 3
  br i1 %62, label %143, label %146

63:                                               ; preds = %39
  %64 = getelementptr %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1, i32 0, i64 0
  %65 = bitcast i64* %64 to i8*
  %66 = getelementptr %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 0, i32 0, i64 2
  %67 = bitcast i64* %66 to i8*
  %68 = getelementptr i8, i8* %67, i64 %37
  %69 = getelementptr i8, i8* %36, i64 %37
  %70 = icmp ugt i8* %69, %65
  %71 = icmp ult i8* %36, %68
  %72 = and i1 %70, %71
  br i1 %72, label %43, label %73

73:                                               ; preds = %63
  %74 = and i64 %37, -32
  %75 = add i64 %74, -32
  %76 = lshr exact i64 %75, 5
  %77 = add nuw nsw i64 %76, 1
  %78 = and i64 %77, 1
  %79 = icmp eq i64 %75, 0
  br i1 %79, label %121, label %80

80:                                               ; preds = %73
  %81 = sub nuw nsw i64 %77, %78
  br label %82

82:                                               ; preds = %82, %80
  %83 = phi i64 [ 0, %80 ], [ %118, %82 ]
  %84 = phi i64 [ %81, %80 ], [ %119, %82 ]
  %85 = getelementptr inbounds i8, i8* %36, i64 %83
  %86 = bitcast i8* %85 to <16 x i8>*
  %87 = load <16 x i8>, <16 x i8>* %86, align 1, !alias.scope !22
  %88 = getelementptr inbounds i8, i8* %85, i64 16
  %89 = bitcast i8* %88 to <16 x i8>*
  %90 = load <16 x i8>, <16 x i8>* %89, align 1, !alias.scope !22
  %91 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %83
  %92 = bitcast i8* %91 to <16 x i8>*
  %93 = load <16 x i8>, <16 x i8>* %92, align 1, !alias.scope !25, !noalias !22
  %94 = getelementptr inbounds i8, i8* %91, i64 16
  %95 = bitcast i8* %94 to <16 x i8>*
  %96 = load <16 x i8>, <16 x i8>* %95, align 1, !alias.scope !25, !noalias !22
  %97 = xor <16 x i8> %93, %87
  %98 = xor <16 x i8> %96, %90
  %99 = bitcast i8* %91 to <16 x i8>*
  store <16 x i8> %97, <16 x i8>* %99, align 1, !alias.scope !25, !noalias !22
  %100 = bitcast i8* %94 to <16 x i8>*
  store <16 x i8> %98, <16 x i8>* %100, align 1, !alias.scope !25, !noalias !22
  %101 = or i64 %83, 32
  %102 = getelementptr inbounds i8, i8* %36, i64 %101
  %103 = bitcast i8* %102 to <16 x i8>*
  %104 = load <16 x i8>, <16 x i8>* %103, align 1, !alias.scope !22
  %105 = getelementptr inbounds i8, i8* %102, i64 16
  %106 = bitcast i8* %105 to <16 x i8>*
  %107 = load <16 x i8>, <16 x i8>* %106, align 1, !alias.scope !22
  %108 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %101
  %109 = bitcast i8* %108 to <16 x i8>*
  %110 = load <16 x i8>, <16 x i8>* %109, align 1, !alias.scope !25, !noalias !22
  %111 = getelementptr inbounds i8, i8* %108, i64 16
  %112 = bitcast i8* %111 to <16 x i8>*
  %113 = load <16 x i8>, <16 x i8>* %112, align 1, !alias.scope !25, !noalias !22
  %114 = xor <16 x i8> %110, %104
  %115 = xor <16 x i8> %113, %107
  %116 = bitcast i8* %108 to <16 x i8>*
  store <16 x i8> %114, <16 x i8>* %116, align 1, !alias.scope !25, !noalias !22
  %117 = bitcast i8* %111 to <16 x i8>*
  store <16 x i8> %115, <16 x i8>* %117, align 1, !alias.scope !25, !noalias !22
  %118 = add i64 %83, 64
  %119 = add i64 %84, -2
  %120 = icmp eq i64 %119, 0
  br i1 %120, label %121, label %82, !llvm.loop !27

121:                                              ; preds = %82, %73
  %122 = phi i64 [ 0, %73 ], [ %118, %82 ]
  %123 = icmp eq i64 %78, 0
  br i1 %123, label %141, label %124

124:                                              ; preds = %121
  %125 = getelementptr inbounds i8, i8* %36, i64 %122
  %126 = bitcast i8* %125 to <16 x i8>*
  %127 = load <16 x i8>, <16 x i8>* %126, align 1, !alias.scope !22
  %128 = getelementptr inbounds i8, i8* %125, i64 16
  %129 = bitcast i8* %128 to <16 x i8>*
  %130 = load <16 x i8>, <16 x i8>* %129, align 1, !alias.scope !22
  %131 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %122
  %132 = bitcast i8* %131 to <16 x i8>*
  %133 = load <16 x i8>, <16 x i8>* %132, align 1, !alias.scope !25, !noalias !22
  %134 = getelementptr inbounds i8, i8* %131, i64 16
  %135 = bitcast i8* %134 to <16 x i8>*
  %136 = load <16 x i8>, <16 x i8>* %135, align 1, !alias.scope !25, !noalias !22
  %137 = xor <16 x i8> %133, %127
  %138 = xor <16 x i8> %136, %130
  %139 = bitcast i8* %131 to <16 x i8>*
  store <16 x i8> %137, <16 x i8>* %139, align 1, !alias.scope !25, !noalias !22
  %140 = bitcast i8* %134 to <16 x i8>*
  store <16 x i8> %138, <16 x i8>* %140, align 1, !alias.scope !25, !noalias !22
  br label %141

141:                                              ; preds = %121, %124
  %142 = icmp eq i64 %37, %74
  br i1 %142, label %143, label %43

143:                                              ; preds = %60, %146, %141
  %144 = getelementptr inbounds %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1
  %145 = bitcast %union.anon.0* %144 to i8*
  tail call void %10(i8* %145, i8* %145, %struct.aes_key_st* %2) #4
  br label %173

146:                                              ; preds = %60, %146
  %147 = phi i64 [ %171, %146 ], [ %61, %60 ]
  %148 = getelementptr inbounds i8, i8* %36, i64 %147
  %149 = load i8, i8* %148, align 1
  %150 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %147
  %151 = load i8, i8* %150, align 1
  %152 = xor i8 %151, %149
  store i8 %152, i8* %150, align 1
  %153 = add nuw i64 %147, 1
  %154 = getelementptr inbounds i8, i8* %36, i64 %153
  %155 = load i8, i8* %154, align 1
  %156 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %153
  %157 = load i8, i8* %156, align 1
  %158 = xor i8 %157, %155
  store i8 %158, i8* %156, align 1
  %159 = add nuw i64 %147, 2
  %160 = getelementptr inbounds i8, i8* %36, i64 %159
  %161 = load i8, i8* %160, align 1
  %162 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %159
  %163 = load i8, i8* %162, align 1
  %164 = xor i8 %163, %161
  store i8 %164, i8* %162, align 1
  %165 = add nuw i64 %147, 3
  %166 = getelementptr inbounds i8, i8* %36, i64 %165
  %167 = load i8, i8* %166, align 1
  %168 = getelementptr inbounds [16 x i8], [16 x i8]* %41, i64 0, i64 %165
  %169 = load i8, i8* %168, align 1
  %170 = xor i8 %169, %167
  store i8 %170, i8* %168, align 1
  %171 = add nuw i64 %147, 4
  %172 = icmp eq i64 %171, %37
  br i1 %172, label %143, label %146, !llvm.loop !28

173:                                              ; preds = %35, %143
  %174 = getelementptr inbounds %struct.ccm128_context, %struct.ccm128_context* %0, i64 0, i32 3
  %175 = load i32, i32* %174, align 4
  %176 = icmp eq i32 %175, 0
  br i1 %176, label %179, label %177

177:                                              ; preds = %173
  %178 = bitcast %struct.ccm128_state* %1 to [16 x i8]*
  br label %191

179:                                              ; preds = %191, %173
  %180 = bitcast %struct.ccm128_state* %1 to i8*
  call void %10(i8* %180, i8* nonnull %16, %struct.aes_key_st* %2) #4
  %181 = getelementptr inbounds %struct.ccm128_state, %struct.ccm128_state* %1, i64 0, i32 1
  %182 = load <2 x i64>, <2 x i64>* %8, align 16
  %183 = bitcast %union.anon.0* %181 to <2 x i64>*
  %184 = load <2 x i64>, <2 x i64>* %183, align 8
  %185 = xor <2 x i64> %184, %182
  %186 = bitcast %union.anon.0* %181 to <2 x i64>*
  store <2 x i64> %185, <2 x i64>* %186, align 8
  %187 = icmp eq i64 %4, 0
  br i1 %187, label %190, label %188

188:                                              ; preds = %179
  %189 = bitcast %union.anon.0* %181 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %3, i8* align 1 %189, i64 %4, i1 false) #4
  br label %190

190:                                              ; preds = %179, %188
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %16) #4
  br label %200

191:                                              ; preds = %177, %191
  %192 = phi i64 [ 0, %177 ], [ %196, %191 ]
  %193 = sub nsw i64 15, %192
  %194 = and i64 %193, 4294967295
  %195 = getelementptr inbounds [16 x i8], [16 x i8]* %178, i64 0, i64 %194
  store i8 0, i8* %195, align 1
  %196 = add nuw nsw i64 %192, 1
  %197 = load i32, i32* %174, align 4
  %198 = zext i32 %197 to i64
  %199 = icmp ult i64 %196, %198
  br i1 %199, label %191, label %179

200:                                              ; preds = %7, %190
  %201 = phi i32 [ 1, %190 ], [ 0, %7 ]
  ret i32 %201
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #3

declare void @CRYPTO_ctr128_encrypt_ctr32(i8*, i8*, i64, %struct.aes_key_st*, i8*, i8*, i32*, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)*) local_unnamed_addr #2

declare void @CRYPTO_ctr128_encrypt(i8*, i8*, i64, %struct.aes_key_st*, i8*, i8*, i32*, void (i8*, i8*, %struct.aes_key_st*)*) local_unnamed_addr #2

declare i32 @CRYPTO_memcmp(i8*, i8*, i64) local_unnamed_addr #2

; Function Attrs: nounwind ssp uwtable
define internal i32 @aead_aes_ccm_bluetooth_8_init(%struct.evp_aead_ctx_st*, i8*, i64, i64) #1 {
  %5 = alloca void (i8*, i8*, %struct.aes_key_st*)*, align 8
  %6 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 0
  %7 = load %struct.evp_aead_st*, %struct.evp_aead_st** %6, align 8
  %8 = tail call i64 @EVP_AEAD_key_length(%struct.evp_aead_st* %7) #4
  %9 = icmp eq i64 %8, %2
  br i1 %9, label %11, label %10

10:                                               ; preds = %4
  tail call void @ERR_put_error(i32 30, i32 0, i32 102, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 295) #4
  br label %31

11:                                               ; preds = %4
  %12 = and i64 %3, -9
  %13 = icmp eq i64 %12, 0
  br i1 %13, label %15, label %14

14:                                               ; preds = %11
  tail call void @ERR_put_error(i32 30, i32 0, i32 116, i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str, i64 0, i64 0), i32 304) #4
  br label %31

15:                                               ; preds = %11
  %16 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1
  %17 = bitcast void (i8*, i8*, %struct.aes_key_st*)** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %17) #4
  store void (i8*, i8*, %struct.aes_key_st*)* inttoptr (i64 -6148914691236517206 to void (i8*, i8*, %struct.aes_key_st*)*), void (i8*, i8*, %struct.aes_key_st*)** %5, align 8
  %18 = bitcast %union.evp_aead_ctx_st_state* %16 to %struct.aes_key_st*
  %19 = call void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* @aes_ctr_set_key(%struct.aes_key_st* %18, %struct.gcm128_key_st* null, void (i8*, i8*, %struct.aes_key_st*)** nonnull %5, i8* %1, i64 %2) #4
  %20 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 2
  store i8 8, i8* %20, align 8
  %21 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 240
  %22 = bitcast void (i8*, i8*, %struct.aes_key_st*)** %5 to i64*
  %23 = load i64, i64* %22, align 8
  %24 = bitcast i8* %21 to i64*
  store i64 %23, i64* %24, align 8
  %25 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 248
  %26 = bitcast i8* %25 to void (i8*, i8*, i64, %struct.aes_key_st*, i8*)**
  store void (i8*, i8*, i64, %struct.aes_key_st*, i8*)* %19, void (i8*, i8*, i64, %struct.aes_key_st*, i8*)** %26, align 8
  %27 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 256
  %28 = bitcast i8* %27 to i32*
  store i32 8, i32* %28, align 8
  %29 = getelementptr inbounds %struct.evp_aead_ctx_st, %struct.evp_aead_ctx_st* %0, i64 0, i32 1, i32 1, i64 260
  %30 = bitcast i8* %29 to i32*
  store i32 2, i32* %30, align 4
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %17) #4
  br label %31

31:                                               ; preds = %10, %14, %15
  %32 = phi i32 [ 0, %10 ], [ 0, %14 ], [ 1, %15 ]
  ret i32 %32
}

attributes #0 = { norecurse nounwind readnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { argmemonly nounwind }
attributes #4 = { nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = distinct !{!2, !3}
!3 = !{!"llvm.loop.unroll.disable"}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.isvectorized", i32 1}
!6 = distinct !{!6, !3}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !3}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !3}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = distinct !{!13, !5}
!14 = !{!15}
!15 = distinct !{!15, !16}
!16 = distinct !{!16, !"LVerDomain"}
!17 = !{!18}
!18 = distinct !{!18, !16}
!19 = distinct !{!19, !5}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !3}
!22 = !{!23}
!23 = distinct !{!23, !24}
!24 = distinct !{!24, !"LVerDomain"}
!25 = !{!26}
!26 = distinct !{!26, !24}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
