; ModuleID = '../../third_party/unrar/src/qopen.cpp'
source_filename = "../../third_party/unrar/src/qopen.cpp"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver fmemopen, fmemopen@GLIBC_2.2.5"
module asm ".symver glob, glob@GLIBC_2.2.5"
module asm ".symver glob64, glob64@GLIBC_2.2.5"
module asm ".symver quick_exit, quick_exit@GLIBC_2.10"
module asm ".symver fmemopen, fmemopen@GLIBC_2.2.5"
module asm ".symver glob, glob@GLIBC_2.2.5"
module asm ".symver glob64, glob64@GLIBC_2.2.5"
module asm ".symver quick_exit, quick_exit@GLIBC_2.10"

%class.ErrorHandler = type <{ i32, i32, i8, i8, i8, i8, i8, i8, [2 x i8] }>
%class.QuickOpen = type <{ %class.Archive*, i8, [7 x i8], %struct.QuickOpenItem*, %struct.QuickOpenItem*, i8*, i64, %class.CryptData, i8, [7 x i8], i64, i64, i64, i64, i64, i64, %class.Array, i64, i64, i8, [7 x i8] }>
%class.Archive = type <{ %class.File, %class.CryptData, %class.ComprDataIO, i8, [7 x i8], %class.RAROptions*, %class.RarTime, i32, i32, i8, [7 x i8], %class.QuickOpen, i8, [7 x i8], i64, %struct.BaseBlock, %struct.MarkHeader, %struct.MainHeader, %struct.CryptHeader, [4 x i8], %struct.FileHeader, %struct.EndArcHeader, %struct.SubBlockHeader, [4 x i8], %struct.FileHeader, %struct.CommentHeader, %struct.ProtectHeader, %struct.UnixOwnersHeader, %struct.EAHeader, %struct.StreamHeader, [4 x i8], i64, i64, i32, i8, i8, i8, i8, i8, i8, i8, i8, i8, [3 x i8], i64, i8, i8, [16 x i8], i8, i8, i32, i64, i64, i64, i8, [3 x i8], [2048 x i32], [4 x i8] }>
%class.File = type { i32 (...)**, i64, i8, i32, i8, i32, i8, i8, i8, i8, i8, i8, [2048 x i32], i32, i64 }
%class.ComprDataIO = type <{ i8, [7 x i8], i64, i8*, i8, [7 x i8], i64, i8*, i64, i8*, i64, i8, i8, i8, i8, [4 x i8], %class.File*, %class.File*, %class.CmdAdd*, %struct.FileHeader*, i64*, %class.CryptData*, %class.CryptData*, i32, i32, i8, i8, i8, [5 x i8], i64, i64, i64, i64, i64, i64, i64, %class.DataHash, %class.DataHash, %class.DataHash, i8, i8, [6 x i8] }>
%class.CmdAdd = type opaque
%class.DataHash = type <{ i32, i32, %struct.blake2sp_state*, %class.ThreadPool*, i32, [4 x i8] }>
%struct.blake2sp_state = type <{ [8 x %struct.blake2s_state], %struct.blake2s_state, [512 x i8], i64, %class.ThreadPool*, i32, [4 x i8] }>
%struct.blake2s_state = type <{ [240 x i8], i8*, i32*, i32*, i32*, i64, i8, [7 x i8] }>
%class.ThreadPool = type { i32, [64 x i64], i32, i32, [64 x %"struct.ThreadPool::QueueEntry"], i32, i32, i8, i32, %union.pthread_cond_t, %union.pthread_mutex_t, i8, %union.pthread_cond_t, %union.pthread_mutex_t, %union.pthread_mutex_t }
%"struct.ThreadPool::QueueEntry" = type { void (i8*)*, i8* }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.anon.1, %union.anon.2, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.anon.1 = type { i64 }
%union.anon.2 = type { i64 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }
%class.RAROptions = type <{ i32, i32, i8, i8, i8, [5 x i8], i64, [2048 x i32], [2048 x i32], i32, i8, [3 x i8], [2048 x i32], [2048 x i32], i32, i32, i32, i32, [2048 x i32], %class.SecPassword, i8, i8, [2 x i8], [2048 x i32], i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i8, i8, [3 x i8], i32, i32, i8, i8, i8, i8, i8, [3 x i8], i32, i32, [4 x i8], i64, %class.Array.4, i32, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, i32, i32, i8, i8, i8, i8, [128 x i32], [128 x i32], i8, i8, i8, i8, i8, [3 x i8], %class.RarTime, %class.RarTime, %class.RarTime, i8, i8, i8, [5 x i8], %class.RarTime, %class.RarTime, %class.RarTime, i8, i8, i8, [5 x i8], i64, i64, i8, i8, i8, i8, [16 x %struct.FilterMode], [2048 x i32], i32, i32, i32, i32, i32, i32, i8, [3 x i8], [2048 x i32], i32, [4 x i8] }>
%class.SecPassword = type <{ [128 x i32], i8, i8, [2 x i8] }>
%class.Array.4 = type <{ i64*, i64, i64, i64, i8, [7 x i8] }>
%struct.FilterMode = type { i32, i32, i32 }
%class.RarTime = type { i64 }
%struct.BaseBlock = type { i32, i32, i32, i32, i8 }
%struct.MarkHeader = type { [8 x i8], i32 }
%struct.MainHeader = type { %struct.BaseBlock, i16, i32, i8, i8, i8, i64, i64, i64, i64 }
%struct.CryptHeader = type { %struct.BaseBlock, i8, i32, [16 x i8], [8 x i8] }
%struct.EndArcHeader = type { %struct.BaseBlock, i32, i32, i8, i8, i8, i8 }
%struct.SubBlockHeader = type <{ %struct.BlockHeader, i16, i8, i8 }>
%struct.BlockHeader = type { %struct.BaseBlock, i32 }
%struct.FileHeader = type { %struct.BlockHeader, i8, i32, i8, %union.anon, [2048 x i32], %class.Array, %class.RarTime, %class.RarTime, %class.RarTime, i64, i64, i64, %struct.HashValue, i32, i8, i8, i8, i8, i32, i8, [16 x i8], [16 x i8], i8, [8 x i8], i8, [32 x i8], i32, i8, i8, i8, i8, i64, i8, i8, i8, i32, i32, [2048 x i32], i8, i8, i8, i8, [256 x i8], [256 x i8], i32, i32 }
%union.anon = type { i32 }
%struct.HashValue = type { i32, %union.anon.0 }
%union.anon.0 = type { i32, [28 x i8] }
%struct.CommentHeader = type <{ %struct.BaseBlock, i16, i8, i8, i16, [2 x i8] }>
%struct.ProtectHeader = type { %struct.BlockHeader, i8, i16, i32, [8 x i8] }
%struct.UnixOwnersHeader = type { %struct.SubBlockHeader.base, i16, i16, [256 x i8], [256 x i8] }
%struct.SubBlockHeader.base = type <{ %struct.BlockHeader, i16, i8 }>
%struct.EAHeader = type { %struct.SubBlockHeader.base, i32, i8, i8, i32 }
%struct.StreamHeader = type <{ %struct.SubBlockHeader.base, i8, i32, i8, i8, [2 x i8], i32, i16, [260 x i8], [2 x i8] }>
%struct.QuickOpenItem = type { i8*, i64, i64, %struct.QuickOpenItem* }
%class.CryptData = type { [4 x %"struct.CryptData::KDF3CacheItem"], i32, [4 x %"struct.CryptData::KDF5CacheItem"], i32, i32, %class.Rijndael, [256 x i32], [256 x i8], [4 x i32], [3 x i8], [4 x i16] }
%"struct.CryptData::KDF3CacheItem" = type { %class.SecPassword, [8 x i8], [16 x i8], [16 x i8], i8, [3 x i8] }
%"struct.CryptData::KDF5CacheItem" = type { %class.SecPassword, [16 x i8], [32 x i8], i32, [32 x i8], [32 x i8] }
%class.Rijndael = type { i8, i32, [16 x i8], [15 x [4 x [4 x i8]]] }
%class.Array = type <{ i8*, i64, i64, i64, i8, [7 x i8] }>
%class.RawRead = type { %class.Array, %class.File*, i64, i64, %class.CryptData* }

$_ZN5ArrayIhE3AddEm = comdat any

@.str = private unnamed_addr constant [3 x i32] [i32 81, i32 79, i32 0], align 4
@ErrHandler = external global %class.ErrorHandler, align 4
@.str.1 = private unnamed_addr constant [44 x i32] [i32 77, i32 97, i32 120, i32 105, i32 109, i32 117, i32 109, i32 32, i32 97, i32 108, i32 108, i32 111, i32 119, i32 101, i32 100, i32 32, i32 97, i32 114, i32 114, i32 97, i32 121, i32 32, i32 115, i32 105, i32 122, i32 101, i32 32, i32 40, i32 37, i32 117, i32 41, i32 32, i32 105, i32 115, i32 32, i32 101, i32 120, i32 99, i32 101, i32 101, i32 100, i32 101, i32 100, i32 0], align 4

@_ZN9QuickOpenC1Ev = hidden unnamed_addr alias void (%class.QuickOpen*), void (%class.QuickOpen*)* @_ZN9QuickOpenC2Ev
@_ZN9QuickOpenD1Ev = hidden unnamed_addr alias void (%class.QuickOpen*), void (%class.QuickOpen*)* @_ZN9QuickOpenD2Ev

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN9QuickOpenC2Ev(%class.QuickOpen*) unnamed_addr #0 align 2 {
  %2 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 7
  tail call void @_ZN9CryptDataC1Ev(%class.CryptData* %2) #9
  %3 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16
  %4 = bitcast %class.Array* %3 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* align 8 %4, i8 0, i64 33, i1 false) #9
  %5 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 5
  %6 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 0
  store %class.Archive* null, %class.Archive** %6, align 8
  %7 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 1
  store i8 0, i8* %7, align 8
  %8 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 3
  %9 = bitcast %struct.QuickOpenItem** %8 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %9, i8 0, i64 16, i1 false)
  %10 = tail call i8* @_Znam(i64 65536) #10
  store i8* %10, i8** %5, align 8
  %11 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 6
  store i64 0, i64* %11, align 8
  %12 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  store i8 0, i8* %12, align 8
  ret void
}

declare void @_ZN9CryptDataC1Ev(%class.CryptData*) unnamed_addr #1

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN9QuickOpen4InitEP7Archiveb(%class.QuickOpen* nocapture, %class.Archive*, i1 zeroext) local_unnamed_addr #0 align 2 {
  %4 = zext i1 %2 to i8
  %5 = icmp eq %class.Archive* %1, null
  br i1 %5, label %21, label %6

6:                                                ; preds = %3
  %7 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 3
  %8 = load %struct.QuickOpenItem*, %struct.QuickOpenItem** %7, align 8
  %9 = icmp eq %struct.QuickOpenItem* %8, null
  br i1 %9, label %21, label %10

10:                                               ; preds = %6, %19
  %11 = phi %struct.QuickOpenItem* [ %14, %19 ], [ %8, %6 ]
  %12 = bitcast %struct.QuickOpenItem* %11 to i8*
  %13 = getelementptr inbounds %struct.QuickOpenItem, %struct.QuickOpenItem* %11, i64 0, i32 3
  %14 = load %struct.QuickOpenItem*, %struct.QuickOpenItem** %13, align 8
  %15 = getelementptr inbounds %struct.QuickOpenItem, %struct.QuickOpenItem* %11, i64 0, i32 0
  %16 = load i8*, i8** %15, align 8
  %17 = icmp eq i8* %16, null
  br i1 %17, label %19, label %18

18:                                               ; preds = %10
  tail call void @_ZdaPv(i8* nonnull %16) #10
  br label %19

19:                                               ; preds = %18, %10
  tail call void @_ZdlPv(i8* %12) #10
  %20 = icmp eq %struct.QuickOpenItem* %14, null
  br i1 %20, label %21, label %10

21:                                               ; preds = %19, %6, %3
  %22 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 0
  store %class.Archive* %1, %class.Archive** %22, align 8
  %23 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 1
  store i8 %4, i8* %23, align 8
  %24 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 3
  %25 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 5
  %26 = bitcast %struct.QuickOpenItem** %24 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %26, i8 0, i64 16, i1 false)
  %27 = load i8*, i8** %25, align 8
  %28 = icmp eq i8* %27, null
  br i1 %28, label %29, label %31

29:                                               ; preds = %21
  %30 = tail call i8* @_Znam(i64 65536) #10
  store i8* %30, i8** %25, align 8
  br label %31

31:                                               ; preds = %29, %21
  %32 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 6
  store i64 0, i64* %32, align 8
  %33 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  store i8 0, i8* %33, align 8
  ret void
}

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN9QuickOpenD2Ev(%class.QuickOpen*) unnamed_addr #0 align 2 {
  %2 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 3
  %3 = load %struct.QuickOpenItem*, %struct.QuickOpenItem** %2, align 8
  %4 = icmp eq %struct.QuickOpenItem* %3, null
  br i1 %4, label %16, label %5

5:                                                ; preds = %1, %14
  %6 = phi %struct.QuickOpenItem* [ %9, %14 ], [ %3, %1 ]
  %7 = bitcast %struct.QuickOpenItem* %6 to i8*
  %8 = getelementptr inbounds %struct.QuickOpenItem, %struct.QuickOpenItem* %6, i64 0, i32 3
  %9 = load %struct.QuickOpenItem*, %struct.QuickOpenItem** %8, align 8
  %10 = getelementptr inbounds %struct.QuickOpenItem, %struct.QuickOpenItem* %6, i64 0, i32 0
  %11 = load i8*, i8** %10, align 8
  %12 = icmp eq i8* %11, null
  br i1 %12, label %14, label %13

13:                                               ; preds = %5
  tail call void @_ZdaPv(i8* nonnull %11) #10
  br label %14

14:                                               ; preds = %13, %5
  tail call void @_ZdlPv(i8* %7) #10
  %15 = icmp eq %struct.QuickOpenItem* %9, null
  br i1 %15, label %16, label %5

16:                                               ; preds = %14, %1
  %17 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 5
  %18 = load i8*, i8** %17, align 8
  %19 = icmp eq i8* %18, null
  br i1 %19, label %21, label %20

20:                                               ; preds = %16
  tail call void @_ZdaPv(i8* nonnull %18) #10
  br label %21

21:                                               ; preds = %20, %16
  %22 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 0
  %23 = load i8*, i8** %22, align 8
  %24 = icmp eq i8* %23, null
  br i1 %24, label %35, label %25

25:                                               ; preds = %21
  %26 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 4
  %27 = load i8, i8* %26, align 8, !range !2
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %33, label %29

29:                                               ; preds = %25
  %30 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 2
  %31 = load i64, i64* %30, align 8
  tail call void @_Z9cleandataPvm(i8* nonnull %23, i64 %31) #9
  %32 = load i8*, i8** %22, align 8
  br label %33

33:                                               ; preds = %29, %25
  %34 = phi i8* [ %23, %25 ], [ %32, %29 ]
  tail call void @free(i8* %34) #9
  br label %35

35:                                               ; preds = %21, %33
  %36 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 7
  tail call void @_ZN9CryptDataD1Ev(%class.CryptData* %36) #9
  ret void
}

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN9QuickOpen5CloseEv(%class.QuickOpen* nocapture readonly) local_unnamed_addr #0 align 2 {
  %2 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 3
  %3 = load %struct.QuickOpenItem*, %struct.QuickOpenItem** %2, align 8
  %4 = icmp eq %struct.QuickOpenItem* %3, null
  br i1 %4, label %16, label %5

5:                                                ; preds = %1, %14
  %6 = phi %struct.QuickOpenItem* [ %9, %14 ], [ %3, %1 ]
  %7 = bitcast %struct.QuickOpenItem* %6 to i8*
  %8 = getelementptr inbounds %struct.QuickOpenItem, %struct.QuickOpenItem* %6, i64 0, i32 3
  %9 = load %struct.QuickOpenItem*, %struct.QuickOpenItem** %8, align 8
  %10 = getelementptr inbounds %struct.QuickOpenItem, %struct.QuickOpenItem* %6, i64 0, i32 0
  %11 = load i8*, i8** %10, align 8
  %12 = icmp eq i8* %11, null
  br i1 %12, label %14, label %13

13:                                               ; preds = %5
  tail call void @_ZdaPv(i8* nonnull %11) #10
  br label %14

14:                                               ; preds = %5, %13
  tail call void @_ZdlPv(i8* %7) #10
  %15 = icmp eq %struct.QuickOpenItem* %9, null
  br i1 %15, label %16, label %5

16:                                               ; preds = %14, %1
  ret void
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdaPv(i8*) local_unnamed_addr #2

; Function Attrs: nounwind
declare void @_ZN9CryptDataD1Ev(%class.CryptData*) unnamed_addr #3

; Function Attrs: nobuiltin nofree
declare noalias nonnull i8* @_Znam(i64) local_unnamed_addr #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #5

; Function Attrs: nobuiltin nounwind
declare void @_ZdlPv(i8*) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #5

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN9QuickOpen4LoadEm(%class.QuickOpen*, i64) local_unnamed_addr #0 align 2 {
  %3 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  %4 = load i8, i8* %3, align 8, !range !2
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %6, label %60

6:                                                ; preds = %2
  %7 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 0
  %8 = load %class.Archive*, %class.Archive** %7, align 8
  %9 = bitcast %class.Archive* %8 to i64 (%class.Archive*)***
  %10 = load i64 (%class.Archive*)**, i64 (%class.Archive*)*** %9, align 8
  %11 = getelementptr inbounds i64 (%class.Archive*)*, i64 (%class.Archive*)** %10, i64 6
  %12 = load i64 (%class.Archive*)*, i64 (%class.Archive*)** %11, align 8
  %13 = tail call i64 %12(%class.Archive* %8) #9
  %14 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 18
  store i64 %13, i64* %14, align 8
  %15 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 19
  store i8 0, i8* %15, align 8
  %16 = load %class.Archive*, %class.Archive** %7, align 8
  %17 = bitcast %class.Archive* %16 to void (%class.Archive*, i64, i32)***
  %18 = load void (%class.Archive*, i64, i32)**, void (%class.Archive*, i64, i32)*** %17, align 8
  %19 = getelementptr inbounds void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %18, i64 5
  %20 = load void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %19, align 8
  tail call void %20(%class.Archive* %16, i64 %1, i32 0) #9
  %21 = load %class.Archive*, %class.Archive** %7, align 8
  %22 = getelementptr inbounds %class.Archive, %class.Archive* %21, i64 0, i32 12
  store i8 1, i8* %22, align 8
  %23 = load %class.Archive*, %class.Archive** %7, align 8
  %24 = tail call i64 @_ZN7Archive10ReadHeaderEv(%class.Archive* %23) #9
  %25 = load %class.Archive*, %class.Archive** %7, align 8
  %26 = getelementptr inbounds %class.Archive, %class.Archive* %25, i64 0, i32 12
  store i8 0, i8* %26, align 8
  %27 = icmp eq i64 %24, 0
  %28 = load %class.Archive*, %class.Archive** %7, align 8
  br i1 %27, label %37, label %29

29:                                               ; preds = %6
  %30 = getelementptr inbounds %class.Archive, %class.Archive* %28, i64 0, i32 8
  %31 = load i32, i32* %30, align 4
  %32 = icmp eq i32 %31, 3
  br i1 %32, label %33, label %37

33:                                               ; preds = %29
  %34 = getelementptr inbounds %class.Archive, %class.Archive* %28, i64 0, i32 24, i32 5, i64 0
  %35 = tail call i32 @wcscmp(i32* %34, i32* getelementptr inbounds ([3 x i32], [3 x i32]* @.str, i64 0, i64 0)) #11
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %42, label %37

37:                                               ; preds = %6, %29, %33
  %38 = bitcast %class.Archive* %28 to void (%class.Archive*, i64, i32)***
  %39 = load void (%class.Archive*, i64, i32)**, void (%class.Archive*, i64, i32)*** %38, align 8
  %40 = getelementptr inbounds void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %39, i64 5
  %41 = load void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %40, align 8
  tail call void %41(%class.Archive* %28, i64 %13, i32 0) #9
  br label %95

42:                                               ; preds = %33
  %43 = getelementptr inbounds %class.Archive, %class.Archive* %28, i64 0, i32 31
  %44 = load i64, i64* %43, align 8
  %45 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 10
  store i64 %44, i64* %45, align 8
  %46 = bitcast %class.Archive* %28 to i64 (%class.Archive*)***
  %47 = load i64 (%class.Archive*)**, i64 (%class.Archive*)*** %46, align 8
  %48 = getelementptr inbounds i64 (%class.Archive*)*, i64 (%class.Archive*)** %47, i64 6
  %49 = load i64 (%class.Archive*)*, i64 (%class.Archive*)** %48, align 8
  %50 = tail call i64 %49(%class.Archive* %28) #9
  %51 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 11
  store i64 %50, i64* %51, align 8
  %52 = load %class.Archive*, %class.Archive** %7, align 8
  %53 = getelementptr inbounds %class.Archive, %class.Archive* %52, i64 0, i32 24, i32 11
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 12
  store i64 %54, i64* %55, align 8
  %56 = bitcast %class.Archive* %52 to void (%class.Archive*, i64, i32)***
  %57 = load void (%class.Archive*, i64, i32)**, void (%class.Archive*, i64, i32)*** %56, align 8
  %58 = getelementptr inbounds void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %57, i64 5
  %59 = load void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %58, align 8
  tail call void %59(%class.Archive* %52, i64 %13, i32 0) #9
  store i8 1, i8* %3, align 8
  br label %60

60:                                               ; preds = %42, %2
  %61 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 0
  %62 = load %class.Archive*, %class.Archive** %61, align 8
  %63 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 24, i32 18
  %64 = load i8, i8* %63, align 1, !range !2
  %65 = icmp eq i8 %64, 0
  br i1 %65, label %83, label %66

66:                                               ; preds = %60
  %67 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 5
  %68 = load %class.RAROptions*, %class.RAROptions** %67, align 8
  %69 = getelementptr inbounds %class.RAROptions, %class.RAROptions* %68, i64 0, i32 19, i32 1
  %70 = load i8, i8* %69, align 4, !range !2
  %71 = icmp eq i8 %70, 0
  br i1 %71, label %82, label %72

72:                                               ; preds = %66
  %73 = getelementptr inbounds %class.RAROptions, %class.RAROptions* %68, i64 0, i32 19
  %74 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 7
  %75 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 24, i32 21, i64 0
  %76 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 24, i32 22, i64 0
  %77 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 24, i32 27
  %78 = load i32, i32* %77, align 4
  %79 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 24, i32 26, i64 0
  %80 = getelementptr inbounds %class.Archive, %class.Archive* %62, i64 0, i32 24, i32 24, i64 0
  %81 = tail call zeroext i1 @_ZN9CryptData12SetCryptKeysEb12CRYPT_METHODP11SecPasswordPKhS4_jPhS5_(%class.CryptData* %74, i1 zeroext false, i32 5, %class.SecPassword* %73, i8* %75, i8* %76, i32 %78, i8* %79, i8* %80) #9
  br label %83

82:                                               ; preds = %66
  store i8 0, i8* %3, align 8
  br label %95

83:                                               ; preds = %72, %60
  %84 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 13
  %85 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 0
  %86 = bitcast i64* %84 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %86, i8 0, i64 24, i1 false)
  %87 = load i8*, i8** %85, align 8
  %88 = icmp eq i8* %87, null
  br i1 %88, label %90, label %89

89:                                               ; preds = %83
  tail call void @free(i8* nonnull %87) #9
  store i8* null, i8** %85, align 8
  br label %90

90:                                               ; preds = %83, %89
  %91 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 1
  %92 = bitcast i64* %91 to i8*
  tail call void @llvm.memset.p0i8.i64(i8* align 8 %92, i8 0, i64 16, i1 false) #9
  %93 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 17
  store i64 0, i64* %93, align 8
  %94 = tail call i32 @_ZN9QuickOpen10ReadBufferEv(%class.QuickOpen* %0)
  br label %95

95:                                               ; preds = %82, %37, %90
  ret void
}

declare i64 @_ZN7Archive10ReadHeaderEv(%class.Archive*) local_unnamed_addr #1

declare zeroext i1 @_ZN9CryptData12SetCryptKeysEb12CRYPT_METHODP11SecPasswordPKhS4_jPhS5_(%class.CryptData*, i1 zeroext, i32, %class.SecPassword*, i8*, i8*, i32, i8*, i8*) local_unnamed_addr #1

; Function Attrs: nounwind ssp uwtable
define hidden i32 @_ZN9QuickOpen10ReadBufferEv(%class.QuickOpen*) local_unnamed_addr #0 align 2 {
  %2 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 0
  %3 = load %class.Archive*, %class.Archive** %2, align 8
  %4 = bitcast %class.Archive* %3 to i64 (%class.Archive*)***
  %5 = load i64 (%class.Archive*)**, i64 (%class.Archive*)*** %4, align 8
  %6 = getelementptr inbounds i64 (%class.Archive*)*, i64 (%class.Archive*)** %5, i64 6
  %7 = load i64 (%class.Archive*)*, i64 (%class.Archive*)** %6, align 8
  %8 = tail call i64 %7(%class.Archive* %3) #9
  %9 = bitcast %class.QuickOpen* %0 to %class.File**
  %10 = load %class.File*, %class.File** %9, align 8
  %11 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 11
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 13
  %14 = load i64, i64* %13, align 8
  %15 = add i64 %14, %12
  tail call void @_ZN4File4SeekEli(%class.File* %10, i64 %15, i32 0) #9
  %16 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 12
  %17 = load i64, i64* %16, align 8
  %18 = load i64, i64* %13, align 8
  %19 = sub i64 %17, %18
  %20 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 14
  %21 = load i64, i64* %20, align 8
  %22 = sub i64 65536, %21
  %23 = icmp ult i64 %19, %22
  %24 = select i1 %23, i64 %19, i64 %22
  %25 = load %class.Archive*, %class.Archive** %2, align 8
  %26 = getelementptr inbounds %class.Archive, %class.Archive* %25, i64 0, i32 24, i32 18
  %27 = load i8, i8* %26, align 1, !range !2
  %28 = icmp eq i8 %27, 0
  %29 = and i64 %24, -16
  %30 = select i1 %28, i64 %24, i64 %29
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %59, label %32

32:                                               ; preds = %1
  %33 = getelementptr inbounds %class.Archive, %class.Archive* %25, i64 0, i32 0
  %34 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 5
  %35 = load i8*, i8** %34, align 8
  %36 = getelementptr inbounds i8, i8* %35, i64 %21
  %37 = tail call i32 @_ZN4File4ReadEPvm(%class.File* %33, i8* %36, i64 %30) #9
  %38 = icmp slt i32 %37, 1
  br i1 %38, label %59, label %39

39:                                               ; preds = %32
  %40 = load %class.Archive*, %class.Archive** %2, align 8
  %41 = getelementptr inbounds %class.Archive, %class.Archive* %40, i64 0, i32 24, i32 18
  %42 = load i8, i8* %41, align 1, !range !2
  %43 = icmp eq i8 %42, 0
  br i1 %43, label %51, label %44

44:                                               ; preds = %39
  %45 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 7
  %46 = load i8*, i8** %34, align 8
  %47 = load i64, i64* %20, align 8
  %48 = getelementptr inbounds i8, i8* %46, i64 %47
  %49 = and i32 %37, -16
  %50 = sext i32 %49 to i64
  tail call void @_ZN9CryptData12DecryptBlockEPhm(%class.CryptData* %45, i8* %48, i64 %50) #9
  br label %51

51:                                               ; preds = %39, %44
  %52 = sext i32 %37 to i64
  %53 = bitcast i64* %13 to <2 x i64>*
  %54 = load <2 x i64>, <2 x i64>* %53, align 8
  %55 = insertelement <2 x i64> undef, i64 %52, i32 0
  %56 = shufflevector <2 x i64> %55, <2 x i64> undef, <2 x i32> zeroinitializer
  %57 = add <2 x i64> %54, %56
  %58 = bitcast i64* %13 to <2 x i64>*
  store <2 x i64> %57, <2 x i64>* %58, align 8
  br label %59

59:                                               ; preds = %32, %1, %51
  %60 = phi i32 [ %37, %51 ], [ 0, %1 ], [ 0, %32 ]
  %61 = load %class.Archive*, %class.Archive** %2, align 8
  %62 = bitcast %class.Archive* %61 to void (%class.Archive*, i64, i32)***
  %63 = load void (%class.Archive*, i64, i32)**, void (%class.Archive*, i64, i32)*** %62, align 8
  %64 = getelementptr inbounds void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %63, i64 5
  %65 = load void (%class.Archive*, i64, i32)*, void (%class.Archive*, i64, i32)** %64, align 8
  tail call void %65(%class.Archive* %61, i64 %8, i32 0) #9
  ret i32 %60
}

; Function Attrs: nounwind ssp uwtable
define hidden zeroext i1 @_ZN9QuickOpen4ReadEPvmRm(%class.QuickOpen*, i8*, i64, i64* nocapture dereferenceable(8)) local_unnamed_addr #0 align 2 {
  %5 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  %6 = load i8, i8* %5, align 8, !range !2
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %64, label %8

8:                                                ; preds = %4
  %9 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 17
  %10 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 1
  %11 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 18
  br label %12

12:                                               ; preds = %8, %18
  %13 = load i64, i64* %9, align 8
  %14 = load i64, i64* %10, align 8
  %15 = add i64 %14, %13
  %16 = load i64, i64* %11, align 8
  %17 = icmp ugt i64 %15, %16
  br i1 %17, label %20, label %18

18:                                               ; preds = %12
  %19 = tail call zeroext i1 @_ZN9QuickOpen8ReadNextEv(%class.QuickOpen* %0)
  br i1 %19, label %12, label %20

20:                                               ; preds = %12, %18
  %21 = load i8, i8* %5, align 8, !range !2
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %23, label %31

23:                                               ; preds = %20
  %24 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 19
  %25 = load i8, i8* %24, align 8, !range !2
  %26 = icmp eq i8 %25, 0
  br i1 %26, label %64, label %27

27:                                               ; preds = %23
  %28 = bitcast %class.QuickOpen* %0 to %class.File**
  %29 = load %class.File*, %class.File** %28, align 8
  %30 = load i64, i64* %11, align 8
  tail call void @_ZN4File4SeekEli(%class.File* %29, i64 %30, i32 0) #9
  br label %64

31:                                               ; preds = %20
  %32 = load i64, i64* %11, align 8
  %33 = load i64, i64* %9, align 8
  %34 = icmp ult i64 %32, %33
  br i1 %34, label %48, label %35

35:                                               ; preds = %31
  %36 = add i64 %32, %2
  %37 = load i64, i64* %10, align 8
  %38 = add i64 %37, %33
  %39 = icmp ugt i64 %36, %38
  br i1 %39, label %48, label %40

40:                                               ; preds = %35
  %41 = sub i64 %32, %33
  %42 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 0
  %43 = load i8*, i8** %42, align 8
  %44 = getelementptr inbounds i8, i8* %43, i64 %41
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 %44, i64 %2, i1 false)
  store i64 %2, i64* %3, align 8
  %45 = load i64, i64* %11, align 8
  %46 = add i64 %45, %2
  store i64 %46, i64* %11, align 8
  %47 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 19
  store i8 1, i8* %47, align 8
  br label %64

48:                                               ; preds = %35, %31
  %49 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 19
  %50 = load i8, i8* %49, align 8, !range !2
  %51 = icmp eq i8 %50, 0
  %52 = bitcast %class.QuickOpen* %0 to %class.File**
  br i1 %51, label %55, label %53

53:                                               ; preds = %48
  %54 = load %class.File*, %class.File** %52, align 8
  tail call void @_ZN4File4SeekEli(%class.File* %54, i64 %32, i32 0) #9
  store i8 0, i8* %49, align 8
  br label %55

55:                                               ; preds = %48, %53
  %56 = load %class.File*, %class.File** %52, align 8
  %57 = tail call i32 @_ZN4File4ReadEPvm(%class.File* %56, i8* %1, i64 %2) #9
  %58 = icmp slt i32 %57, 0
  br i1 %58, label %59, label %60

59:                                               ; preds = %55
  store i8 0, i8* %5, align 8
  br label %64

60:                                               ; preds = %55
  %61 = sext i32 %57 to i64
  store i64 %61, i64* %3, align 8
  %62 = load i64, i64* %11, align 8
  %63 = add i64 %62, %61
  store i64 %63, i64* %11, align 8
  br label %64

64:                                               ; preds = %40, %60, %59, %27, %23, %4
  %65 = phi i1 [ false, %4 ], [ false, %23 ], [ false, %27 ], [ false, %59 ], [ true, %60 ], [ true, %40 ]
  ret i1 %65
}

; Function Attrs: nounwind ssp uwtable
define hidden zeroext i1 @_ZN9QuickOpen8ReadNextEv(%class.QuickOpen*) local_unnamed_addr #0 align 2 {
  %2 = alloca %class.RawRead, align 8
  %3 = bitcast %class.RawRead* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 72, i8* nonnull %3) #9
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %3, i8 -86, i64 72, i1 false)
  call void @_ZN7RawReadC1EP4File(%class.RawRead* nonnull %2, %class.File* null) #9
  %4 = call zeroext i1 @_ZN9QuickOpen7ReadRawER7RawRead(%class.QuickOpen* %0, %class.RawRead* nonnull dereferenceable(72) %2)
  br i1 %4, label %5, label %28

5:                                                ; preds = %1
  %6 = call i64 @_ZN7RawRead4GetVEv(%class.RawRead* nonnull %2) #9
  %7 = call i64 @_ZN7RawRead4GetVEv(%class.RawRead* nonnull %2) #9
  %8 = call i64 @_ZN7RawRead4GetVEv(%class.RawRead* nonnull %2) #9
  %9 = icmp ugt i64 %8, 2097152
  br i1 %9, label %28, label %10

10:                                               ; preds = %5
  %11 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16
  %12 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 2
  %13 = load i64, i64* %12, align 8
  %14 = icmp ult i64 %13, %8
  %15 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 16, i32 1
  br i1 %14, label %16, label %19

16:                                               ; preds = %10
  %17 = load i64, i64* %15, align 8
  %18 = sub i64 %8, %17
  call void @_ZN5ArrayIhE3AddEm(%class.Array* %11, i64 %18) #9
  br label %20

19:                                               ; preds = %10
  store i64 %8, i64* %15, align 8
  br label %20

20:                                               ; preds = %16, %19
  %21 = getelementptr inbounds %class.Array, %class.Array* %11, i64 0, i32 0
  %22 = load i8*, i8** %21, align 8
  %23 = call i64 @_ZN7RawRead4GetBEPvm(%class.RawRead* nonnull %2, i8* %22, i64 %8) #9
  %24 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 10
  %25 = load i64, i64* %24, align 8
  %26 = sub i64 %25, %7
  %27 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 17
  store i64 %26, i64* %27, align 8
  br label %28

28:                                               ; preds = %20, %5, %1
  %29 = phi i1 [ false, %1 ], [ true, %20 ], [ false, %5 ]
  %30 = getelementptr inbounds %class.RawRead, %class.RawRead* %2, i64 0, i32 0, i32 0
  %31 = load i8*, i8** %30, align 8
  %32 = icmp eq i8* %31, null
  br i1 %32, label %43, label %33

33:                                               ; preds = %28
  %34 = getelementptr inbounds %class.RawRead, %class.RawRead* %2, i64 0, i32 0, i32 4
  %35 = load i8, i8* %34, align 8, !range !2
  %36 = icmp eq i8 %35, 0
  br i1 %36, label %41, label %37

37:                                               ; preds = %33
  %38 = getelementptr inbounds %class.RawRead, %class.RawRead* %2, i64 0, i32 0, i32 2
  %39 = load i64, i64* %38, align 8
  call void @_Z9cleandataPvm(i8* nonnull %31, i64 %39) #9
  %40 = load i8*, i8** %30, align 8
  br label %41

41:                                               ; preds = %37, %33
  %42 = phi i8* [ %31, %33 ], [ %40, %37 ]
  call void @free(i8* %42) #9
  br label %43

43:                                               ; preds = %28, %41
  call void @llvm.lifetime.end.p0i8(i64 72, i8* nonnull %3) #9
  ret i1 %29
}

declare void @_ZN4File4SeekEli(%class.File*, i64, i32) unnamed_addr #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #5

declare i32 @_ZN4File4ReadEPvm(%class.File*, i8*, i64) unnamed_addr #1

; Function Attrs: nounwind ssp uwtable
define hidden zeroext i1 @_ZN9QuickOpen4SeekEli(%class.QuickOpen*, i64, i32) local_unnamed_addr #0 align 2 {
  %4 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  %5 = load i8, i8* %4, align 8, !range !2
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %35, label %7

7:                                                ; preds = %3
  switch i32 %2, label %26 [
    i32 0, label %8
    i32 1, label %20
  ]

8:                                                ; preds = %7
  %9 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 18
  %10 = load i64, i64* %9, align 8
  %11 = icmp ugt i64 %10, %1
  br i1 %11, label %12, label %19

12:                                               ; preds = %8
  %13 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 17
  %14 = load i64, i64* %13, align 8
  %15 = icmp ugt i64 %14, %1
  br i1 %15, label %16, label %19

16:                                               ; preds = %12
  %17 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 10
  %18 = load i64, i64* %17, align 8
  tail call void @_ZN9QuickOpen4LoadEm(%class.QuickOpen* %0, i64 %18)
  br label %19

19:                                               ; preds = %16, %12, %8
  store i64 %1, i64* %9, align 8
  br label %24

20:                                               ; preds = %7
  %21 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 18
  %22 = load i64, i64* %21, align 8
  %23 = add i64 %22, %1
  store i64 %23, i64* %21, align 8
  br label %24

24:                                               ; preds = %19, %20
  %25 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 19
  store i8 1, i8* %25, align 8
  br label %35

26:                                               ; preds = %7
  %27 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 19
  store i8 1, i8* %27, align 8
  %28 = icmp eq i32 %2, 2
  br i1 %28, label %29, label %35

29:                                               ; preds = %26
  %30 = bitcast %class.QuickOpen* %0 to %class.File**
  %31 = load %class.File*, %class.File** %30, align 8
  tail call void @_ZN4File4SeekEli(%class.File* %31, i64 %1, i32 2) #9
  %32 = load %class.File*, %class.File** %30, align 8
  %33 = tail call i64 @_ZN4File4TellEv(%class.File* %32) #9
  %34 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 18
  store i64 %33, i64* %34, align 8
  store i8 0, i8* %27, align 8
  br label %35

35:                                               ; preds = %24, %26, %29, %3
  %36 = phi i1 [ false, %3 ], [ true, %29 ], [ true, %26 ], [ true, %24 ]
  ret i1 %36
}

declare i64 @_ZN4File4TellEv(%class.File*) unnamed_addr #1

; Function Attrs: nofree norecurse nounwind ssp uwtable
define hidden zeroext i1 @_ZN9QuickOpen4TellEPl(%class.QuickOpen* nocapture readonly, i64* nocapture) local_unnamed_addr #6 align 2 {
  %3 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  %4 = load i8, i8* %3, align 8, !range !2
  %5 = icmp eq i8 %4, 0
  br i1 %5, label %9, label %6

6:                                                ; preds = %2
  %7 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 18
  %8 = load i64, i64* %7, align 8
  store i64 %8, i64* %1, align 8
  br label %9

9:                                                ; preds = %2, %6
  %10 = phi i1 [ true, %6 ], [ false, %2 ]
  ret i1 %10
}

declare void @_ZN9CryptData12DecryptBlockEPhm(%class.CryptData*, i8*, i64) local_unnamed_addr #1

; Function Attrs: nounwind ssp uwtable
define hidden zeroext i1 @_ZN9QuickOpen7ReadRawER7RawRead(%class.QuickOpen*, %class.RawRead* dereferenceable(72)) local_unnamed_addr #0 align 2 {
  %3 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 15
  %4 = load i64, i64* %3, align 8
  %5 = sub i64 65536, %4
  %6 = icmp ult i64 %5, 256
  br i1 %6, label %7, label %16

7:                                                ; preds = %2
  %8 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 14
  %9 = load i64, i64* %8, align 8
  %10 = sub i64 %9, %4
  %11 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 5
  %12 = load i8*, i8** %11, align 8
  %13 = getelementptr inbounds i8, i8* %12, i64 %4
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %12, i8* align 1 %13, i64 %10, i1 false)
  store i64 0, i64* %3, align 8
  store i64 %10, i64* %8, align 8
  %14 = tail call i32 @_ZN9QuickOpen10ReadBufferEv(%class.QuickOpen* %0)
  %15 = load i64, i64* %3, align 8
  br label %16

16:                                               ; preds = %7, %2
  %17 = phi i64 [ %15, %7 ], [ %4, %2 ]
  %18 = add i64 %17, 7
  %19 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 14
  %20 = load i64, i64* %19, align 8
  %21 = icmp ugt i64 %18, %20
  br i1 %21, label %67, label %22

22:                                               ; preds = %16
  %23 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 5
  %24 = load i8*, i8** %23, align 8
  %25 = getelementptr inbounds i8, i8* %24, i64 %17
  tail call void @_ZN7RawRead4ReadEPhm(%class.RawRead* %1, i8* %25, i64 7) #9
  %26 = load i64, i64* %3, align 8
  %27 = add i64 %26, 7
  store i64 %27, i64* %3, align 8
  %28 = tail call i32 @_ZN7RawRead4Get4Ev(%class.RawRead* %1) #9
  %29 = tail call i32 @_ZN7RawRead8GetVSizeEm(%class.RawRead* %1, i64 4) #9
  %30 = tail call i64 @_ZN7RawRead4GetVEv(%class.RawRead* %1) #9
  %31 = zext i32 %29 to i64
  %32 = add nuw nsw i64 %31, 4294967293
  %33 = add i64 %32, %30
  %34 = trunc i64 %33 to i32
  %35 = icmp slt i32 %34, 0
  %36 = icmp eq i32 %29, 0
  %37 = or i1 %36, %35
  %38 = icmp eq i64 %30, 0
  %39 = or i1 %38, %37
  br i1 %39, label %44, label %40

40:                                               ; preds = %22
  %41 = icmp sgt i32 %34, 0
  br i1 %41, label %42, label %64

42:                                               ; preds = %40
  %43 = bitcast i64* %19 to i8*
  br label %46

44:                                               ; preds = %22
  %45 = getelementptr inbounds %class.QuickOpen, %class.QuickOpen* %0, i64 0, i32 8
  store i8 0, i8* %45, align 8
  br label %67

46:                                               ; preds = %61, %42
  %47 = phi i32 [ %34, %42 ], [ %59, %61 ]
  %48 = load i64, i64* %19, align 8
  %49 = load i64, i64* %3, align 8
  %50 = sub i64 %48, %49
  %51 = sext i32 %47 to i64
  %52 = icmp ult i64 %50, %51
  %53 = select i1 %52, i64 %50, i64 %51
  %54 = load i8*, i8** %23, align 8
  %55 = getelementptr inbounds i8, i8* %54, i64 %49
  tail call void @_ZN7RawRead4ReadEPhm(%class.RawRead* %1, i8* %55, i64 %53) #9
  %56 = load i64, i64* %3, align 8
  %57 = add i64 %56, %53
  store i64 %57, i64* %3, align 8
  %58 = trunc i64 %53 to i32
  %59 = sub nsw i32 %47, %58
  %60 = icmp sgt i32 %59, 0
  br i1 %60, label %61, label %64

61:                                               ; preds = %46
  call void @llvm.memset.p0i8.i64(i8* align 8 %43, i8 0, i64 16, i1 false)
  %62 = tail call i32 @_ZN9QuickOpen10ReadBufferEv(%class.QuickOpen* %0)
  %63 = icmp eq i32 %62, 0
  br i1 %63, label %67, label %46

64:                                               ; preds = %46, %40
  %65 = tail call i32 @_ZN7RawRead8GetCRC50Ev(%class.RawRead* %1) #9
  %66 = icmp eq i32 %28, %65
  br label %67

67:                                               ; preds = %61, %44, %64, %16
  %68 = phi i1 [ false, %16 ], [ false, %44 ], [ %66, %64 ], [ false, %61 ]
  ret i1 %68
}

declare void @_ZN7RawRead4ReadEPhm(%class.RawRead*, i8*, i64) local_unnamed_addr #1

declare i32 @_ZN7RawRead4Get4Ev(%class.RawRead*) local_unnamed_addr #1

declare i32 @_ZN7RawRead8GetVSizeEm(%class.RawRead*, i64) local_unnamed_addr #1

declare i64 @_ZN7RawRead4GetVEv(%class.RawRead*) local_unnamed_addr #1

declare i32 @_ZN7RawRead8GetCRC50Ev(%class.RawRead*) local_unnamed_addr #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #5

declare void @_ZN7RawReadC1EP4File(%class.RawRead*, %class.File*) unnamed_addr #1

declare i64 @_ZN7RawRead4GetBEPvm(%class.RawRead*, i8*, i64) local_unnamed_addr #1

; Function Attrs: nounwind readonly
declare i32 @wcscmp(i32*, i32*) local_unnamed_addr #7

declare void @_Z9cleandataPvm(i8*, i64) local_unnamed_addr #1

; Function Attrs: nounwind
declare void @free(i8* nocapture) local_unnamed_addr #3

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZN5ArrayIhE3AddEm(%class.Array*, i64) local_unnamed_addr #0 comdat align 2 {
  %3 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 1
  %4 = load i64, i64* %3, align 8
  %5 = add i64 %4, %1
  store i64 %5, i64* %3, align 8
  %6 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 2
  %7 = load i64, i64* %6, align 8
  %8 = icmp ugt i64 %5, %7
  br i1 %8, label %9, label %49

9:                                                ; preds = %2
  %10 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 3
  %11 = load i64, i64* %10, align 8
  %12 = icmp ne i64 %11, 0
  %13 = icmp ugt i64 %5, %11
  %14 = and i1 %12, %13
  br i1 %14, label %15, label %18

15:                                               ; preds = %9
  tail call void (%class.ErrorHandler*, i32*, ...) @_ZN12ErrorHandler13GeneralErrMsgEPKwz(%class.ErrorHandler* nonnull @ErrHandler, i32* getelementptr inbounds ([44 x i32], [44 x i32]* @.str.1, i64 0, i64 0), i64 %11) #9
  tail call void @_ZN12ErrorHandler11MemoryErrorEv(%class.ErrorHandler* nonnull @ErrHandler) #9
  %16 = load i64, i64* %6, align 8
  %17 = load i64, i64* %3, align 8
  br label %18

18:                                               ; preds = %9, %15
  %19 = phi i64 [ %5, %9 ], [ %17, %15 ]
  %20 = phi i64 [ %7, %9 ], [ %16, %15 ]
  %21 = lshr i64 %20, 2
  %22 = add i64 %20, 32
  %23 = add i64 %22, %21
  %24 = icmp ugt i64 %19, %23
  %25 = select i1 %24, i64 %19, i64 %23
  %26 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 4
  %27 = load i8, i8* %26, align 8, !range !2
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %40, label %29

29:                                               ; preds = %18
  %30 = tail call noalias i8* @malloc(i64 %25) #9
  %31 = icmp eq i8* %30, null
  br i1 %31, label %32, label %33

32:                                               ; preds = %29
  tail call void @_ZN12ErrorHandler11MemoryErrorEv(%class.ErrorHandler* nonnull @ErrHandler) #9
  br label %33

33:                                               ; preds = %32, %29
  %34 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 0
  %35 = load i8*, i8** %34, align 8
  %36 = icmp eq i8* %35, null
  br i1 %36, label %46, label %37

37:                                               ; preds = %33
  %38 = load i64, i64* %6, align 8
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %30, i8* nonnull align 1 %35, i64 %38, i1 false)
  tail call void @_Z9cleandataPvm(i8* nonnull %35, i64 %38) #9
  %39 = load i8*, i8** %34, align 8
  tail call void @free(i8* %39) #9
  br label %46

40:                                               ; preds = %18
  %41 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 0
  %42 = load i8*, i8** %41, align 8
  %43 = tail call i8* @realloc(i8* %42, i64 %25) #9
  %44 = icmp eq i8* %43, null
  br i1 %44, label %45, label %46

45:                                               ; preds = %40
  tail call void @_ZN12ErrorHandler11MemoryErrorEv(%class.ErrorHandler* nonnull @ErrHandler) #9
  br label %46

46:                                               ; preds = %33, %40, %45, %37
  %47 = phi i8* [ %30, %37 ], [ %30, %33 ], [ null, %45 ], [ %43, %40 ]
  %48 = getelementptr inbounds %class.Array, %class.Array* %0, i64 0, i32 0
  store i8* %47, i8** %48, align 8
  store i64 %25, i64* %6, align 8
  br label %49

49:                                               ; preds = %46, %2
  ret void
}

declare void @_ZN12ErrorHandler13GeneralErrMsgEPKwz(%class.ErrorHandler*, i32*, ...) local_unnamed_addr #1

declare void @_ZN12ErrorHandler11MemoryErrorEv(%class.ErrorHandler*) local_unnamed_addr #1

; Function Attrs: nofree nounwind
declare noalias i8* @malloc(i64) local_unnamed_addr #8

; Function Attrs: nounwind
declare noalias i8* @realloc(i8* nocapture, i64) local_unnamed_addr #3

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nobuiltin nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nobuiltin nofree "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind }
attributes #6 = { nofree norecurse nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nofree nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind }
attributes #10 = { builtin nounwind }
attributes #11 = { nounwind readonly }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{i8 0, i8 2}
