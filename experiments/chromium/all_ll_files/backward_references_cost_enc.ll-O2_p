; ModuleID = '../../third_party/libwebp/src/enc/backward_references_cost_enc.c'
source_filename = "../../third_party/libwebp/src/enc/backward_references_cost_enc.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.VP8LPrefixCode = type { i8, i8 }
%struct.VP8LHashChain = type { i32*, i32 }
%struct.VP8LBackwardRefs = type { i32, i32, %struct.PixOrCopyBlock*, %struct.PixOrCopyBlock**, %struct.PixOrCopyBlock*, %struct.PixOrCopyBlock* }
%struct.PixOrCopyBlock = type opaque
%struct.VP8LColorCache = type { i32*, i32, i32 }
%struct.VP8LRefsCursor = type { %struct.PixOrCopy*, %struct.PixOrCopyBlock*, %struct.PixOrCopy* }
%struct.PixOrCopy = type { i8, i16, i32 }
%struct.CostModel = type { [256 x double], [256 x double], [256 x double], [40 x double], double* }
%struct.CostManager = type { %struct.CostInterval*, i32, %struct.CostCacheInterval*, i64, [4095 x double], float*, i16*, [10 x %struct.CostInterval], %struct.CostInterval*, %struct.CostInterval* }
%struct.CostCacheInterval = type { double, i32, i32 }
%struct.CostInterval = type { float, i32, i32, i32, %struct.CostInterval*, %struct.CostInterval* }
%struct.VP8LHistogram = type { i32*, [256 x i32], [256 x i32], [256 x i32], [40 x i32], i32, i32, double, double, double, double, [5 x i8] }

@kLog2Table = external local_unnamed_addr constant [256 x float], align 16
@VP8LFastLog2Slow = external local_unnamed_addr global float (i32)*, align 8
@kPrefixEncodeCode = external local_unnamed_addr constant [512 x %struct.VP8LPrefixCode], align 16

; Function Attrs: nounwind ssp uwtable
define hidden i32 @VP8LBackwardReferencesTraceBackwards(i32, i32, i32* nocapture readonly, i32, %struct.VP8LHashChain* nocapture readonly, %struct.VP8LBackwardRefs*, %struct.VP8LBackwardRefs*) local_unnamed_addr #0 {
  %8 = alloca %struct.VP8LColorCache, align 8
  %9 = alloca %struct.VP8LRefsCursor, align 8
  %10 = alloca %struct.VP8LColorCache, align 8
  %11 = mul i32 %1, %0
  %12 = sext i32 %11 to i64
  %13 = tail call i8* @WebPSafeMalloc(i64 %12, i64 2) #5
  %14 = bitcast i8* %13 to i16*
  %15 = icmp eq i8* %13, null
  br i1 %15, label %1450, label %16

16:                                               ; preds = %7
  %17 = icmp sgt i32 %3, 0
  %18 = shl i32 1, %3
  %19 = add i32 %18, 280
  %20 = select i1 %17, i32 %19, i32 280
  %21 = sext i32 %20 to i64
  %22 = shl nsw i64 %21, 3
  %23 = add nsw i64 %22, 6472
  %24 = tail call i8* @WebPSafeCalloc(i64 1, i64 %23) #5
  %25 = bitcast i8* %24 to %struct.CostModel*
  %26 = bitcast %struct.VP8LColorCache* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %26) #5
  %27 = getelementptr inbounds %struct.VP8LColorCache, %struct.VP8LColorCache* %10, i64 0, i32 0
  %28 = getelementptr inbounds %struct.VP8LColorCache, %struct.VP8LColorCache* %10, i64 0, i32 1
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %26, i8 -86, i64 16, i1 false) #5
  %29 = tail call i8* @WebPSafeMalloc(i64 1, i64 33144) #5
  %30 = bitcast i8* %29 to %struct.CostManager*
  %31 = icmp eq i8* %24, null
  %32 = icmp eq i8* %29, null
  %33 = or i1 %31, %32
  br i1 %33, label %1225, label %34

34:                                               ; preds = %16
  %35 = getelementptr inbounds i8, i8* %24, i64 6472
  %36 = getelementptr inbounds i8, i8* %24, i64 6464
  %37 = bitcast i8* %36 to i8**
  store i8* %35, i8** %37, align 8
  br i1 %17, label %38, label %41

38:                                               ; preds = %34
  %39 = call i32 @VP8LColorCacheInit(%struct.VP8LColorCache* nonnull %10, i32 %3) #5
  %40 = icmp eq i32 %39, 0
  br i1 %40, label %1225, label %41

41:                                               ; preds = %38, %34
  %42 = phi i32 [ %39, %38 ], [ 0, %34 ]
  %43 = bitcast %struct.VP8LRefsCursor* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %43) #5
  %44 = getelementptr inbounds %struct.VP8LRefsCursor, %struct.VP8LRefsCursor* %9, i64 0, i32 0
  %45 = getelementptr inbounds %struct.VP8LRefsCursor, %struct.VP8LRefsCursor* %9, i64 0, i32 2
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %43, i8 -86, i64 24, i1 false) #5
  call void @VP8LRefsCursorInit(%struct.VP8LRefsCursor* nonnull sret %9, %struct.VP8LBackwardRefs* %5) #5
  %46 = call %struct.VP8LHistogram* @VP8LAllocateHistogram(i32 %3) #5
  %47 = icmp eq %struct.VP8LHistogram* %46, null
  br i1 %47, label %1220, label %48

48:                                               ; preds = %41
  call void @VP8LHistogramInit(%struct.VP8LHistogram* nonnull %46, i32 %3, i32 1) #5
  %49 = load %struct.PixOrCopy*, %struct.PixOrCopy** %44, align 8
  %50 = icmp eq %struct.PixOrCopy* %49, null
  br i1 %50, label %62, label %51

51:                                               ; preds = %48, %59
  %52 = phi %struct.PixOrCopy* [ %60, %59 ], [ %49, %48 ]
  call void @VP8LHistogramAddSinglePixOrCopy(%struct.VP8LHistogram* nonnull %46, %struct.PixOrCopy* nonnull %52, i32 (i32, i32)* nonnull @VP8LDistanceToPlaneCode, i32 %0) #5
  %53 = load %struct.PixOrCopy*, %struct.PixOrCopy** %44, align 8
  %54 = getelementptr inbounds %struct.PixOrCopy, %struct.PixOrCopy* %53, i64 1
  store %struct.PixOrCopy* %54, %struct.PixOrCopy** %44, align 8
  %55 = load %struct.PixOrCopy*, %struct.PixOrCopy** %45, align 8
  %56 = icmp eq %struct.PixOrCopy* %54, %55
  br i1 %56, label %57, label %59

57:                                               ; preds = %51
  call void @VP8LRefsCursorNextBlock(%struct.VP8LRefsCursor* nonnull %9) #5
  %58 = load %struct.PixOrCopy*, %struct.PixOrCopy** %44, align 8
  br label %59

59:                                               ; preds = %57, %51
  %60 = phi %struct.PixOrCopy* [ %54, %51 ], [ %58, %57 ]
  %61 = icmp eq %struct.PixOrCopy* %60, null
  br i1 %61, label %62, label %51

62:                                               ; preds = %59, %48
  %63 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 5
  %64 = load i32, i32* %63, align 8
  %65 = icmp sgt i32 %64, 0
  %66 = shl i32 1, %64
  %67 = add i32 %66, 280
  %68 = select i1 %65, i32 %67, i32 280
  %69 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 0
  %70 = load i32*, i32** %69, align 8
  %71 = bitcast i8* %36 to double**
  %72 = load double*, double** %71, align 8
  %73 = icmp sgt i32 %68, 0
  br i1 %73, label %74, label %189

74:                                               ; preds = %62
  %75 = zext i32 %68 to i64
  %76 = icmp ult i32 %68, 8
  br i1 %76, label %169, label %77

77:                                               ; preds = %74
  %78 = and i64 %75, 4294967288
  %79 = add nsw i64 %78, -8
  %80 = lshr exact i64 %79, 3
  %81 = add nuw nsw i64 %80, 1
  %82 = and i64 %81, 1
  %83 = icmp eq i64 %79, 0
  br i1 %83, label %125, label %84

84:                                               ; preds = %77
  %85 = sub nuw nsw i64 %81, %82
  br label %86

86:                                               ; preds = %86, %84
  %87 = phi i64 [ 0, %84 ], [ %122, %86 ]
  %88 = phi <4 x i32> [ zeroinitializer, %84 ], [ %120, %86 ]
  %89 = phi <4 x i32> [ zeroinitializer, %84 ], [ %121, %86 ]
  %90 = phi <4 x i32> [ zeroinitializer, %84 ], [ %114, %86 ]
  %91 = phi <4 x i32> [ zeroinitializer, %84 ], [ %115, %86 ]
  %92 = phi i64 [ %85, %84 ], [ %123, %86 ]
  %93 = getelementptr inbounds i32, i32* %70, i64 %87
  %94 = bitcast i32* %93 to <4 x i32>*
  %95 = load <4 x i32>, <4 x i32>* %94, align 4
  %96 = getelementptr inbounds i32, i32* %93, i64 4
  %97 = bitcast i32* %96 to <4 x i32>*
  %98 = load <4 x i32>, <4 x i32>* %97, align 4
  %99 = add <4 x i32> %95, %90
  %100 = add <4 x i32> %98, %91
  %101 = icmp ne <4 x i32> %95, zeroinitializer
  %102 = icmp ne <4 x i32> %98, zeroinitializer
  %103 = zext <4 x i1> %101 to <4 x i32>
  %104 = zext <4 x i1> %102 to <4 x i32>
  %105 = add nuw nsw <4 x i32> %88, %103
  %106 = add nuw nsw <4 x i32> %89, %104
  %107 = or i64 %87, 8
  %108 = getelementptr inbounds i32, i32* %70, i64 %107
  %109 = bitcast i32* %108 to <4 x i32>*
  %110 = load <4 x i32>, <4 x i32>* %109, align 4
  %111 = getelementptr inbounds i32, i32* %108, i64 4
  %112 = bitcast i32* %111 to <4 x i32>*
  %113 = load <4 x i32>, <4 x i32>* %112, align 4
  %114 = add <4 x i32> %110, %99
  %115 = add <4 x i32> %113, %100
  %116 = icmp ne <4 x i32> %110, zeroinitializer
  %117 = icmp ne <4 x i32> %113, zeroinitializer
  %118 = zext <4 x i1> %116 to <4 x i32>
  %119 = zext <4 x i1> %117 to <4 x i32>
  %120 = add nuw nsw <4 x i32> %105, %118
  %121 = add nuw nsw <4 x i32> %106, %119
  %122 = add i64 %87, 16
  %123 = add i64 %92, -2
  %124 = icmp eq i64 %123, 0
  br i1 %124, label %125, label %86, !llvm.loop !2

125:                                              ; preds = %86, %77
  %126 = phi <4 x i32> [ undef, %77 ], [ %114, %86 ]
  %127 = phi <4 x i32> [ undef, %77 ], [ %115, %86 ]
  %128 = phi <4 x i32> [ undef, %77 ], [ %120, %86 ]
  %129 = phi <4 x i32> [ undef, %77 ], [ %121, %86 ]
  %130 = phi i64 [ 0, %77 ], [ %122, %86 ]
  %131 = phi <4 x i32> [ zeroinitializer, %77 ], [ %120, %86 ]
  %132 = phi <4 x i32> [ zeroinitializer, %77 ], [ %121, %86 ]
  %133 = phi <4 x i32> [ zeroinitializer, %77 ], [ %114, %86 ]
  %134 = phi <4 x i32> [ zeroinitializer, %77 ], [ %115, %86 ]
  %135 = icmp eq i64 %82, 0
  br i1 %135, label %151, label %136

136:                                              ; preds = %125
  %137 = getelementptr inbounds i32, i32* %70, i64 %130
  %138 = bitcast i32* %137 to <4 x i32>*
  %139 = load <4 x i32>, <4 x i32>* %138, align 4
  %140 = getelementptr inbounds i32, i32* %137, i64 4
  %141 = bitcast i32* %140 to <4 x i32>*
  %142 = load <4 x i32>, <4 x i32>* %141, align 4
  %143 = icmp ne <4 x i32> %142, zeroinitializer
  %144 = zext <4 x i1> %143 to <4 x i32>
  %145 = add nuw nsw <4 x i32> %132, %144
  %146 = icmp ne <4 x i32> %139, zeroinitializer
  %147 = zext <4 x i1> %146 to <4 x i32>
  %148 = add nuw nsw <4 x i32> %131, %147
  %149 = add <4 x i32> %142, %134
  %150 = add <4 x i32> %139, %133
  br label %151

151:                                              ; preds = %125, %136
  %152 = phi <4 x i32> [ %126, %125 ], [ %150, %136 ]
  %153 = phi <4 x i32> [ %127, %125 ], [ %149, %136 ]
  %154 = phi <4 x i32> [ %128, %125 ], [ %148, %136 ]
  %155 = phi <4 x i32> [ %129, %125 ], [ %145, %136 ]
  %156 = add <4 x i32> %153, %152
  %157 = shufflevector <4 x i32> %156, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %158 = add <4 x i32> %156, %157
  %159 = shufflevector <4 x i32> %158, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %160 = add <4 x i32> %158, %159
  %161 = extractelement <4 x i32> %160, i32 0
  %162 = add nuw <4 x i32> %155, %154
  %163 = shufflevector <4 x i32> %162, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %164 = add <4 x i32> %162, %163
  %165 = shufflevector <4 x i32> %164, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %166 = add <4 x i32> %164, %165
  %167 = extractelement <4 x i32> %166, i32 0
  %168 = icmp eq i64 %78, %75
  br i1 %168, label %185, label %169

169:                                              ; preds = %151, %74
  %170 = phi i64 [ 0, %74 ], [ %78, %151 ]
  %171 = phi i32 [ 0, %74 ], [ %167, %151 ]
  %172 = phi i32 [ 0, %74 ], [ %161, %151 ]
  br label %173

173:                                              ; preds = %169, %173
  %174 = phi i64 [ %183, %173 ], [ %170, %169 ]
  %175 = phi i32 [ %182, %173 ], [ %171, %169 ]
  %176 = phi i32 [ %179, %173 ], [ %172, %169 ]
  %177 = getelementptr inbounds i32, i32* %70, i64 %174
  %178 = load i32, i32* %177, align 4
  %179 = add i32 %178, %176
  %180 = icmp ne i32 %178, 0
  %181 = zext i1 %180 to i32
  %182 = add nuw nsw i32 %175, %181
  %183 = add nuw nsw i64 %174, 1
  %184 = icmp eq i64 %183, %75
  br i1 %184, label %185, label %173, !llvm.loop !4

185:                                              ; preds = %173, %151
  %186 = phi i32 [ %161, %151 ], [ %179, %173 ]
  %187 = phi i32 [ %167, %151 ], [ %182, %173 ]
  %188 = icmp ult i32 %187, 2
  br i1 %188, label %189, label %193

189:                                              ; preds = %185, %62
  %190 = bitcast double* %72 to i8*
  %191 = sext i32 %68 to i64
  %192 = shl nsw i64 %191, 3
  call void @llvm.memset.p0i8.i64(i8* align 8 %190, i8 0, i64 %192, i1 false) #5
  br label %224

193:                                              ; preds = %185
  %194 = icmp ult i32 %186, 256
  br i1 %194, label %195, label %199

195:                                              ; preds = %193
  %196 = zext i32 %186 to i64
  %197 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %196
  %198 = load float, float* %197, align 4
  br label %202

199:                                              ; preds = %193
  %200 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %201 = call float %200(i32 %186) #5
  br label %202

202:                                              ; preds = %199, %195
  %203 = phi float [ %198, %195 ], [ %201, %199 ]
  %204 = fpext float %203 to double
  br label %205

205:                                              ; preds = %217, %202
  %206 = phi i64 [ 0, %202 ], [ %222, %217 ]
  %207 = getelementptr inbounds i32, i32* %70, i64 %206
  %208 = load i32, i32* %207, align 4
  %209 = icmp ult i32 %208, 256
  br i1 %209, label %210, label %214

210:                                              ; preds = %205
  %211 = zext i32 %208 to i64
  %212 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %211
  %213 = load float, float* %212, align 4
  br label %217

214:                                              ; preds = %205
  %215 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %216 = call float %215(i32 %208) #5
  br label %217

217:                                              ; preds = %214, %210
  %218 = phi float [ %213, %210 ], [ %216, %214 ]
  %219 = fpext float %218 to double
  %220 = fsub double %204, %219
  %221 = getelementptr inbounds double, double* %72, i64 %206
  store double %220, double* %221, align 8
  %222 = add nuw nsw i64 %206, 1
  %223 = icmp eq i64 %222, %75
  br i1 %223, label %224, label %205

224:                                              ; preds = %217, %189
  br label %225

225:                                              ; preds = %225, %224
  %226 = phi i64 [ 0, %224 ], [ %260, %225 ]
  %227 = phi <4 x i32> [ zeroinitializer, %224 ], [ %258, %225 ]
  %228 = phi <4 x i32> [ zeroinitializer, %224 ], [ %259, %225 ]
  %229 = phi <4 x i32> [ zeroinitializer, %224 ], [ %252, %225 ]
  %230 = phi <4 x i32> [ zeroinitializer, %224 ], [ %253, %225 ]
  %231 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 1, i64 %226
  %232 = bitcast i32* %231 to <4 x i32>*
  %233 = load <4 x i32>, <4 x i32>* %232, align 4
  %234 = getelementptr inbounds i32, i32* %231, i64 4
  %235 = bitcast i32* %234 to <4 x i32>*
  %236 = load <4 x i32>, <4 x i32>* %235, align 4
  %237 = add <4 x i32> %233, %229
  %238 = add <4 x i32> %236, %230
  %239 = icmp ne <4 x i32> %233, zeroinitializer
  %240 = icmp ne <4 x i32> %236, zeroinitializer
  %241 = zext <4 x i1> %239 to <4 x i32>
  %242 = zext <4 x i1> %240 to <4 x i32>
  %243 = add nuw nsw <4 x i32> %227, %241
  %244 = add nuw nsw <4 x i32> %228, %242
  %245 = or i64 %226, 8
  %246 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 1, i64 %245
  %247 = bitcast i32* %246 to <4 x i32>*
  %248 = load <4 x i32>, <4 x i32>* %247, align 4
  %249 = getelementptr inbounds i32, i32* %246, i64 4
  %250 = bitcast i32* %249 to <4 x i32>*
  %251 = load <4 x i32>, <4 x i32>* %250, align 4
  %252 = add <4 x i32> %248, %237
  %253 = add <4 x i32> %251, %238
  %254 = icmp ne <4 x i32> %248, zeroinitializer
  %255 = icmp ne <4 x i32> %251, zeroinitializer
  %256 = zext <4 x i1> %254 to <4 x i32>
  %257 = zext <4 x i1> %255 to <4 x i32>
  %258 = add nuw nsw <4 x i32> %243, %256
  %259 = add nuw nsw <4 x i32> %244, %257
  %260 = add nuw nsw i64 %226, 16
  %261 = icmp eq i64 %260, 256
  br i1 %261, label %262, label %225, !llvm.loop !6

262:                                              ; preds = %225
  %263 = add <4 x i32> %253, %252
  %264 = shufflevector <4 x i32> %263, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %265 = add <4 x i32> %263, %264
  %266 = shufflevector <4 x i32> %265, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %267 = add <4 x i32> %265, %266
  %268 = extractelement <4 x i32> %267, i32 0
  %269 = add nuw <4 x i32> %259, %258
  %270 = shufflevector <4 x i32> %269, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %271 = add <4 x i32> %269, %270
  %272 = shufflevector <4 x i32> %271, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %273 = add <4 x i32> %271, %272
  %274 = extractelement <4 x i32> %273, i32 0
  %275 = icmp ult i32 %274, 2
  br i1 %275, label %276, label %278

276:                                              ; preds = %262
  %277 = getelementptr inbounds i8, i8* %24, i64 2048
  call void @llvm.memset.p0i8.i64(i8* align 8 %277, i8 0, i64 2048, i1 false) #5
  br label %309

278:                                              ; preds = %262
  %279 = icmp ult i32 %268, 256
  br i1 %279, label %280, label %284

280:                                              ; preds = %278
  %281 = zext i32 %268 to i64
  %282 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %281
  %283 = load float, float* %282, align 4
  br label %287

284:                                              ; preds = %278
  %285 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %286 = call float %285(i32 %268) #5
  br label %287

287:                                              ; preds = %284, %280
  %288 = phi float [ %283, %280 ], [ %286, %284 ]
  %289 = fpext float %288 to double
  br label %290

290:                                              ; preds = %302, %287
  %291 = phi i64 [ 0, %287 ], [ %307, %302 ]
  %292 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 1, i64 %291
  %293 = load i32, i32* %292, align 4
  %294 = icmp ult i32 %293, 256
  br i1 %294, label %295, label %299

295:                                              ; preds = %290
  %296 = zext i32 %293 to i64
  %297 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %296
  %298 = load float, float* %297, align 4
  br label %302

299:                                              ; preds = %290
  %300 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %301 = call float %300(i32 %293) #5
  br label %302

302:                                              ; preds = %299, %295
  %303 = phi float [ %298, %295 ], [ %301, %299 ]
  %304 = fpext float %303 to double
  %305 = fsub double %289, %304
  %306 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 1, i64 %291
  store double %305, double* %306, align 8
  %307 = add nuw nsw i64 %291, 1
  %308 = icmp eq i64 %307, 256
  br i1 %308, label %309, label %290

309:                                              ; preds = %302, %276
  br label %310

310:                                              ; preds = %310, %309
  %311 = phi i64 [ 0, %309 ], [ %345, %310 ]
  %312 = phi <4 x i32> [ zeroinitializer, %309 ], [ %343, %310 ]
  %313 = phi <4 x i32> [ zeroinitializer, %309 ], [ %344, %310 ]
  %314 = phi <4 x i32> [ zeroinitializer, %309 ], [ %337, %310 ]
  %315 = phi <4 x i32> [ zeroinitializer, %309 ], [ %338, %310 ]
  %316 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 2, i64 %311
  %317 = bitcast i32* %316 to <4 x i32>*
  %318 = load <4 x i32>, <4 x i32>* %317, align 4
  %319 = getelementptr inbounds i32, i32* %316, i64 4
  %320 = bitcast i32* %319 to <4 x i32>*
  %321 = load <4 x i32>, <4 x i32>* %320, align 4
  %322 = add <4 x i32> %318, %314
  %323 = add <4 x i32> %321, %315
  %324 = icmp ne <4 x i32> %318, zeroinitializer
  %325 = icmp ne <4 x i32> %321, zeroinitializer
  %326 = zext <4 x i1> %324 to <4 x i32>
  %327 = zext <4 x i1> %325 to <4 x i32>
  %328 = add nuw nsw <4 x i32> %312, %326
  %329 = add nuw nsw <4 x i32> %313, %327
  %330 = or i64 %311, 8
  %331 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 2, i64 %330
  %332 = bitcast i32* %331 to <4 x i32>*
  %333 = load <4 x i32>, <4 x i32>* %332, align 4
  %334 = getelementptr inbounds i32, i32* %331, i64 4
  %335 = bitcast i32* %334 to <4 x i32>*
  %336 = load <4 x i32>, <4 x i32>* %335, align 4
  %337 = add <4 x i32> %333, %322
  %338 = add <4 x i32> %336, %323
  %339 = icmp ne <4 x i32> %333, zeroinitializer
  %340 = icmp ne <4 x i32> %336, zeroinitializer
  %341 = zext <4 x i1> %339 to <4 x i32>
  %342 = zext <4 x i1> %340 to <4 x i32>
  %343 = add nuw nsw <4 x i32> %328, %341
  %344 = add nuw nsw <4 x i32> %329, %342
  %345 = add nuw nsw i64 %311, 16
  %346 = icmp eq i64 %345, 256
  br i1 %346, label %347, label %310, !llvm.loop !7

347:                                              ; preds = %310
  %348 = add <4 x i32> %338, %337
  %349 = shufflevector <4 x i32> %348, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %350 = add <4 x i32> %348, %349
  %351 = shufflevector <4 x i32> %350, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %352 = add <4 x i32> %350, %351
  %353 = extractelement <4 x i32> %352, i32 0
  %354 = add nuw <4 x i32> %344, %343
  %355 = shufflevector <4 x i32> %354, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %356 = add <4 x i32> %354, %355
  %357 = shufflevector <4 x i32> %356, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %358 = add <4 x i32> %356, %357
  %359 = extractelement <4 x i32> %358, i32 0
  %360 = icmp ult i32 %359, 2
  br i1 %360, label %361, label %363

361:                                              ; preds = %347
  %362 = getelementptr inbounds i8, i8* %24, i64 4096
  call void @llvm.memset.p0i8.i64(i8* align 8 %362, i8 0, i64 2048, i1 false) #5
  br label %394

363:                                              ; preds = %347
  %364 = icmp ult i32 %353, 256
  br i1 %364, label %365, label %369

365:                                              ; preds = %363
  %366 = zext i32 %353 to i64
  %367 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %366
  %368 = load float, float* %367, align 4
  br label %372

369:                                              ; preds = %363
  %370 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %371 = call float %370(i32 %353) #5
  br label %372

372:                                              ; preds = %369, %365
  %373 = phi float [ %368, %365 ], [ %371, %369 ]
  %374 = fpext float %373 to double
  br label %375

375:                                              ; preds = %387, %372
  %376 = phi i64 [ 0, %372 ], [ %392, %387 ]
  %377 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 2, i64 %376
  %378 = load i32, i32* %377, align 4
  %379 = icmp ult i32 %378, 256
  br i1 %379, label %380, label %384

380:                                              ; preds = %375
  %381 = zext i32 %378 to i64
  %382 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %381
  %383 = load float, float* %382, align 4
  br label %387

384:                                              ; preds = %375
  %385 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %386 = call float %385(i32 %378) #5
  br label %387

387:                                              ; preds = %384, %380
  %388 = phi float [ %383, %380 ], [ %386, %384 ]
  %389 = fpext float %388 to double
  %390 = fsub double %374, %389
  %391 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 2, i64 %376
  store double %390, double* %391, align 8
  %392 = add nuw nsw i64 %376, 1
  %393 = icmp eq i64 %392, 256
  br i1 %393, label %394, label %375

394:                                              ; preds = %387, %361
  br label %395

395:                                              ; preds = %395, %394
  %396 = phi i64 [ 0, %394 ], [ %430, %395 ]
  %397 = phi <4 x i32> [ zeroinitializer, %394 ], [ %428, %395 ]
  %398 = phi <4 x i32> [ zeroinitializer, %394 ], [ %429, %395 ]
  %399 = phi <4 x i32> [ zeroinitializer, %394 ], [ %422, %395 ]
  %400 = phi <4 x i32> [ zeroinitializer, %394 ], [ %423, %395 ]
  %401 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 3, i64 %396
  %402 = bitcast i32* %401 to <4 x i32>*
  %403 = load <4 x i32>, <4 x i32>* %402, align 4
  %404 = getelementptr inbounds i32, i32* %401, i64 4
  %405 = bitcast i32* %404 to <4 x i32>*
  %406 = load <4 x i32>, <4 x i32>* %405, align 4
  %407 = add <4 x i32> %403, %399
  %408 = add <4 x i32> %406, %400
  %409 = icmp ne <4 x i32> %403, zeroinitializer
  %410 = icmp ne <4 x i32> %406, zeroinitializer
  %411 = zext <4 x i1> %409 to <4 x i32>
  %412 = zext <4 x i1> %410 to <4 x i32>
  %413 = add nuw nsw <4 x i32> %397, %411
  %414 = add nuw nsw <4 x i32> %398, %412
  %415 = or i64 %396, 8
  %416 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 3, i64 %415
  %417 = bitcast i32* %416 to <4 x i32>*
  %418 = load <4 x i32>, <4 x i32>* %417, align 4
  %419 = getelementptr inbounds i32, i32* %416, i64 4
  %420 = bitcast i32* %419 to <4 x i32>*
  %421 = load <4 x i32>, <4 x i32>* %420, align 4
  %422 = add <4 x i32> %418, %407
  %423 = add <4 x i32> %421, %408
  %424 = icmp ne <4 x i32> %418, zeroinitializer
  %425 = icmp ne <4 x i32> %421, zeroinitializer
  %426 = zext <4 x i1> %424 to <4 x i32>
  %427 = zext <4 x i1> %425 to <4 x i32>
  %428 = add nuw nsw <4 x i32> %413, %426
  %429 = add nuw nsw <4 x i32> %414, %427
  %430 = add nuw nsw i64 %396, 16
  %431 = icmp eq i64 %430, 256
  br i1 %431, label %432, label %395, !llvm.loop !8

432:                                              ; preds = %395
  %433 = add <4 x i32> %423, %422
  %434 = shufflevector <4 x i32> %433, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %435 = add <4 x i32> %433, %434
  %436 = shufflevector <4 x i32> %435, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %437 = add <4 x i32> %435, %436
  %438 = extractelement <4 x i32> %437, i32 0
  %439 = add nuw <4 x i32> %429, %428
  %440 = shufflevector <4 x i32> %439, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %441 = add <4 x i32> %439, %440
  %442 = shufflevector <4 x i32> %441, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %443 = add <4 x i32> %441, %442
  %444 = extractelement <4 x i32> %443, i32 0
  %445 = icmp ult i32 %444, 2
  br i1 %445, label %446, label %447

446:                                              ; preds = %432
  call void @llvm.memset.p0i8.i64(i8* align 8 %24, i8 0, i64 2048, i1 false) #5
  br label %478

447:                                              ; preds = %432
  %448 = icmp ult i32 %438, 256
  br i1 %448, label %449, label %453

449:                                              ; preds = %447
  %450 = zext i32 %438 to i64
  %451 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %450
  %452 = load float, float* %451, align 4
  br label %456

453:                                              ; preds = %447
  %454 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %455 = call float %454(i32 %438) #5
  br label %456

456:                                              ; preds = %453, %449
  %457 = phi float [ %452, %449 ], [ %455, %453 ]
  %458 = fpext float %457 to double
  br label %459

459:                                              ; preds = %471, %456
  %460 = phi i64 [ 0, %456 ], [ %476, %471 ]
  %461 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 3, i64 %460
  %462 = load i32, i32* %461, align 4
  %463 = icmp ult i32 %462, 256
  br i1 %463, label %464, label %468

464:                                              ; preds = %459
  %465 = zext i32 %462 to i64
  %466 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %465
  %467 = load float, float* %466, align 4
  br label %471

468:                                              ; preds = %459
  %469 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %470 = call float %469(i32 %462) #5
  br label %471

471:                                              ; preds = %468, %464
  %472 = phi float [ %467, %464 ], [ %470, %468 ]
  %473 = fpext float %472 to double
  %474 = fsub double %458, %473
  %475 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 0, i64 %460
  store double %474, double* %475, align 8
  %476 = add nuw nsw i64 %460, 1
  %477 = icmp eq i64 %476, 256
  br i1 %477, label %478, label %459

478:                                              ; preds = %446, %471
  %479 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 0
  %480 = bitcast i32* %479 to <4 x i32>*
  %481 = load <4 x i32>, <4 x i32>* %480, align 4
  %482 = icmp ne <4 x i32> %481, zeroinitializer
  %483 = zext <4 x i1> %482 to <4 x i32>
  %484 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 4
  %485 = bitcast i32* %484 to <4 x i32>*
  %486 = load <4 x i32>, <4 x i32>* %485, align 4
  %487 = add <4 x i32> %486, %481
  %488 = icmp ne <4 x i32> %486, zeroinitializer
  %489 = zext <4 x i1> %488 to <4 x i32>
  %490 = add nuw nsw <4 x i32> %483, %489
  %491 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 8
  %492 = bitcast i32* %491 to <4 x i32>*
  %493 = load <4 x i32>, <4 x i32>* %492, align 4
  %494 = add <4 x i32> %493, %487
  %495 = icmp ne <4 x i32> %493, zeroinitializer
  %496 = zext <4 x i1> %495 to <4 x i32>
  %497 = add nuw nsw <4 x i32> %490, %496
  %498 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 12
  %499 = bitcast i32* %498 to <4 x i32>*
  %500 = load <4 x i32>, <4 x i32>* %499, align 4
  %501 = add <4 x i32> %500, %494
  %502 = icmp ne <4 x i32> %500, zeroinitializer
  %503 = zext <4 x i1> %502 to <4 x i32>
  %504 = add nuw nsw <4 x i32> %497, %503
  %505 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 16
  %506 = bitcast i32* %505 to <4 x i32>*
  %507 = load <4 x i32>, <4 x i32>* %506, align 4
  %508 = add <4 x i32> %507, %501
  %509 = icmp ne <4 x i32> %507, zeroinitializer
  %510 = zext <4 x i1> %509 to <4 x i32>
  %511 = add nuw nsw <4 x i32> %504, %510
  %512 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 20
  %513 = bitcast i32* %512 to <4 x i32>*
  %514 = load <4 x i32>, <4 x i32>* %513, align 4
  %515 = add <4 x i32> %514, %508
  %516 = icmp ne <4 x i32> %514, zeroinitializer
  %517 = zext <4 x i1> %516 to <4 x i32>
  %518 = add nuw nsw <4 x i32> %511, %517
  %519 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 24
  %520 = bitcast i32* %519 to <4 x i32>*
  %521 = load <4 x i32>, <4 x i32>* %520, align 4
  %522 = add <4 x i32> %521, %515
  %523 = icmp ne <4 x i32> %521, zeroinitializer
  %524 = zext <4 x i1> %523 to <4 x i32>
  %525 = add nuw nsw <4 x i32> %518, %524
  %526 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 28
  %527 = bitcast i32* %526 to <4 x i32>*
  %528 = load <4 x i32>, <4 x i32>* %527, align 4
  %529 = add <4 x i32> %528, %522
  %530 = icmp ne <4 x i32> %528, zeroinitializer
  %531 = zext <4 x i1> %530 to <4 x i32>
  %532 = add nuw nsw <4 x i32> %525, %531
  %533 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 32
  %534 = bitcast i32* %533 to <4 x i32>*
  %535 = load <4 x i32>, <4 x i32>* %534, align 4
  %536 = add <4 x i32> %535, %529
  %537 = icmp ne <4 x i32> %535, zeroinitializer
  %538 = zext <4 x i1> %537 to <4 x i32>
  %539 = add nuw nsw <4 x i32> %532, %538
  %540 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 36
  %541 = bitcast i32* %540 to <4 x i32>*
  %542 = load <4 x i32>, <4 x i32>* %541, align 4
  %543 = add <4 x i32> %542, %536
  %544 = icmp ne <4 x i32> %542, zeroinitializer
  %545 = zext <4 x i1> %544 to <4 x i32>
  %546 = add nuw nsw <4 x i32> %539, %545
  %547 = shufflevector <4 x i32> %543, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %548 = add <4 x i32> %543, %547
  %549 = shufflevector <4 x i32> %548, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %550 = add <4 x i32> %548, %549
  %551 = extractelement <4 x i32> %550, i32 0
  %552 = shufflevector <4 x i32> %546, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %553 = add <4 x i32> %546, %552
  %554 = shufflevector <4 x i32> %553, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %555 = add <4 x i32> %553, %554
  %556 = extractelement <4 x i32> %555, i32 0
  %557 = icmp ult i32 %556, 2
  br i1 %557, label %558, label %560

558:                                              ; preds = %478
  %559 = getelementptr inbounds i8, i8* %24, i64 6144
  call void @llvm.memset.p0i8.i64(i8* align 8 %559, i8 0, i64 320, i1 false) #5
  br label %591

560:                                              ; preds = %478
  %561 = icmp ult i32 %551, 256
  br i1 %561, label %562, label %566

562:                                              ; preds = %560
  %563 = zext i32 %551 to i64
  %564 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %563
  %565 = load float, float* %564, align 4
  br label %569

566:                                              ; preds = %560
  %567 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %568 = call float %567(i32 %551) #5
  br label %569

569:                                              ; preds = %566, %562
  %570 = phi float [ %565, %562 ], [ %568, %566 ]
  %571 = fpext float %570 to double
  br label %572

572:                                              ; preds = %584, %569
  %573 = phi i64 [ 0, %569 ], [ %589, %584 ]
  %574 = getelementptr inbounds %struct.VP8LHistogram, %struct.VP8LHistogram* %46, i64 0, i32 4, i64 %573
  %575 = load i32, i32* %574, align 4
  %576 = icmp ult i32 %575, 256
  br i1 %576, label %577, label %581

577:                                              ; preds = %572
  %578 = zext i32 %575 to i64
  %579 = getelementptr inbounds [256 x float], [256 x float]* @kLog2Table, i64 0, i64 %578
  %580 = load float, float* %579, align 4
  br label %584

581:                                              ; preds = %572
  %582 = load float (i32)*, float (i32)** @VP8LFastLog2Slow, align 8
  %583 = call float %582(i32 %575) #5
  br label %584

584:                                              ; preds = %581, %577
  %585 = phi float [ %580, %577 ], [ %583, %581 ]
  %586 = fpext float %585 to double
  %587 = fsub double %571, %586
  %588 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 3, i64 %573
  store double %587, double* %588, align 8
  %589 = add nuw nsw i64 %573, 1
  %590 = icmp eq i64 %589, 40
  br i1 %590, label %591, label %572

591:                                              ; preds = %584, %558
  call void @VP8LFreeHistogram(%struct.VP8LHistogram* nonnull %46) #5
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %43) #5
  %592 = icmp slt i32 %11, 4095
  %593 = select i1 %592, i32 %11, i32 4095
  %594 = getelementptr inbounds i8, i8* %29, i64 32792
  %595 = bitcast i8* %594 to float**
  store float* null, float** %595, align 8
  %596 = getelementptr inbounds i8, i8* %29, i64 16
  %597 = bitcast i8* %596 to %struct.CostCacheInterval**
  store %struct.CostCacheInterval* null, %struct.CostCacheInterval** %597, align 8
  %598 = bitcast i8* %29 to %struct.CostInterval**
  store %struct.CostInterval* null, %struct.CostInterval** %598, align 8
  %599 = getelementptr inbounds i8, i8* %29, i64 33136
  %600 = bitcast i8* %599 to %struct.CostInterval**
  store %struct.CostInterval* null, %struct.CostInterval** %600, align 8
  %601 = getelementptr inbounds i8, i8* %29, i64 8
  %602 = bitcast i8* %601 to i32*
  store i32 0, i32* %602, align 8
  %603 = getelementptr inbounds i8, i8* %29, i64 32800
  %604 = bitcast i8* %603 to i16**
  %605 = bitcast i8* %603 to i8**
  store i8* %13, i8** %605, align 8
  %606 = getelementptr inbounds i8, i8* %29, i64 33128
  %607 = bitcast i8* %606 to %struct.CostInterval**
  %608 = getelementptr inbounds i8, i8* %29, i64 32808
  %609 = bitcast i8* %608 to %struct.CostInterval*
  %610 = getelementptr inbounds i8, i8* %29, i64 32832
  %611 = bitcast i8* %610 to i64*
  store i64 0, i64* %611, align 8
  %612 = getelementptr inbounds i8, i8* %29, i64 32840
  %613 = ptrtoint i8* %608 to i64
  %614 = getelementptr inbounds i8, i8* %29, i64 32864
  %615 = bitcast i8* %614 to i64*
  store i64 %613, i64* %615, align 8
  %616 = getelementptr inbounds i8, i8* %29, i64 32872
  %617 = ptrtoint i8* %612 to i64
  %618 = getelementptr inbounds i8, i8* %29, i64 32896
  %619 = bitcast i8* %618 to i64*
  store i64 %617, i64* %619, align 8
  %620 = getelementptr inbounds i8, i8* %29, i64 32904
  %621 = ptrtoint i8* %616 to i64
  %622 = getelementptr inbounds i8, i8* %29, i64 32928
  %623 = bitcast i8* %622 to i64*
  store i64 %621, i64* %623, align 8
  %624 = getelementptr inbounds i8, i8* %29, i64 32936
  %625 = ptrtoint i8* %620 to i64
  %626 = getelementptr inbounds i8, i8* %29, i64 32960
  %627 = bitcast i8* %626 to i64*
  store i64 %625, i64* %627, align 8
  %628 = getelementptr inbounds i8, i8* %29, i64 32968
  %629 = ptrtoint i8* %624 to i64
  %630 = getelementptr inbounds i8, i8* %29, i64 32992
  %631 = bitcast i8* %630 to i64*
  store i64 %629, i64* %631, align 8
  %632 = getelementptr inbounds i8, i8* %29, i64 33000
  %633 = ptrtoint i8* %628 to i64
  %634 = getelementptr inbounds i8, i8* %29, i64 33024
  %635 = bitcast i8* %634 to i64*
  store i64 %633, i64* %635, align 8
  %636 = getelementptr inbounds i8, i8* %29, i64 33032
  %637 = ptrtoint i8* %632 to i64
  %638 = getelementptr inbounds i8, i8* %29, i64 33056
  %639 = bitcast i8* %638 to i64*
  store i64 %637, i64* %639, align 8
  %640 = getelementptr inbounds i8, i8* %29, i64 33064
  %641 = ptrtoint i8* %636 to i64
  %642 = getelementptr inbounds i8, i8* %29, i64 33088
  %643 = bitcast i8* %642 to i64*
  store i64 %641, i64* %643, align 8
  %644 = getelementptr inbounds i8, i8* %29, i64 33096
  %645 = bitcast i8* %644 to %struct.CostInterval*
  %646 = ptrtoint i8* %640 to i64
  %647 = getelementptr inbounds i8, i8* %29, i64 33120
  %648 = bitcast i8* %647 to i64*
  store i64 %646, i64* %648, align 8
  %649 = bitcast i8* %606 to i8**
  store i8* %644, i8** %649, align 8
  %650 = getelementptr inbounds i8, i8* %29, i64 24
  %651 = bitcast i8* %650 to i64*
  store i64 1, i64* %651, align 8
  %652 = load i8, i8* getelementptr inbounds ([512 x %struct.VP8LPrefixCode], [512 x %struct.VP8LPrefixCode]* @kPrefixEncodeCode, i64 0, i64 0, i32 0), align 16
  %653 = load i8, i8* getelementptr inbounds ([512 x %struct.VP8LPrefixCode], [512 x %struct.VP8LPrefixCode]* @kPrefixEncodeCode, i64 0, i64 0, i32 1), align 1
  %654 = sext i8 %652 to i64
  %655 = load double*, double** %71, align 8
  %656 = add nsw i64 %654, 256
  %657 = getelementptr inbounds double, double* %655, i64 %656
  %658 = load double, double* %657, align 8
  %659 = sitofp i8 %653 to double
  %660 = fadd double %658, %659
  %661 = getelementptr inbounds i8, i8* %29, i64 32
  %662 = bitcast i8* %661 to double*
  store double %660, double* %662, align 8
  %663 = icmp sgt i32 %593, 1
  br i1 %663, label %664, label %709

664:                                              ; preds = %591
  %665 = sext i32 %593 to i64
  br label %666

666:                                              ; preds = %705, %664
  %667 = phi i64 [ 1, %664 ], [ %706, %705 ]
  %668 = phi i64 [ 1, %664 ], [ %707, %705 ]
  %669 = icmp ult i64 %668, 512
  br i1 %669, label %670, label %678

670:                                              ; preds = %666
  %671 = getelementptr inbounds [512 x %struct.VP8LPrefixCode], [512 x %struct.VP8LPrefixCode]* @kPrefixEncodeCode, i64 0, i64 %668, i32 0
  %672 = load i8, i8* %671, align 2
  %673 = getelementptr inbounds [512 x %struct.VP8LPrefixCode], [512 x %struct.VP8LPrefixCode]* @kPrefixEncodeCode, i64 0, i64 %668, i32 1
  %674 = load i8, i8* %673, align 1
  %675 = sext i8 %672 to i32
  %676 = sext i8 %674 to i32
  %677 = add nsw i64 %668, -1
  br label %688

678:                                              ; preds = %666
  %679 = add nsw i64 %668, -1
  %680 = trunc i64 %679 to i32
  %681 = call i32 @llvm.ctlz.i32(i32 %680, i1 true) #5, !range !9
  %682 = xor i32 %681, 31
  %683 = add nsw i32 %682, -1
  %684 = lshr i32 %680, %683
  %685 = and i32 %684, 1
  %686 = shl nuw nsw i32 %682, 1
  %687 = or i32 %685, %686
  br label %688

688:                                              ; preds = %678, %670
  %689 = phi i64 [ %677, %670 ], [ %679, %678 ]
  %690 = phi i32 [ %675, %670 ], [ %687, %678 ]
  %691 = phi i32 [ %676, %670 ], [ %683, %678 ]
  %692 = load double*, double** %71, align 8
  %693 = add nsw i32 %690, 256
  %694 = sext i32 %693 to i64
  %695 = getelementptr inbounds double, double* %692, i64 %694
  %696 = load double, double* %695, align 8
  %697 = sitofp i32 %691 to double
  %698 = fadd double %696, %697
  %699 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %30, i64 0, i32 4, i64 %668
  store double %698, double* %699, align 8
  %700 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %30, i64 0, i32 4, i64 %689
  %701 = load double, double* %700, align 8
  %702 = fcmp une double %698, %701
  br i1 %702, label %703, label %705

703:                                              ; preds = %688
  %704 = add i64 %667, 1
  store i64 %704, i64* %651, align 8
  br label %705

705:                                              ; preds = %703, %688
  %706 = phi i64 [ %667, %688 ], [ %704, %703 ]
  %707 = add nuw nsw i64 %668, 1
  %708 = icmp slt i64 %707, %665
  br i1 %708, label %666, label %709

709:                                              ; preds = %705, %591
  %710 = phi i64 [ 1, %591 ], [ %706, %705 ]
  %711 = call i8* @WebPSafeMalloc(i64 %710, i64 16) #5
  %712 = bitcast i8* %596 to i8**
  store i8* %711, i8** %712, align 8
  %713 = icmp eq i8* %711, null
  br i1 %713, label %714, label %746

714:                                              ; preds = %709
  %715 = bitcast i8* %594 to i8**
  %716 = load i8*, i8** %715, align 8
  call void @WebPSafeFree(i8* %716) #5
  %717 = load i8*, i8** %712, align 8
  call void @WebPSafeFree(i8* %717) #5
  %718 = load %struct.CostInterval*, %struct.CostInterval** %598, align 8
  %719 = icmp eq %struct.CostInterval* %718, null
  br i1 %719, label %731, label %720

720:                                              ; preds = %714, %729
  %721 = phi %struct.CostInterval* [ %723, %729 ], [ %718, %714 ]
  %722 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %721, i64 0, i32 5
  %723 = load %struct.CostInterval*, %struct.CostInterval** %722, align 8
  %724 = icmp ult %struct.CostInterval* %721, %609
  %725 = icmp ugt %struct.CostInterval* %721, %645
  %726 = or i1 %724, %725
  br i1 %726, label %727, label %729

727:                                              ; preds = %720
  %728 = bitcast %struct.CostInterval* %721 to i8*
  call void @WebPSafeFree(i8* nonnull %728) #5
  br label %729

729:                                              ; preds = %727, %720
  %730 = icmp eq %struct.CostInterval* %723, null
  br i1 %730, label %731, label %720

731:                                              ; preds = %729, %714
  store %struct.CostInterval* null, %struct.CostInterval** %598, align 8
  %732 = load %struct.CostInterval*, %struct.CostInterval** %600, align 8
  %733 = icmp eq %struct.CostInterval* %732, null
  br i1 %733, label %745, label %734

734:                                              ; preds = %731, %743
  %735 = phi %struct.CostInterval* [ %737, %743 ], [ %732, %731 ]
  %736 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %735, i64 0, i32 5
  %737 = load %struct.CostInterval*, %struct.CostInterval** %736, align 8
  %738 = icmp ult %struct.CostInterval* %735, %609
  %739 = icmp ugt %struct.CostInterval* %735, %645
  %740 = or i1 %738, %739
  br i1 %740, label %741, label %743

741:                                              ; preds = %734
  %742 = bitcast %struct.CostInterval* %735 to i8*
  call void @WebPSafeFree(i8* nonnull %742) #5
  br label %743

743:                                              ; preds = %741, %734
  %744 = icmp eq %struct.CostInterval* %737, null
  br i1 %744, label %745, label %734

745:                                              ; preds = %743, %731
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %29, i8 0, i64 33144, i1 false) #5
  store i64 %613, i64* %615, align 8
  store i64 %617, i64* %619, align 8
  store i64 %621, i64* %623, align 8
  store i64 %625, i64* %627, align 8
  store i64 %629, i64* %631, align 8
  store i64 %633, i64* %635, align 8
  store i64 %637, i64* %639, align 8
  store i64 %641, i64* %643, align 8
  store i64 %646, i64* %648, align 8
  store i8* %644, i8** %649, align 8
  br label %1221

746:                                              ; preds = %709
  %747 = getelementptr inbounds i8, i8* %711, i64 8
  %748 = bitcast i8* %747 to i32*
  store i32 0, i32* %748, align 8
  %749 = getelementptr inbounds i8, i8* %711, i64 12
  %750 = bitcast i8* %749 to i32*
  store i32 1, i32* %750, align 4
  %751 = bitcast i8* %661 to i64*
  %752 = load i64, i64* %751, align 8
  %753 = bitcast i8* %711 to i64*
  store i64 %752, i64* %753, align 8
  br i1 %663, label %754, label %806

754:                                              ; preds = %746
  %755 = bitcast i8* %711 to %struct.CostCacheInterval*
  %756 = sext i32 %593 to i64
  %757 = add nsw i64 %756, -1
  %758 = and i64 %757, 1
  %759 = icmp eq i32 %593, 2
  br i1 %759, label %786, label %760

760:                                              ; preds = %754
  %761 = sub nsw i64 %757, %758
  br label %762

762:                                              ; preds = %1457, %760
  %763 = phi i64 [ 1, %760 ], [ %1459, %1457 ]
  %764 = phi %struct.CostCacheInterval* [ %755, %760 ], [ %1458, %1457 ]
  %765 = phi i64 [ %761, %760 ], [ %1462, %1457 ]
  %766 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %30, i64 0, i32 4, i64 %763
  %767 = load double, double* %766, align 8
  %768 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %764, i64 0, i32 0
  %769 = load double, double* %768, align 8
  %770 = fcmp une double %767, %769
  br i1 %770, label %771, label %776

771:                                              ; preds = %762
  %772 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %764, i64 1
  %773 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %764, i64 1, i32 1
  %774 = trunc i64 %763 to i32
  store i32 %774, i32* %773, align 8
  %775 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %772, i64 0, i32 0
  store double %767, double* %775, align 8
  br label %776

776:                                              ; preds = %771, %762
  %777 = phi %struct.CostCacheInterval* [ %772, %771 ], [ %764, %762 ]
  %778 = add nuw nsw i64 %763, 1
  %779 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %777, i64 0, i32 2
  %780 = trunc i64 %778 to i32
  store i32 %780, i32* %779, align 4
  %781 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %30, i64 0, i32 4, i64 %778
  %782 = load double, double* %781, align 8
  %783 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %777, i64 0, i32 0
  %784 = load double, double* %783, align 8
  %785 = fcmp une double %782, %784
  br i1 %785, label %1452, label %1457

786:                                              ; preds = %1457, %754
  %787 = phi i64 [ 1, %754 ], [ %1459, %1457 ]
  %788 = phi %struct.CostCacheInterval* [ %755, %754 ], [ %1458, %1457 ]
  %789 = icmp eq i64 %758, 0
  br i1 %789, label %806, label %790

790:                                              ; preds = %786
  %791 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %30, i64 0, i32 4, i64 %787
  %792 = load double, double* %791, align 8
  %793 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %788, i64 0, i32 0
  %794 = load double, double* %793, align 8
  %795 = fcmp une double %792, %794
  br i1 %795, label %796, label %801

796:                                              ; preds = %790
  %797 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %788, i64 1
  %798 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %788, i64 1, i32 1
  %799 = trunc i64 %787 to i32
  store i32 %799, i32* %798, align 8
  %800 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %797, i64 0, i32 0
  store double %792, double* %800, align 8
  br label %801

801:                                              ; preds = %796, %790
  %802 = phi %struct.CostCacheInterval* [ %797, %796 ], [ %788, %790 ]
  %803 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %802, i64 0, i32 2
  %804 = trunc i64 %787 to i32
  %805 = add i32 %804, 1
  store i32 %805, i32* %803, align 4
  br label %806

806:                                              ; preds = %801, %786, %746
  %807 = call i8* @WebPSafeMalloc(i64 %12, i64 4) #5
  %808 = bitcast i8* %594 to i8**
  store i8* %807, i8** %808, align 8
  %809 = icmp eq i8* %807, null
  %810 = bitcast i8* %807 to float*
  br i1 %809, label %823, label %811

811:                                              ; preds = %806
  %812 = icmp sgt i32 %11, 0
  br i1 %812, label %813, label %881

813:                                              ; preds = %811
  %814 = zext i32 %11 to i64
  store float 0x47D2CED320000000, float* %810, align 4
  %815 = icmp eq i32 %11, 1
  br i1 %815, label %881, label %816

816:                                              ; preds = %813
  %817 = add nsw i64 %814, -1
  %818 = add nsw i64 %814, -2
  %819 = and i64 %817, 3
  %820 = icmp ult i64 %818, 3
  br i1 %820, label %870, label %821

821:                                              ; preds = %816
  %822 = sub nsw i64 %817, %819
  br label %853

823:                                              ; preds = %806
  call void @WebPSafeFree(i8* null) #5
  %824 = load i8*, i8** %712, align 8
  call void @WebPSafeFree(i8* %824) #5
  %825 = load %struct.CostInterval*, %struct.CostInterval** %598, align 8
  %826 = icmp eq %struct.CostInterval* %825, null
  br i1 %826, label %838, label %827

827:                                              ; preds = %823, %836
  %828 = phi %struct.CostInterval* [ %830, %836 ], [ %825, %823 ]
  %829 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %828, i64 0, i32 5
  %830 = load %struct.CostInterval*, %struct.CostInterval** %829, align 8
  %831 = icmp ult %struct.CostInterval* %828, %609
  %832 = icmp ugt %struct.CostInterval* %828, %645
  %833 = or i1 %831, %832
  br i1 %833, label %834, label %836

834:                                              ; preds = %827
  %835 = bitcast %struct.CostInterval* %828 to i8*
  call void @WebPSafeFree(i8* nonnull %835) #5
  br label %836

836:                                              ; preds = %834, %827
  %837 = icmp eq %struct.CostInterval* %830, null
  br i1 %837, label %838, label %827

838:                                              ; preds = %836, %823
  store %struct.CostInterval* null, %struct.CostInterval** %598, align 8
  %839 = load %struct.CostInterval*, %struct.CostInterval** %600, align 8
  %840 = icmp eq %struct.CostInterval* %839, null
  br i1 %840, label %852, label %841

841:                                              ; preds = %838, %850
  %842 = phi %struct.CostInterval* [ %844, %850 ], [ %839, %838 ]
  %843 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %842, i64 0, i32 5
  %844 = load %struct.CostInterval*, %struct.CostInterval** %843, align 8
  %845 = icmp ult %struct.CostInterval* %842, %609
  %846 = icmp ugt %struct.CostInterval* %842, %645
  %847 = or i1 %845, %846
  br i1 %847, label %848, label %850

848:                                              ; preds = %841
  %849 = bitcast %struct.CostInterval* %842 to i8*
  call void @WebPSafeFree(i8* nonnull %849) #5
  br label %850

850:                                              ; preds = %848, %841
  %851 = icmp eq %struct.CostInterval* %844, null
  br i1 %851, label %852, label %841

852:                                              ; preds = %850, %838
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %29, i8 0, i64 33144, i1 false) #5
  store i64 %613, i64* %615, align 8
  store i64 %617, i64* %619, align 8
  store i64 %621, i64* %623, align 8
  store i64 %625, i64* %627, align 8
  store i64 %629, i64* %631, align 8
  store i64 %633, i64* %635, align 8
  store i64 %637, i64* %639, align 8
  store i64 %641, i64* %643, align 8
  store i64 %646, i64* %648, align 8
  store i8* %644, i8** %649, align 8
  br label %1221

853:                                              ; preds = %853, %821
  %854 = phi i64 [ 1, %821 ], [ %867, %853 ]
  %855 = phi i64 [ %822, %821 ], [ %868, %853 ]
  %856 = load float*, float** %595, align 8
  %857 = getelementptr inbounds float, float* %856, i64 %854
  store float 0x47D2CED320000000, float* %857, align 4
  %858 = add nuw nsw i64 %854, 1
  %859 = load float*, float** %595, align 8
  %860 = getelementptr inbounds float, float* %859, i64 %858
  store float 0x47D2CED320000000, float* %860, align 4
  %861 = add nuw nsw i64 %854, 2
  %862 = load float*, float** %595, align 8
  %863 = getelementptr inbounds float, float* %862, i64 %861
  store float 0x47D2CED320000000, float* %863, align 4
  %864 = add nuw nsw i64 %854, 3
  %865 = load float*, float** %595, align 8
  %866 = getelementptr inbounds float, float* %865, i64 %864
  store float 0x47D2CED320000000, float* %866, align 4
  %867 = add nuw nsw i64 %854, 4
  %868 = add i64 %855, -4
  %869 = icmp eq i64 %868, 0
  br i1 %869, label %870, label %853

870:                                              ; preds = %853, %816
  %871 = phi i64 [ 1, %816 ], [ %867, %853 ]
  %872 = icmp eq i64 %819, 0
  br i1 %872, label %881, label %873

873:                                              ; preds = %870, %873
  %874 = phi i64 [ %878, %873 ], [ %871, %870 ]
  %875 = phi i64 [ %879, %873 ], [ %819, %870 ]
  %876 = load float*, float** %595, align 8
  %877 = getelementptr inbounds float, float* %876, i64 %874
  store float 0x47D2CED320000000, float* %877, align 4
  %878 = add nuw nsw i64 %874, 1
  %879 = add i64 %875, -1
  %880 = icmp eq i64 %879, 0
  br i1 %880, label %881, label %873, !llvm.loop !10

881:                                              ; preds = %870, %873, %813, %811
  store i16 0, i16* %14, align 2
  %882 = load float*, float** %595, align 8
  %883 = load i32, i32* %2, align 4
  br i1 %17, label %884, label %903

884:                                              ; preds = %881
  %885 = load i32, i32* %28, align 8
  %886 = mul i32 %883, 506832829
  %887 = lshr i32 %886, %885
  %888 = load i32*, i32** %27, align 8
  %889 = sext i32 %887 to i64
  %890 = getelementptr inbounds i32, i32* %888, i64 %889
  %891 = load i32, i32* %890, align 4
  %892 = icmp eq i32 %891, %883
  %893 = icmp sgt i32 %887, -1
  %894 = and i1 %893, %892
  br i1 %894, label %895, label %902

895:                                              ; preds = %884
  %896 = add nuw i32 %887, 280
  %897 = load double*, double** %71, align 8
  %898 = sext i32 %896 to i64
  %899 = getelementptr inbounds double, double* %897, i64 %898
  %900 = load double, double* %899, align 8
  %901 = fmul double %900, 6.800000e-01
  br label %927

902:                                              ; preds = %884
  store i32 %883, i32* %890, align 4
  br label %903

903:                                              ; preds = %902, %881
  %904 = lshr i32 %883, 24
  %905 = zext i32 %904 to i64
  %906 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 0, i64 %905
  %907 = load double, double* %906, align 8
  %908 = lshr i32 %883, 16
  %909 = and i32 %908, 255
  %910 = zext i32 %909 to i64
  %911 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 1, i64 %910
  %912 = load double, double* %911, align 8
  %913 = fadd double %907, %912
  %914 = load double*, double** %71, align 8
  %915 = lshr i32 %883, 8
  %916 = and i32 %915, 255
  %917 = zext i32 %916 to i64
  %918 = getelementptr inbounds double, double* %914, i64 %917
  %919 = load double, double* %918, align 8
  %920 = fadd double %913, %919
  %921 = and i32 %883, 255
  %922 = zext i32 %921 to i64
  %923 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 2, i64 %922
  %924 = load double, double* %923, align 8
  %925 = fadd double %920, %924
  %926 = fmul double %925, 8.200000e-01
  br label %927

927:                                              ; preds = %903, %895
  %928 = phi double [ %901, %895 ], [ %926, %903 ]
  %929 = fadd double %928, 0.000000e+00
  %930 = load float, float* %882, align 4
  %931 = fpext float %930 to double
  %932 = fcmp olt double %929, %931
  br i1 %932, label %933, label %935

933:                                              ; preds = %927
  %934 = fptrunc double %929 to float
  store float %934, float* %882, align 4
  store i16 1, i16* %14, align 2
  br label %935

935:                                              ; preds = %933, %927
  %936 = icmp sgt i32 %11, 1
  br i1 %936, label %937, label %1215

937:                                              ; preds = %935
  %938 = getelementptr inbounds %struct.VP8LHashChain, %struct.VP8LHashChain* %4, i64 0, i32 0
  %939 = zext i32 %11 to i64
  br label %940

940:                                              ; preds = %1212, %937
  %941 = phi i64 [ 1, %937 ], [ %1213, %1212 ]
  %942 = phi i32 [ 0, %937 ], [ %1157, %1212 ]
  %943 = phi i32 [ -1, %937 ], [ %1156, %1212 ]
  %944 = phi double [ -1.000000e+00, %937 ], [ %1155, %1212 ]
  %945 = phi i32 [ -1, %937 ], [ %955, %1212 ]
  %946 = phi i32 [ -1, %937 ], [ %954, %1212 ]
  %947 = load float*, float** %595, align 8
  %948 = add nsw i64 %941, -1
  %949 = getelementptr inbounds float, float* %947, i64 %948
  %950 = load float, float* %949, align 4
  %951 = load i32*, i32** %938, align 8
  %952 = getelementptr inbounds i32, i32* %951, i64 %941
  %953 = load i32, i32* %952, align 4
  %954 = lshr i32 %953, 12
  %955 = and i32 %953, 4095
  %956 = fpext float %950 to double
  %957 = getelementptr inbounds i32, i32* %2, i64 %941
  %958 = load i32, i32* %957, align 4
  br i1 %17, label %959, label %978

959:                                              ; preds = %940
  %960 = load i32, i32* %28, align 8
  %961 = mul i32 %958, 506832829
  %962 = lshr i32 %961, %960
  %963 = load i32*, i32** %27, align 8
  %964 = sext i32 %962 to i64
  %965 = getelementptr inbounds i32, i32* %963, i64 %964
  %966 = load i32, i32* %965, align 4
  %967 = icmp eq i32 %966, %958
  %968 = icmp sgt i32 %962, -1
  %969 = and i1 %968, %967
  br i1 %969, label %970, label %977

970:                                              ; preds = %959
  %971 = add nuw i32 %962, 280
  %972 = load double*, double** %71, align 8
  %973 = sext i32 %971 to i64
  %974 = getelementptr inbounds double, double* %972, i64 %973
  %975 = load double, double* %974, align 8
  %976 = fmul double %975, 6.800000e-01
  br label %1002

977:                                              ; preds = %959
  store i32 %958, i32* %965, align 4
  br label %978

978:                                              ; preds = %977, %940
  %979 = lshr i32 %958, 24
  %980 = zext i32 %979 to i64
  %981 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 0, i64 %980
  %982 = load double, double* %981, align 8
  %983 = lshr i32 %958, 16
  %984 = and i32 %983, 255
  %985 = zext i32 %984 to i64
  %986 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 1, i64 %985
  %987 = load double, double* %986, align 8
  %988 = fadd double %982, %987
  %989 = load double*, double** %71, align 8
  %990 = lshr i32 %958, 8
  %991 = and i32 %990, 255
  %992 = zext i32 %991 to i64
  %993 = getelementptr inbounds double, double* %989, i64 %992
  %994 = load double, double* %993, align 8
  %995 = fadd double %988, %994
  %996 = and i32 %958, 255
  %997 = zext i32 %996 to i64
  %998 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 2, i64 %997
  %999 = load double, double* %998, align 8
  %1000 = fadd double %995, %999
  %1001 = fmul double %1000, 8.200000e-01
  br label %1002

1002:                                             ; preds = %978, %970
  %1003 = phi double [ %976, %970 ], [ %1001, %978 ]
  %1004 = fadd double %1003, %956
  %1005 = getelementptr inbounds float, float* %947, i64 %941
  %1006 = load float, float* %1005, align 4
  %1007 = fpext float %1006 to double
  %1008 = fcmp olt double %1004, %1007
  br i1 %1008, label %1009, label %1012

1009:                                             ; preds = %1002
  %1010 = fptrunc double %1004 to float
  store float %1010, float* %1005, align 4
  %1011 = getelementptr inbounds i16, i16* %14, i64 %941
  store i16 1, i16* %1011, align 2
  br label %1012

1012:                                             ; preds = %1009, %1002
  %1013 = icmp ugt i32 %955, 1
  br i1 %1013, label %1014, label %1154

1014:                                             ; preds = %1012
  %1015 = icmp eq i32 %954, %946
  br i1 %1015, label %1046, label %1016

1016:                                             ; preds = %1014
  %1017 = call i32 @VP8LDistanceToPlaneCode(i32 %0, i32 %954) #5
  %1018 = icmp slt i32 %1017, 512
  br i1 %1018, label %1019, label %1027

1019:                                             ; preds = %1016
  %1020 = sext i32 %1017 to i64
  %1021 = getelementptr inbounds [512 x %struct.VP8LPrefixCode], [512 x %struct.VP8LPrefixCode]* @kPrefixEncodeCode, i64 0, i64 %1020, i32 0
  %1022 = load i8, i8* %1021, align 2
  %1023 = getelementptr inbounds [512 x %struct.VP8LPrefixCode], [512 x %struct.VP8LPrefixCode]* @kPrefixEncodeCode, i64 0, i64 %1020, i32 1
  %1024 = load i8, i8* %1023, align 1
  %1025 = sext i8 %1022 to i32
  %1026 = sext i8 %1024 to i32
  br label %1036

1027:                                             ; preds = %1016
  %1028 = add nsw i32 %1017, -1
  %1029 = call i32 @llvm.ctlz.i32(i32 %1028, i1 true) #5, !range !9
  %1030 = xor i32 %1029, 31
  %1031 = add nsw i32 %1030, -1
  %1032 = lshr i32 %1028, %1031
  %1033 = and i32 %1032, 1
  %1034 = shl nuw nsw i32 %1030, 1
  %1035 = or i32 %1033, %1034
  br label %1036

1036:                                             ; preds = %1027, %1019
  %1037 = phi i32 [ %1025, %1019 ], [ %1035, %1027 ]
  %1038 = phi i32 [ %1026, %1019 ], [ %1031, %1027 ]
  %1039 = sext i32 %1037 to i64
  %1040 = getelementptr inbounds %struct.CostModel, %struct.CostModel* %25, i64 0, i32 3, i64 %1039
  %1041 = load double, double* %1040, align 8
  %1042 = sitofp i32 %1038 to double
  %1043 = fadd double %1041, %1042
  %1044 = fadd double %1043, %956
  %1045 = trunc i64 %941 to i32
  call fastcc void @PushInterval(%struct.CostManager* %30, double %1044, i32 %1045, i32 %955) #5
  br label %1154

1046:                                             ; preds = %1014
  %1047 = icmp eq i32 %943, 0
  %1048 = trunc i64 %948 to i32
  %1049 = add i32 %1048, -1
  %1050 = add i32 %1049, %945
  %1051 = select i1 %1047, i32 %942, i32 %1050
  %1052 = add i32 %955, %1048
  %1053 = icmp sgt i32 %1052, %1051
  br i1 %1053, label %1054, label %1154

1054:                                             ; preds = %1046
  %1055 = sext i32 %1051 to i64
  %1056 = icmp sgt i64 %941, %1055
  %1057 = trunc i64 %941 to i32
  br i1 %1056, label %1079, label %1058

1058:                                             ; preds = %1054
  %1059 = load i32*, i32** %938, align 8
  %1060 = add nsw i32 %1051, 1
  %1061 = zext i32 %1060 to i64
  br label %1064

1062:                                             ; preds = %1064
  %1063 = icmp eq i64 %1066, %1061
  br i1 %1063, label %1077, label %1064

1064:                                             ; preds = %1062, %1058
  %1065 = phi i64 [ %1066, %1062 ], [ %941, %1058 ]
  %1066 = add nuw nsw i64 %1065, 1
  %1067 = getelementptr inbounds i32, i32* %1059, i64 %1066
  %1068 = load i32, i32* %1067, align 4
  %1069 = lshr i32 %1068, 12
  %1070 = icmp eq i32 %1069, %946
  br i1 %1070, label %1062, label %1071

1071:                                             ; preds = %1064
  %1072 = trunc i64 %1065 to i32
  %1073 = and i64 %1065, 4294967295
  %1074 = getelementptr inbounds i32, i32* %1059, i64 %1073
  %1075 = load i32, i32* %1074, align 4
  %1076 = and i32 %1075, 4095
  br label %1079

1077:                                             ; preds = %1062
  %1078 = and i32 %1068, 4095
  br label %1079

1079:                                             ; preds = %1077, %1071, %1054
  %1080 = phi i32 [ %1072, %1071 ], [ %1057, %1054 ], [ %1060, %1077 ]
  %1081 = phi i32 [ %1076, %1071 ], [ 0, %1054 ], [ %1078, %1077 ]
  %1082 = add i32 %1080, -1
  %1083 = load %struct.CostInterval*, %struct.CostInterval** %598, align 8
  %1084 = icmp eq %struct.CostInterval* %1083, null
  %1085 = sext i32 %1082 to i64
  br i1 %1084, label %1147, label %1086

1086:                                             ; preds = %1079, %1112
  %1087 = phi %struct.CostInterval* [ %1093, %1112 ], [ %1083, %1079 ]
  %1088 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1087, i64 0, i32 1
  %1089 = load i32, i32* %1088, align 4
  %1090 = icmp slt i32 %1089, %1080
  br i1 %1090, label %1091, label %1114

1091:                                             ; preds = %1086
  %1092 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1087, i64 0, i32 5
  %1093 = load %struct.CostInterval*, %struct.CostInterval** %1092, align 8
  %1094 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1087, i64 0, i32 2
  %1095 = load i32, i32* %1094, align 8
  %1096 = icmp slt i32 %1095, %1080
  br i1 %1096, label %1112, label %1097

1097:                                             ; preds = %1091
  %1098 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1087, i64 0, i32 0
  %1099 = load float, float* %1098, align 8
  %1100 = load float*, float** %595, align 8
  %1101 = getelementptr inbounds float, float* %1100, i64 %1085
  %1102 = load float, float* %1101, align 4
  %1103 = fcmp ogt float %1102, %1099
  br i1 %1103, label %1104, label %1112

1104:                                             ; preds = %1097
  %1105 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1087, i64 0, i32 3
  %1106 = load i32, i32* %1105, align 4
  %1107 = sub nsw i32 %1082, %1106
  store float %1099, float* %1101, align 4
  %1108 = trunc i32 %1107 to i16
  %1109 = add i16 %1108, 1
  %1110 = load i16*, i16** %604, align 8
  %1111 = getelementptr inbounds i16, i16* %1110, i64 %1085
  store i16 %1109, i16* %1111, align 2
  br label %1112

1112:                                             ; preds = %1104, %1097, %1091
  %1113 = icmp eq %struct.CostInterval* %1093, null
  br i1 %1113, label %1114, label %1086

1114:                                             ; preds = %1112, %1086
  %1115 = load %struct.CostInterval*, %struct.CostInterval** %598, align 8
  %1116 = icmp eq %struct.CostInterval* %1115, null
  br i1 %1116, label %1147, label %1117

1117:                                             ; preds = %1114
  %1118 = zext i32 %1080 to i64
  br label %1119

1119:                                             ; preds = %1145, %1117
  %1120 = phi %struct.CostInterval* [ %1115, %1117 ], [ %1126, %1145 ]
  %1121 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1120, i64 0, i32 1
  %1122 = load i32, i32* %1121, align 4
  %1123 = icmp sgt i32 %1122, %1080
  br i1 %1123, label %1147, label %1124

1124:                                             ; preds = %1119
  %1125 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1120, i64 0, i32 5
  %1126 = load %struct.CostInterval*, %struct.CostInterval** %1125, align 8
  %1127 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1120, i64 0, i32 2
  %1128 = load i32, i32* %1127, align 8
  %1129 = icmp sgt i32 %1128, %1080
  br i1 %1129, label %1130, label %1145

1130:                                             ; preds = %1124
  %1131 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1120, i64 0, i32 0
  %1132 = load float, float* %1131, align 8
  %1133 = load float*, float** %595, align 8
  %1134 = getelementptr inbounds float, float* %1133, i64 %1118
  %1135 = load float, float* %1134, align 4
  %1136 = fcmp ogt float %1135, %1132
  br i1 %1136, label %1137, label %1145

1137:                                             ; preds = %1130
  %1138 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1120, i64 0, i32 3
  %1139 = load i32, i32* %1138, align 4
  %1140 = sub nsw i32 %1080, %1139
  store float %1132, float* %1134, align 4
  %1141 = trunc i32 %1140 to i16
  %1142 = add i16 %1141, 1
  %1143 = load i16*, i16** %604, align 8
  %1144 = getelementptr inbounds i16, i16* %1143, i64 %1118
  store i16 %1142, i16* %1144, align 2
  br label %1145

1145:                                             ; preds = %1137, %1130, %1124
  %1146 = icmp eq %struct.CostInterval* %1126, null
  br i1 %1146, label %1147, label %1119

1147:                                             ; preds = %1145, %1119, %1114, %1079
  %1148 = load float*, float** %595, align 8
  %1149 = getelementptr inbounds float, float* %1148, i64 %1085
  %1150 = load float, float* %1149, align 4
  %1151 = fpext float %1150 to double
  %1152 = fadd double %944, %1151
  call fastcc void @PushInterval(%struct.CostManager* %30, double %1152, i32 %1080, i32 %1081) #5
  %1153 = add i32 %1082, %1081
  br label %1154

1154:                                             ; preds = %1147, %1046, %1036, %1012
  %1155 = phi double [ %1043, %1036 ], [ %944, %1147 ], [ %944, %1046 ], [ %944, %1012 ]
  %1156 = phi i32 [ 1, %1036 ], [ 0, %1147 ], [ 0, %1046 ], [ %943, %1012 ]
  %1157 = phi i32 [ %942, %1036 ], [ %1153, %1147 ], [ %1051, %1046 ], [ %942, %1012 ]
  %1158 = load %struct.CostInterval*, %struct.CostInterval** %598, align 8
  %1159 = icmp eq %struct.CostInterval* %1158, null
  br i1 %1159, label %1212, label %1160

1160:                                             ; preds = %1154
  %1161 = trunc i64 %941 to i32
  br label %1162

1162:                                             ; preds = %1210, %1160
  %1163 = phi %struct.CostInterval* [ %1170, %1210 ], [ %1158, %1160 ]
  %1164 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1163, i64 0, i32 1
  %1165 = load i32, i32* %1164, align 4
  %1166 = sext i32 %1165 to i64
  %1167 = icmp slt i64 %941, %1166
  br i1 %1167, label %1212, label %1168

1168:                                             ; preds = %1162
  %1169 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1163, i64 0, i32 5
  %1170 = load %struct.CostInterval*, %struct.CostInterval** %1169, align 8
  %1171 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1163, i64 0, i32 2
  %1172 = load i32, i32* %1171, align 8
  %1173 = sext i32 %1172 to i64
  %1174 = icmp slt i64 %941, %1173
  br i1 %1174, label %1195, label %1175

1175:                                             ; preds = %1168
  %1176 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1163, i64 0, i32 4
  %1177 = load %struct.CostInterval*, %struct.CostInterval** %1176, align 8
  %1178 = icmp eq %struct.CostInterval* %1177, null
  %1179 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1177, i64 0, i32 5
  %1180 = select i1 %1178, %struct.CostInterval** %598, %struct.CostInterval** %1179
  store %struct.CostInterval* %1170, %struct.CostInterval** %1180, align 8
  %1181 = icmp eq %struct.CostInterval* %1170, null
  br i1 %1181, label %1184, label %1182

1182:                                             ; preds = %1175
  %1183 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1170, i64 0, i32 4
  store %struct.CostInterval* %1177, %struct.CostInterval** %1183, align 8
  br label %1184

1184:                                             ; preds = %1182, %1175
  %1185 = icmp ult %struct.CostInterval* %1163, %609
  %1186 = icmp ugt %struct.CostInterval* %1163, %645
  %1187 = or i1 %1185, %1186
  %1188 = select i1 %1187, i8* %599, i8* %606
  %1189 = bitcast i8* %1188 to i64*
  %1190 = select i1 %1187, %struct.CostInterval** %600, %struct.CostInterval** %607
  %1191 = load i64, i64* %1189, align 8
  %1192 = bitcast %struct.CostInterval** %1169 to i64*
  store i64 %1191, i64* %1192, align 8
  store %struct.CostInterval* %1163, %struct.CostInterval** %1190, align 8
  %1193 = load i32, i32* %602, align 8
  %1194 = add nsw i32 %1193, -1
  store i32 %1194, i32* %602, align 8
  br label %1210

1195:                                             ; preds = %1168
  %1196 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1163, i64 0, i32 0
  %1197 = load float, float* %1196, align 8
  %1198 = load float*, float** %595, align 8
  %1199 = getelementptr inbounds float, float* %1198, i64 %941
  %1200 = load float, float* %1199, align 4
  %1201 = fcmp ogt float %1200, %1197
  br i1 %1201, label %1202, label %1210

1202:                                             ; preds = %1195
  %1203 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1163, i64 0, i32 3
  %1204 = load i32, i32* %1203, align 4
  %1205 = sub nsw i32 %1161, %1204
  store float %1197, float* %1199, align 4
  %1206 = trunc i32 %1205 to i16
  %1207 = add i16 %1206, 1
  %1208 = load i16*, i16** %604, align 8
  %1209 = getelementptr inbounds i16, i16* %1208, i64 %941
  store i16 %1207, i16* %1209, align 2
  br label %1210

1210:                                             ; preds = %1202, %1195, %1184
  %1211 = icmp eq %struct.CostInterval* %1170, null
  br i1 %1211, label %1212, label %1162

1212:                                             ; preds = %1210, %1162, %1154
  %1213 = add nuw nsw i64 %941, 1
  %1214 = icmp eq i64 %1213, %939
  br i1 %1214, label %1215, label %940

1215:                                             ; preds = %1212, %935
  %1216 = getelementptr inbounds %struct.VP8LBackwardRefs, %struct.VP8LBackwardRefs* %5, i64 0, i32 1
  %1217 = load i32, i32* %1216, align 4
  %1218 = icmp eq i32 %1217, 0
  %1219 = zext i1 %1218 to i32
  br label %1221

1220:                                             ; preds = %41
  call void @VP8LFreeHistogram(%struct.VP8LHistogram* null) #5
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %43) #5
  br label %1221

1221:                                             ; preds = %1220, %1215, %852, %745
  %1222 = phi i32 [ %1219, %1215 ], [ 0, %745 ], [ 0, %852 ], [ 0, %1220 ]
  %1223 = icmp eq i32 %42, 0
  br i1 %1223, label %1225, label %1224

1224:                                             ; preds = %1221
  call void @VP8LColorCacheClear(%struct.VP8LColorCache* nonnull %10) #5
  br label %1225

1225:                                             ; preds = %1224, %1221, %38, %16
  %1226 = phi i32 [ %1222, %1221 ], [ %1222, %1224 ], [ 0, %16 ], [ 0, %38 ]
  br i1 %32, label %1314, label %1227

1227:                                             ; preds = %1225
  %1228 = getelementptr inbounds i8, i8* %29, i64 32792
  %1229 = bitcast i8* %1228 to i8**
  %1230 = load i8*, i8** %1229, align 8
  call void @WebPSafeFree(i8* %1230) #5
  %1231 = getelementptr inbounds i8, i8* %29, i64 16
  %1232 = bitcast i8* %1231 to i8**
  %1233 = load i8*, i8** %1232, align 8
  call void @WebPSafeFree(i8* %1233) #5
  %1234 = bitcast i8* %29 to %struct.CostInterval**
  %1235 = load %struct.CostInterval*, %struct.CostInterval** %1234, align 8
  %1236 = icmp eq %struct.CostInterval* %1235, null
  br i1 %1236, label %1253, label %1237

1237:                                             ; preds = %1227
  %1238 = getelementptr inbounds i8, i8* %29, i64 32808
  %1239 = bitcast i8* %1238 to %struct.CostInterval*
  %1240 = getelementptr inbounds i8, i8* %29, i64 33096
  %1241 = bitcast i8* %1240 to %struct.CostInterval*
  br label %1242

1242:                                             ; preds = %1251, %1237
  %1243 = phi %struct.CostInterval* [ %1235, %1237 ], [ %1245, %1251 ]
  %1244 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1243, i64 0, i32 5
  %1245 = load %struct.CostInterval*, %struct.CostInterval** %1244, align 8
  %1246 = icmp ult %struct.CostInterval* %1243, %1239
  %1247 = icmp ugt %struct.CostInterval* %1243, %1241
  %1248 = or i1 %1246, %1247
  br i1 %1248, label %1249, label %1251

1249:                                             ; preds = %1242
  %1250 = bitcast %struct.CostInterval* %1243 to i8*
  call void @WebPSafeFree(i8* nonnull %1250) #5
  br label %1251

1251:                                             ; preds = %1249, %1242
  %1252 = icmp eq %struct.CostInterval* %1245, null
  br i1 %1252, label %1253, label %1242

1253:                                             ; preds = %1251, %1227
  store %struct.CostInterval* null, %struct.CostInterval** %1234, align 8
  %1254 = getelementptr inbounds i8, i8* %29, i64 33136
  %1255 = bitcast i8* %1254 to %struct.CostInterval**
  %1256 = load %struct.CostInterval*, %struct.CostInterval** %1255, align 8
  %1257 = icmp eq %struct.CostInterval* %1256, null
  br i1 %1257, label %1274, label %1258

1258:                                             ; preds = %1253
  %1259 = getelementptr inbounds i8, i8* %29, i64 32808
  %1260 = bitcast i8* %1259 to %struct.CostInterval*
  %1261 = getelementptr inbounds i8, i8* %29, i64 33096
  %1262 = bitcast i8* %1261 to %struct.CostInterval*
  br label %1263

1263:                                             ; preds = %1272, %1258
  %1264 = phi %struct.CostInterval* [ %1256, %1258 ], [ %1266, %1272 ]
  %1265 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %1264, i64 0, i32 5
  %1266 = load %struct.CostInterval*, %struct.CostInterval** %1265, align 8
  %1267 = icmp ult %struct.CostInterval* %1264, %1260
  %1268 = icmp ugt %struct.CostInterval* %1264, %1262
  %1269 = or i1 %1267, %1268
  br i1 %1269, label %1270, label %1272

1270:                                             ; preds = %1263
  %1271 = bitcast %struct.CostInterval* %1264 to i8*
  call void @WebPSafeFree(i8* nonnull %1271) #5
  br label %1272

1272:                                             ; preds = %1270, %1263
  %1273 = icmp eq %struct.CostInterval* %1266, null
  br i1 %1273, label %1274, label %1263

1274:                                             ; preds = %1272, %1253
  %1275 = getelementptr inbounds i8, i8* %29, i64 33128
  %1276 = getelementptr inbounds i8, i8* %29, i64 32808
  %1277 = getelementptr inbounds i8, i8* %29, i64 32840
  %1278 = ptrtoint i8* %1276 to i64
  %1279 = getelementptr inbounds i8, i8* %29, i64 32864
  %1280 = bitcast i8* %1279 to i64*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %29, i8 0, i64 33144, i1 false) #5
  store i64 %1278, i64* %1280, align 8
  %1281 = getelementptr inbounds i8, i8* %29, i64 32872
  %1282 = ptrtoint i8* %1277 to i64
  %1283 = getelementptr inbounds i8, i8* %29, i64 32896
  %1284 = bitcast i8* %1283 to i64*
  store i64 %1282, i64* %1284, align 8
  %1285 = getelementptr inbounds i8, i8* %29, i64 32904
  %1286 = ptrtoint i8* %1281 to i64
  %1287 = getelementptr inbounds i8, i8* %29, i64 32928
  %1288 = bitcast i8* %1287 to i64*
  store i64 %1286, i64* %1288, align 8
  %1289 = getelementptr inbounds i8, i8* %29, i64 32936
  %1290 = ptrtoint i8* %1285 to i64
  %1291 = getelementptr inbounds i8, i8* %29, i64 32960
  %1292 = bitcast i8* %1291 to i64*
  store i64 %1290, i64* %1292, align 8
  %1293 = getelementptr inbounds i8, i8* %29, i64 32968
  %1294 = ptrtoint i8* %1289 to i64
  %1295 = getelementptr inbounds i8, i8* %29, i64 32992
  %1296 = bitcast i8* %1295 to i64*
  store i64 %1294, i64* %1296, align 8
  %1297 = getelementptr inbounds i8, i8* %29, i64 33000
  %1298 = ptrtoint i8* %1293 to i64
  %1299 = getelementptr inbounds i8, i8* %29, i64 33024
  %1300 = bitcast i8* %1299 to i64*
  store i64 %1298, i64* %1300, align 8
  %1301 = getelementptr inbounds i8, i8* %29, i64 33032
  %1302 = ptrtoint i8* %1297 to i64
  %1303 = getelementptr inbounds i8, i8* %29, i64 33056
  %1304 = bitcast i8* %1303 to i64*
  store i64 %1302, i64* %1304, align 8
  %1305 = getelementptr inbounds i8, i8* %29, i64 33064
  %1306 = ptrtoint i8* %1301 to i64
  %1307 = getelementptr inbounds i8, i8* %29, i64 33088
  %1308 = bitcast i8* %1307 to i64*
  store i64 %1306, i64* %1308, align 8
  %1309 = getelementptr inbounds i8, i8* %29, i64 33096
  %1310 = ptrtoint i8* %1305 to i64
  %1311 = getelementptr inbounds i8, i8* %29, i64 33120
  %1312 = bitcast i8* %1311 to i64*
  store i64 %1310, i64* %1312, align 8
  %1313 = bitcast i8* %1275 to i8**
  store i8* %1309, i8** %1313, align 8
  br label %1314

1314:                                             ; preds = %1225, %1274
  call void @WebPSafeFree(i8* %24) #5
  call void @WebPSafeFree(i8* %29) #5
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %26) #5
  %1315 = icmp eq i32 %1226, 0
  br i1 %1315, label %1450, label %1316

1316:                                             ; preds = %1314
  %1317 = getelementptr inbounds i16, i16* %14, i64 %12
  %1318 = getelementptr inbounds i16, i16* %1317, i64 -1
  %1319 = icmp ult i16* %1318, %14
  br i1 %1319, label %1329, label %1320

1320:                                             ; preds = %1316, %1320
  %1321 = phi i16* [ %1324, %1320 ], [ %1317, %1316 ]
  %1322 = phi i16* [ %1327, %1320 ], [ %1318, %1316 ]
  %1323 = load i16, i16* %1322, align 2
  %1324 = getelementptr inbounds i16, i16* %1321, i64 -1
  store i16 %1323, i16* %1324, align 2
  %1325 = zext i16 %1323 to i64
  %1326 = sub nsw i64 0, %1325
  %1327 = getelementptr inbounds i16, i16* %1322, i64 %1326
  %1328 = icmp ult i16* %1327, %14
  br i1 %1328, label %1329, label %1320

1329:                                             ; preds = %1320, %1316
  %1330 = phi i16* [ %1317, %1316 ], [ %1324, %1320 ]
  %1331 = ptrtoint i16* %1317 to i64
  %1332 = ptrtoint i16* %1330 to i64
  %1333 = sub i64 %1331, %1332
  %1334 = lshr exact i64 %1333, 1
  %1335 = trunc i64 %1334 to i32
  %1336 = bitcast %struct.VP8LColorCache* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %1336) #5
  %1337 = getelementptr inbounds %struct.VP8LColorCache, %struct.VP8LColorCache* %8, i64 0, i32 0
  %1338 = getelementptr inbounds %struct.VP8LColorCache, %struct.VP8LColorCache* %8, i64 0, i32 1
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %1336, i8 -86, i64 16, i1 false) #5
  br i1 %17, label %1339, label %1343

1339:                                             ; preds = %1329
  %1340 = call i32 @VP8LColorCacheInit(%struct.VP8LColorCache* nonnull %8, i32 %3) #5
  %1341 = icmp eq i32 %1340, 0
  br i1 %1341, label %1342, label %1343

1342:                                             ; preds = %1339
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %1336) #5
  br label %1449

1343:                                             ; preds = %1339, %1329
  %1344 = phi i32 [ %1340, %1339 ], [ 0, %1329 ]
  call void @VP8LClearBackwardRefs(%struct.VP8LBackwardRefs* %6) #5
  %1345 = icmp sgt i32 %1335, 0
  br i1 %1345, label %1346, label %1442

1346:                                             ; preds = %1343
  %1347 = getelementptr inbounds %struct.VP8LHashChain, %struct.VP8LHashChain* %4, i64 0, i32 0
  %1348 = and i64 %1334, 4294967295
  br label %1349

1349:                                             ; preds = %1438, %1346
  %1350 = phi i64 [ 0, %1346 ], [ %1440, %1438 ]
  %1351 = phi i32 [ 0, %1346 ], [ %1439, %1438 ]
  %1352 = getelementptr inbounds i16, i16* %1330, i64 %1350
  %1353 = load i16, i16* %1352, align 2
  %1354 = zext i16 %1353 to i32
  %1355 = icmp eq i16 %1353, 1
  br i1 %1355, label %1400, label %1356

1356:                                             ; preds = %1349
  %1357 = load i32*, i32** %1347, align 8
  %1358 = zext i32 %1351 to i64
  %1359 = getelementptr inbounds i32, i32* %1357, i64 %1358
  %1360 = load i32, i32* %1359, align 4
  %1361 = lshr i32 %1360, 12
  %1362 = zext i32 %1361 to i64
  %1363 = shl nuw nsw i64 %1362, 32
  %1364 = zext i16 %1353 to i64
  %1365 = shl nuw nsw i64 %1364, 16
  %1366 = or i64 %1365, %1363
  %1367 = or i64 %1366, 43522
  call void @VP8LBackwardRefsCursorAdd(%struct.VP8LBackwardRefs* %6, i64 %1367) #5
  %1368 = icmp ne i16 %1353, 0
  %1369 = and i1 %17, %1368
  br i1 %1369, label %1370, label %1438

1370:                                             ; preds = %1356
  %1371 = and i64 %1364, 1
  %1372 = icmp eq i16 %1353, 1
  br i1 %1372, label %1425, label %1373

1373:                                             ; preds = %1370
  %1374 = sub nsw i64 %1364, %1371
  br label %1375

1375:                                             ; preds = %1375, %1373
  %1376 = phi i64 [ 0, %1373 ], [ %1397, %1375 ]
  %1377 = phi i64 [ %1374, %1373 ], [ %1398, %1375 ]
  %1378 = add nuw nsw i64 %1376, %1358
  %1379 = getelementptr inbounds i32, i32* %2, i64 %1378
  %1380 = load i32, i32* %1379, align 4
  %1381 = load i32, i32* %1338, align 8
  %1382 = mul i32 %1380, 506832829
  %1383 = lshr i32 %1382, %1381
  %1384 = load i32*, i32** %1337, align 8
  %1385 = sext i32 %1383 to i64
  %1386 = getelementptr inbounds i32, i32* %1384, i64 %1385
  store i32 %1380, i32* %1386, align 4
  %1387 = or i64 %1376, 1
  %1388 = add nuw nsw i64 %1387, %1358
  %1389 = getelementptr inbounds i32, i32* %2, i64 %1388
  %1390 = load i32, i32* %1389, align 4
  %1391 = load i32, i32* %1338, align 8
  %1392 = mul i32 %1390, 506832829
  %1393 = lshr i32 %1392, %1391
  %1394 = load i32*, i32** %1337, align 8
  %1395 = sext i32 %1393 to i64
  %1396 = getelementptr inbounds i32, i32* %1394, i64 %1395
  store i32 %1390, i32* %1396, align 4
  %1397 = add nuw nsw i64 %1376, 2
  %1398 = add i64 %1377, -2
  %1399 = icmp eq i64 %1398, 0
  br i1 %1399, label %1425, label %1375

1400:                                             ; preds = %1349
  %1401 = zext i32 %1351 to i64
  br i1 %17, label %1402, label %1416

1402:                                             ; preds = %1400
  %1403 = getelementptr inbounds i32, i32* %2, i64 %1401
  %1404 = load i32, i32* %1403, align 4
  %1405 = load i32, i32* %1338, align 8
  %1406 = mul i32 %1404, 506832829
  %1407 = lshr i32 %1406, %1405
  %1408 = load i32*, i32** %1337, align 8
  %1409 = sext i32 %1407 to i64
  %1410 = getelementptr inbounds i32, i32* %1408, i64 %1409
  %1411 = load i32, i32* %1410, align 4
  %1412 = icmp eq i32 %1411, %1404
  %1413 = icmp sgt i32 %1407, -1
  %1414 = and i1 %1413, %1412
  br i1 %1414, label %1419, label %1415

1415:                                             ; preds = %1402
  store i32 %1404, i32* %1410, align 4
  br label %1416

1416:                                             ; preds = %1415, %1400
  %1417 = getelementptr inbounds i32, i32* %2, i64 %1401
  %1418 = load i32, i32* %1417, align 4
  br label %1419

1419:                                             ; preds = %1402, %1416
  %1420 = phi i32 [ %1418, %1416 ], [ %1407, %1402 ]
  %1421 = phi i64 [ 109056, %1416 ], [ 109057, %1402 ]
  %1422 = zext i32 %1420 to i64
  %1423 = shl nuw i64 %1422, 32
  %1424 = or i64 %1423, %1421
  call void @VP8LBackwardRefsCursorAdd(%struct.VP8LBackwardRefs* %6, i64 %1424) #5
  br label %1438

1425:                                             ; preds = %1375, %1370
  %1426 = phi i64 [ 0, %1370 ], [ %1397, %1375 ]
  %1427 = icmp eq i64 %1371, 0
  br i1 %1427, label %1438, label %1428

1428:                                             ; preds = %1425
  %1429 = add nuw nsw i64 %1426, %1358
  %1430 = getelementptr inbounds i32, i32* %2, i64 %1429
  %1431 = load i32, i32* %1430, align 4
  %1432 = load i32, i32* %1338, align 8
  %1433 = mul i32 %1431, 506832829
  %1434 = lshr i32 %1433, %1432
  %1435 = load i32*, i32** %1337, align 8
  %1436 = sext i32 %1434 to i64
  %1437 = getelementptr inbounds i32, i32* %1435, i64 %1436
  store i32 %1431, i32* %1437, align 4
  br label %1438

1438:                                             ; preds = %1428, %1425, %1419, %1356
  %1439 = add nuw nsw i32 %1351, %1354
  %1440 = add nuw nsw i64 %1350, 1
  %1441 = icmp eq i64 %1440, %1348
  br i1 %1441, label %1442, label %1349

1442:                                             ; preds = %1438, %1343
  %1443 = getelementptr inbounds %struct.VP8LBackwardRefs, %struct.VP8LBackwardRefs* %6, i64 0, i32 1
  %1444 = load i32, i32* %1443, align 4
  %1445 = icmp eq i32 %1444, 0
  %1446 = icmp eq i32 %1344, 0
  br i1 %1446, label %1448, label %1447

1447:                                             ; preds = %1442
  call void @VP8LColorCacheClear(%struct.VP8LColorCache* nonnull %8) #5
  br label %1448

1448:                                             ; preds = %1442, %1447
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %1336) #5
  br i1 %1445, label %1450, label %1449

1449:                                             ; preds = %1448, %1342
  br label %1450

1450:                                             ; preds = %1448, %1449, %1314, %7
  %1451 = phi i32 [ 0, %7 ], [ 0, %1314 ], [ 0, %1449 ], [ 1, %1448 ]
  call void @WebPSafeFree(i8* %13) #5
  ret i32 %1451

1452:                                             ; preds = %776
  %1453 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %777, i64 1
  %1454 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %777, i64 1, i32 1
  %1455 = trunc i64 %778 to i32
  store i32 %1455, i32* %1454, align 8
  %1456 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %1453, i64 0, i32 0
  store double %782, double* %1456, align 8
  br label %1457

1457:                                             ; preds = %1452, %776
  %1458 = phi %struct.CostCacheInterval* [ %1453, %1452 ], [ %777, %776 ]
  %1459 = add nuw nsw i64 %763, 2
  %1460 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %1458, i64 0, i32 2
  %1461 = trunc i64 %1459 to i32
  store i32 %1461, i32* %1460, align 4
  %1462 = add i64 %765, -2
  %1463 = icmp eq i64 %1462, 0
  br i1 %1463, label %786, label %762
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

declare i8* @WebPSafeMalloc(i64, i64) local_unnamed_addr #2

declare void @WebPSafeFree(i8*) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

declare i8* @WebPSafeCalloc(i64, i64) local_unnamed_addr #2

declare i32 @VP8LColorCacheInit(%struct.VP8LColorCache*, i32) local_unnamed_addr #2

declare i32 @VP8LDistanceToPlaneCode(i32, i32) #2

; Function Attrs: inlinehint nounwind ssp uwtable
define internal fastcc void @PushInterval(%struct.CostManager*, double, i32, i32) unnamed_addr #3 {
  %5 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 2
  %6 = load %struct.CostCacheInterval*, %struct.CostCacheInterval** %5, align 8
  %7 = icmp slt i32 %3, 10
  br i1 %7, label %8, label %35

8:                                                ; preds = %4
  %9 = icmp sgt i32 %3, 0
  br i1 %9, label %10, label %124

10:                                               ; preds = %8
  %11 = add nsw i32 %3, %2
  %12 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 5
  %13 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 6
  %14 = sext i32 %2 to i64
  %15 = sext i32 %11 to i64
  br label %16

16:                                               ; preds = %10, %32
  %17 = phi i64 [ %14, %10 ], [ %33, %32 ]
  %18 = sub nsw i64 %17, %14
  %19 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 4, i64 %18
  %20 = load double, double* %19, align 8
  %21 = fadd double %20, %1
  %22 = fptrunc double %21 to float
  %23 = load float*, float** %12, align 8
  %24 = getelementptr inbounds float, float* %23, i64 %17
  %25 = load float, float* %24, align 4
  %26 = fcmp ogt float %25, %22
  br i1 %26, label %27, label %32

27:                                               ; preds = %16
  store float %22, float* %24, align 4
  %28 = trunc i64 %18 to i16
  %29 = add i16 %28, 1
  %30 = load i16*, i16** %13, align 8
  %31 = getelementptr inbounds i16, i16* %30, i64 %17
  store i16 %29, i16* %31, align 2
  br label %32

32:                                               ; preds = %27, %16
  %33 = add nsw i64 %17, 1
  %34 = icmp slt i64 %33, %15
  br i1 %34, label %16, label %124

35:                                               ; preds = %4
  %36 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 0
  %37 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 3
  %38 = load i64, i64* %37, align 8
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %124, label %40

40:                                               ; preds = %35
  %41 = load %struct.CostInterval*, %struct.CostInterval** %36, align 8
  %42 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 7, i64 0
  %43 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 7, i64 9
  %44 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 8
  %45 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 9
  %46 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 1
  br label %47

47:                                               ; preds = %40, %118
  %48 = phi i64 [ 0, %40 ], [ %121, %118 ]
  %49 = phi %struct.CostInterval* [ %41, %40 ], [ %120, %118 ]
  %50 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %6, i64 %48, i32 1
  %51 = load i32, i32* %50, align 8
  %52 = icmp slt i32 %51, %3
  br i1 %52, label %53, label %124

53:                                               ; preds = %47
  %54 = add nsw i32 %51, %2
  %55 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %6, i64 %48, i32 2
  %56 = load i32, i32* %55, align 4
  %57 = icmp sgt i32 %56, %3
  %58 = select i1 %57, i32 %3, i32 %56
  %59 = add nsw i32 %58, %2
  %60 = getelementptr inbounds %struct.CostCacheInterval, %struct.CostCacheInterval* %6, i64 %48, i32 0
  %61 = load double, double* %60, align 8
  %62 = fadd double %61, %1
  %63 = fptrunc double %62 to float
  %64 = icmp eq %struct.CostInterval* %49, null
  br i1 %64, label %118, label %65

65:                                               ; preds = %53, %115
  %66 = phi %struct.CostInterval* [ %73, %115 ], [ %49, %53 ]
  %67 = phi i32 [ %116, %115 ], [ %54, %53 ]
  %68 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 1
  %69 = load i32, i32* %68, align 4
  %70 = icmp slt i32 %69, %59
  br i1 %70, label %71, label %118

71:                                               ; preds = %65
  %72 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 5
  %73 = load %struct.CostInterval*, %struct.CostInterval** %72, align 8
  %74 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 2
  %75 = load i32, i32* %74, align 8
  %76 = icmp slt i32 %67, %75
  br i1 %76, label %77, label %115

77:                                               ; preds = %71
  %78 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 0
  %79 = load float, float* %78, align 8
  %80 = fcmp ugt float %79, %63
  br i1 %80, label %83, label %81

81:                                               ; preds = %77
  tail call fastcc void @InsertInterval(%struct.CostManager* %0, %struct.CostInterval* nonnull %66, float %63, i32 %2, i32 %67, i32 %69)
  %82 = icmp slt i32 %75, %59
  br i1 %82, label %115, label %118

83:                                               ; preds = %77
  %84 = icmp sgt i32 %67, %69
  br i1 %84, label %109, label %85

85:                                               ; preds = %83
  %86 = icmp sgt i32 %75, %59
  br i1 %86, label %107, label %87

87:                                               ; preds = %85
  %88 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 4
  %89 = load %struct.CostInterval*, %struct.CostInterval** %88, align 8
  %90 = icmp eq %struct.CostInterval* %89, null
  %91 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %89, i64 0, i32 5
  %92 = select i1 %90, %struct.CostInterval** %36, %struct.CostInterval** %91
  store %struct.CostInterval* %73, %struct.CostInterval** %92, align 8
  %93 = icmp eq %struct.CostInterval* %73, null
  br i1 %93, label %96, label %94

94:                                               ; preds = %87
  %95 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %73, i64 0, i32 4
  store %struct.CostInterval* %89, %struct.CostInterval** %95, align 8
  br label %96

96:                                               ; preds = %94, %87
  %97 = icmp ugt %struct.CostInterval* %42, %66
  %98 = icmp ult %struct.CostInterval* %43, %66
  %99 = or i1 %97, %98
  %100 = select i1 %99, %struct.CostInterval** %45, %struct.CostInterval** %44
  %101 = bitcast %struct.CostInterval** %100 to i64*
  %102 = select i1 %99, %struct.CostInterval** %45, %struct.CostInterval** %44
  %103 = load i64, i64* %101, align 8
  %104 = bitcast %struct.CostInterval** %72 to i64*
  store i64 %103, i64* %104, align 8
  store %struct.CostInterval* %66, %struct.CostInterval** %102, align 8
  %105 = load i32, i32* %46, align 8
  %106 = add nsw i32 %105, -1
  store i32 %106, i32* %46, align 8
  br label %115

107:                                              ; preds = %85
  %108 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 1
  store i32 %59, i32* %108, align 4
  br label %118

109:                                              ; preds = %83
  %110 = icmp slt i32 %59, %75
  store i32 %67, i32* %74, align 8
  br i1 %110, label %111, label %115

111:                                              ; preds = %109
  %112 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %66, i64 0, i32 3
  %113 = load i32, i32* %112, align 4
  tail call fastcc void @InsertInterval(%struct.CostManager* %0, %struct.CostInterval* nonnull %66, float %79, i32 %113, i32 %59, i32 %75)
  %114 = load %struct.CostInterval*, %struct.CostInterval** %72, align 8
  br label %118

115:                                              ; preds = %81, %109, %71, %96
  %116 = phi i32 [ %67, %71 ], [ %75, %81 ], [ %67, %96 ], [ %67, %109 ]
  %117 = icmp eq %struct.CostInterval* %73, null
  br i1 %117, label %118, label %65

118:                                              ; preds = %65, %115, %81, %53, %111, %107
  %119 = phi i32 [ %67, %107 ], [ %67, %111 ], [ %54, %53 ], [ %67, %65 ], [ %116, %115 ], [ %75, %81 ]
  %120 = phi %struct.CostInterval* [ %66, %107 ], [ %114, %111 ], [ null, %53 ], [ %66, %65 ], [ null, %115 ], [ %66, %81 ]
  tail call fastcc void @InsertInterval(%struct.CostManager* %0, %struct.CostInterval* %120, float %63, i32 %2, i32 %119, i32 %59)
  %121 = add nuw i64 %48, 1
  %122 = load i64, i64* %37, align 8
  %123 = icmp ult i64 %121, %122
  br i1 %123, label %47, label %124

124:                                              ; preds = %118, %47, %32, %35, %8
  ret void
}

declare void @VP8LColorCacheClear(%struct.VP8LColorCache*) local_unnamed_addr #2

declare void @VP8LRefsCursorInit(%struct.VP8LRefsCursor* sret, %struct.VP8LBackwardRefs*) local_unnamed_addr #2

declare %struct.VP8LHistogram* @VP8LAllocateHistogram(i32) local_unnamed_addr #2

declare void @VP8LHistogramInit(%struct.VP8LHistogram*, i32, i32) local_unnamed_addr #2

declare void @VP8LHistogramAddSinglePixOrCopy(%struct.VP8LHistogram*, %struct.PixOrCopy*, i32 (i32, i32)*, i32) local_unnamed_addr #2

declare void @VP8LFreeHistogram(%struct.VP8LHistogram*) local_unnamed_addr #2

declare void @VP8LRefsCursorNextBlock(%struct.VP8LRefsCursor*) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #4

; Function Attrs: inlinehint nounwind ssp uwtable
define internal fastcc void @InsertInterval(%struct.CostManager* nocapture, %struct.CostInterval*, float, i32, i32, i32) unnamed_addr #3 {
  %7 = icmp slt i32 %4, %5
  br i1 %7, label %8, label %183

8:                                                ; preds = %6
  %9 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 1
  %10 = load i32, i32* %9, align 8
  %11 = icmp sgt i32 %10, 499
  br i1 %11, label %12, label %57

12:                                               ; preds = %8
  %13 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 5
  %14 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 6
  %15 = sext i32 %4 to i64
  %16 = sext i32 %5 to i64
  %17 = sub nsw i64 %16, %15
  %18 = xor i64 %15, -1
  %19 = and i64 %17, 1
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %34, label %21

21:                                               ; preds = %12
  %22 = load float*, float** %13, align 8
  %23 = getelementptr inbounds float, float* %22, i64 %15
  %24 = load float, float* %23, align 4
  %25 = fcmp ogt float %24, %2
  br i1 %25, label %26, label %32

26:                                               ; preds = %21
  store float %2, float* %23, align 4
  %27 = sub i32 %4, %3
  %28 = trunc i32 %27 to i16
  %29 = add i16 %28, 1
  %30 = load i16*, i16** %14, align 8
  %31 = getelementptr inbounds i16, i16* %30, i64 %15
  store i16 %29, i16* %31, align 2
  br label %32

32:                                               ; preds = %26, %21
  %33 = add nsw i64 %15, 1
  br label %34

34:                                               ; preds = %12, %32
  %35 = phi i64 [ %15, %12 ], [ %33, %32 ]
  %36 = sub nsw i64 0, %16
  %37 = icmp eq i64 %18, %36
  br i1 %37, label %183, label %38

38:                                               ; preds = %34, %191
  %39 = phi i64 [ %192, %191 ], [ %35, %34 ]
  %40 = load float*, float** %13, align 8
  %41 = getelementptr inbounds float, float* %40, i64 %39
  %42 = load float, float* %41, align 4
  %43 = fcmp ogt float %42, %2
  br i1 %43, label %44, label %51

44:                                               ; preds = %38
  store float %2, float* %41, align 4
  %45 = trunc i64 %39 to i32
  %46 = sub i32 %45, %3
  %47 = trunc i32 %46 to i16
  %48 = add i16 %47, 1
  %49 = load i16*, i16** %14, align 8
  %50 = getelementptr inbounds i16, i16* %49, i64 %39
  store i16 %48, i16* %50, align 2
  br label %51

51:                                               ; preds = %44, %38
  %52 = add nsw i64 %39, 1
  %53 = load float*, float** %13, align 8
  %54 = getelementptr inbounds float, float* %53, i64 %52
  %55 = load float, float* %54, align 4
  %56 = fcmp ogt float %55, %2
  br i1 %56, label %184, label %191

57:                                               ; preds = %8
  %58 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 8
  %59 = load %struct.CostInterval*, %struct.CostInterval** %58, align 8
  %60 = icmp eq %struct.CostInterval* %59, null
  br i1 %60, label %61, label %114

61:                                               ; preds = %57
  %62 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 9
  %63 = load %struct.CostInterval*, %struct.CostInterval** %62, align 8
  %64 = icmp eq %struct.CostInterval* %63, null
  br i1 %64, label %65, label %114

65:                                               ; preds = %61
  %66 = tail call i8* @WebPSafeMalloc(i64 1, i64 32) #5
  %67 = bitcast i8* %66 to %struct.CostInterval*
  %68 = icmp eq i8* %66, null
  br i1 %68, label %69, label %121

69:                                               ; preds = %65
  %70 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 5
  %71 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 6
  %72 = sext i32 %4 to i64
  %73 = sext i32 %5 to i64
  %74 = sub nsw i64 %73, %72
  %75 = xor i64 %72, -1
  %76 = and i64 %74, 1
  %77 = icmp eq i64 %76, 0
  br i1 %77, label %91, label %78

78:                                               ; preds = %69
  %79 = load float*, float** %70, align 8
  %80 = getelementptr inbounds float, float* %79, i64 %72
  %81 = load float, float* %80, align 4
  %82 = fcmp ogt float %81, %2
  br i1 %82, label %83, label %89

83:                                               ; preds = %78
  store float %2, float* %80, align 4
  %84 = sub i32 %4, %3
  %85 = trunc i32 %84 to i16
  %86 = add i16 %85, 1
  %87 = load i16*, i16** %71, align 8
  %88 = getelementptr inbounds i16, i16* %87, i64 %72
  store i16 %86, i16* %88, align 2
  br label %89

89:                                               ; preds = %83, %78
  %90 = add nsw i64 %72, 1
  br label %91

91:                                               ; preds = %69, %89
  %92 = phi i64 [ %72, %69 ], [ %90, %89 ]
  %93 = sub nsw i64 0, %73
  %94 = icmp eq i64 %75, %93
  br i1 %94, label %183, label %95

95:                                               ; preds = %91, %201
  %96 = phi i64 [ %202, %201 ], [ %92, %91 ]
  %97 = load float*, float** %70, align 8
  %98 = getelementptr inbounds float, float* %97, i64 %96
  %99 = load float, float* %98, align 4
  %100 = fcmp ogt float %99, %2
  br i1 %100, label %101, label %108

101:                                              ; preds = %95
  store float %2, float* %98, align 4
  %102 = trunc i64 %96 to i32
  %103 = sub i32 %102, %3
  %104 = trunc i32 %103 to i16
  %105 = add i16 %104, 1
  %106 = load i16*, i16** %71, align 8
  %107 = getelementptr inbounds i16, i16* %106, i64 %96
  store i16 %105, i16* %107, align 2
  br label %108

108:                                              ; preds = %101, %95
  %109 = add nsw i64 %96, 1
  %110 = load float*, float** %70, align 8
  %111 = getelementptr inbounds float, float* %110, i64 %109
  %112 = load float, float* %111, align 4
  %113 = fcmp ogt float %112, %2
  br i1 %113, label %194, label %201

114:                                              ; preds = %61, %57
  %115 = phi %struct.CostInterval* [ %59, %57 ], [ %63, %61 ]
  %116 = phi %struct.CostInterval** [ %58, %57 ], [ %62, %61 ]
  %117 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %115, i64 0, i32 5
  %118 = bitcast %struct.CostInterval** %117 to i64*
  %119 = load i64, i64* %118, align 8
  %120 = bitcast %struct.CostInterval** %116 to i64*
  store i64 %119, i64* %120, align 8
  br label %121

121:                                              ; preds = %114, %65
  %122 = phi %struct.CostInterval* [ %67, %65 ], [ %115, %114 ]
  %123 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 0
  store float %2, float* %123, align 8
  %124 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 3
  store i32 %3, i32* %124, align 4
  %125 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 1
  store i32 %4, i32* %125, align 4
  %126 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 2
  store i32 %5, i32* %126, align 8
  %127 = icmp eq %struct.CostInterval* %1, null
  br i1 %127, label %128, label %132

128:                                              ; preds = %121
  %129 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 0
  %130 = load %struct.CostInterval*, %struct.CostInterval** %129, align 8
  %131 = icmp eq %struct.CostInterval* %130, null
  br i1 %131, label %143, label %132

132:                                              ; preds = %128, %121
  %133 = phi %struct.CostInterval* [ %1, %121 ], [ %130, %128 ]
  br label %134

134:                                              ; preds = %132, %139
  %135 = phi %struct.CostInterval* [ %141, %139 ], [ %133, %132 ]
  %136 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %135, i64 0, i32 1
  %137 = load i32, i32* %136, align 4
  %138 = icmp sgt i32 %137, %4
  br i1 %138, label %139, label %143

139:                                              ; preds = %134
  %140 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %135, i64 0, i32 4
  %141 = load %struct.CostInterval*, %struct.CostInterval** %140, align 8
  %142 = icmp eq %struct.CostInterval* %141, null
  br i1 %142, label %143, label %134

143:                                              ; preds = %139, %134, %128
  %144 = phi %struct.CostInterval* [ null, %128 ], [ null, %139 ], [ %135, %134 ]
  br label %145

145:                                              ; preds = %143, %152
  %146 = phi %struct.CostInterval* [ %150, %152 ], [ %144, %143 ]
  %147 = icmp eq %struct.CostInterval* %146, null
  br i1 %147, label %165, label %148

148:                                              ; preds = %145
  %149 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %146, i64 0, i32 5
  %150 = load %struct.CostInterval*, %struct.CostInterval** %149, align 8
  %151 = icmp eq %struct.CostInterval* %150, null
  br i1 %151, label %156, label %152

152:                                              ; preds = %148
  %153 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %150, i64 0, i32 1
  %154 = load i32, i32* %153, align 4
  %155 = icmp slt i32 %154, %4
  br i1 %155, label %145, label %156

156:                                              ; preds = %152, %148
  %157 = phi i1 [ false, %152 ], [ true, %148 ]
  %158 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %146, i64 0, i32 5
  %159 = icmp eq %struct.CostInterval* %122, null
  %160 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 0
  %161 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 5
  %162 = select i1 %159, %struct.CostInterval** %160, %struct.CostInterval** %161
  store %struct.CostInterval* %150, %struct.CostInterval** %162, align 8
  br i1 %157, label %175, label %163

163:                                              ; preds = %156
  %164 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %150, i64 0, i32 4
  store %struct.CostInterval* %122, %struct.CostInterval** %164, align 8
  br label %175

165:                                              ; preds = %145
  %166 = getelementptr inbounds %struct.CostManager, %struct.CostManager* %0, i64 0, i32 0
  %167 = load %struct.CostInterval*, %struct.CostInterval** %166, align 8
  %168 = icmp eq %struct.CostInterval* %122, null
  br i1 %168, label %171, label %169

169:                                              ; preds = %165
  %170 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 5
  store %struct.CostInterval* %167, %struct.CostInterval** %170, align 8
  br label %171

171:                                              ; preds = %169, %165
  %172 = icmp eq %struct.CostInterval* %167, null
  br i1 %172, label %175, label %173

173:                                              ; preds = %171
  %174 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %167, i64 0, i32 4
  store %struct.CostInterval* %122, %struct.CostInterval** %174, align 8
  br label %175

175:                                              ; preds = %171, %173, %156, %163
  %176 = phi %struct.CostInterval** [ %158, %163 ], [ %158, %156 ], [ %166, %173 ], [ %166, %171 ]
  store %struct.CostInterval* %122, %struct.CostInterval** %176, align 8
  %177 = icmp eq %struct.CostInterval* %122, null
  br i1 %177, label %180, label %178

178:                                              ; preds = %175
  %179 = getelementptr inbounds %struct.CostInterval, %struct.CostInterval* %122, i64 0, i32 4
  store %struct.CostInterval* %146, %struct.CostInterval** %179, align 8
  br label %180

180:                                              ; preds = %175, %178
  %181 = load i32, i32* %9, align 8
  %182 = add nsw i32 %181, 1
  store i32 %182, i32* %9, align 8
  br label %183

183:                                              ; preds = %91, %201, %34, %191, %6, %180
  ret void

184:                                              ; preds = %51
  store float %2, float* %54, align 4
  %185 = trunc i64 %52 to i32
  %186 = sub i32 %185, %3
  %187 = trunc i32 %186 to i16
  %188 = add i16 %187, 1
  %189 = load i16*, i16** %14, align 8
  %190 = getelementptr inbounds i16, i16* %189, i64 %52
  store i16 %188, i16* %190, align 2
  br label %191

191:                                              ; preds = %184, %51
  %192 = add nsw i64 %39, 2
  %193 = icmp eq i64 %192, %16
  br i1 %193, label %183, label %38

194:                                              ; preds = %108
  store float %2, float* %111, align 4
  %195 = trunc i64 %109 to i32
  %196 = sub i32 %195, %3
  %197 = trunc i32 %196 to i16
  %198 = add i16 %197, 1
  %199 = load i16*, i16** %71, align 8
  %200 = getelementptr inbounds i16, i16* %199, i64 %109
  store i16 %198, i16* %200, align 2
  br label %201

201:                                              ; preds = %194, %108
  %202 = add nsw i64 %96, 2
  %203 = icmp eq i64 %202, %73
  br i1 %203, label %183, label %95
}

declare void @VP8LClearBackwardRefs(%struct.VP8LBackwardRefs*) local_unnamed_addr #2

declare void @VP8LBackwardRefsCursorAdd(%struct.VP8LBackwardRefs*, i64) local_unnamed_addr #2

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { inlinehint nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone speculatable }
attributes #5 = { nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = distinct !{!2, !3}
!3 = !{!"llvm.loop.isvectorized", i32 1}
!4 = distinct !{!4, !5, !3}
!5 = !{!"llvm.loop.unroll.runtime.disable"}
!6 = distinct !{!6, !3}
!7 = distinct !{!7, !3}
!8 = distinct !{!8, !3}
!9 = !{i32 0, i32 33}
!10 = distinct !{!10, !11}
!11 = !{!"llvm.loop.unroll.disable"}
