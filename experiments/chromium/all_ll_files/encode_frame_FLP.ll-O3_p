; ModuleID = '../../third_party/opus/src/silk/float/encode_frame_FLP.c'
source_filename = "../../third_party/opus/src/silk/float/encode_frame_FLP.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"
module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"
module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"

%struct.silk_encoder_state = type { [2 x i32], i32, i32, %struct.silk_LP_state, %struct.silk_VAD_state, %struct.silk_nsq_state, [16 x i16], i32, i32, i8, i8, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8*, i8*, %struct.silk_NLSF_CB_struct*, [4 x i32], i32, i32, [3 x i8], i8, [3 x i32], %struct.SideInfoIndices, [320 x i8], i32, [322 x i16], i32, i32, i32, i32, i32, i32, i32, i32, i16, %struct._silk_resampler_state_struct, i32, i32, i32, i32, i32, i32, [3 x %struct.SideInfoIndices], [3 x [320 x i8]] }
%struct.silk_LP_state = type { [2 x i32], i32, i32, i32 }
%struct.silk_VAD_state = type { [2 x i32], [2 x i32], [2 x i32], [4 x i32], [4 x i32], i16, [4 x i32], [4 x i32], [4 x i32], i32 }
%struct.silk_nsq_state = type { [640 x i16], [640 x i32], [96 x i32], [24 x i32], i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.silk_NLSF_CB_struct = type { i16, i16, i16, i16, i8*, i16*, i8*, i8*, i8*, i8*, i8*, i16* }
%struct.SideInfoIndices = type { [4 x i8], [4 x i8], [17 x i8], i16, i8, i8, i8, i8, i8, i8, i8 }
%struct._silk_resampler_state_struct = type { [6 x i32], %union.anon, [48 x i16], i32, i32, i32, i32, i32, i32, i32, i32, i16* }
%union.anon = type { [36 x i32] }
%struct.silk_encoder_state_FLP = type { %struct.silk_encoder_state, %struct.silk_shape_state_FLP, [720 x float], float }
%struct.silk_shape_state_FLP = type { i8, float, float }
%struct.ec_ctx = type { i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.silk_encoder_control_FLP = type { [4 x float], [2 x [16 x float]], [20 x float], float, [4 x i32], [96 x float], [4 x float], [4 x float], [4 x float], [4 x float], float, float, float, float, float, [4 x float], [4 x i32], i8 }

@SILK_VAD_GETSA_Q8_IMPL = external local_unnamed_addr constant [8 x i32 (%struct.silk_encoder_state*, i16*)*], align 16
@__const.silk_encode_frame_FLP.sEncCtrl = private unnamed_addr constant { [4 x float], [2 x [16 x float]], [20 x float], float, [4 x i32], [96 x float], [4 x float], [4 x float], [4 x float], [4 x float], float, float, float, float, float, [4 x float], [4 x i32], i8, [3 x i8] } { [4 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [2 x [16 x float]] [[16 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [16 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000]], [20 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], float 0xFFFFFFFFE0000000, [4 x i32] [i32 -1431655766, i32 -1431655766, i32 -1431655766, i32 -1431655766], [96 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [4 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [4 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [4 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [4 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, [4 x float] [float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000, float 0xFFFFFFFFE0000000], [4 x i32] [i32 -1431655766, i32 -1431655766, i32 -1431655766, i32 -1431655766], i8 -86, [3 x i8] c"\AA\AA\AA" }, align 4
@.str = private unnamed_addr constant [47 x i8] c"assertion failed: sRangeEnc_copy2.offs <= 1275\00", align 1
@.str.1 = private unnamed_addr constant [57 x i8] c"../../third_party/opus/src/silk/float/encode_frame_FLP.c\00", align 1
@.str.2 = private unnamed_addr constant [43 x i8] c"assertion failed: psRangeEnc->offs <= 1275\00", align 1

; Function Attrs: nounwind ssp uwtable
define hidden void @silk_encode_do_VAD_FLP(%struct.silk_encoder_state_FLP*, i32) local_unnamed_addr #0 {
  %3 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0
  %4 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 57
  %5 = load i32, i32* %4, align 4
  %6 = and i32 %5, 7
  %7 = zext i32 %6 to i64
  %8 = getelementptr inbounds [8 x i32 (%struct.silk_encoder_state*, i16*)*], [8 x i32 (%struct.silk_encoder_state*, i16*)*]* @SILK_VAD_GETSA_Q8_IMPL, i64 0, i64 %7
  %9 = load i32 (%struct.silk_encoder_state*, i16*)*, i32 (%struct.silk_encoder_state*, i16*)** %8, align 8
  %10 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 1
  %11 = tail call i32 %9(%struct.silk_encoder_state* %3, i16* %10) #5
  %12 = icmp eq i32 %1, 0
  %13 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 7
  %14 = load i32, i32* %13, align 4
  br i1 %12, label %15, label %18

15:                                               ; preds = %2
  %16 = icmp sgt i32 %14, 12
  br i1 %16, label %17, label %20

17:                                               ; preds = %15
  store i32 12, i32* %13, align 4
  br label %20

18:                                               ; preds = %2
  %19 = icmp slt i32 %14, 13
  br i1 %19, label %20, label %31

20:                                               ; preds = %15, %17, %18
  %21 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 5
  store i8 0, i8* %21, align 1
  %22 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 71
  %23 = load i32, i32* %22, align 8
  %24 = add nsw i32 %23, 1
  store i32 %24, i32* %22, align 8
  %25 = icmp slt i32 %24, 11
  br i1 %25, label %29, label %26

26:                                               ; preds = %20
  %27 = icmp sgt i32 %23, 29
  br i1 %27, label %28, label %35

28:                                               ; preds = %26
  store i32 10, i32* %22, align 8
  br label %29

29:                                               ; preds = %20, %28
  %30 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 70
  store i32 0, i32* %30, align 4
  br label %35

31:                                               ; preds = %18
  %32 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 71
  store i32 0, i32* %32, align 8
  %33 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 70
  store i32 0, i32* %33, align 4
  %34 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 5
  store i8 1, i8* %34, align 1
  br label %35

35:                                               ; preds = %26, %29, %31
  %36 = phi i8 [ 1, %31 ], [ 0, %29 ], [ 0, %26 ]
  %37 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 61
  %38 = load i32, i32* %37, align 4
  %39 = sext i32 %38 to i64
  %40 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 52, i64 %39
  store i8 %36, i8* %40, align 1
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: nounwind ssp uwtable
define hidden i32 @silk_encode_frame_FLP(%struct.silk_encoder_state_FLP*, i32* nocapture, %struct.ec_ctx*, i32, i32, i32) local_unnamed_addr #0 {
  %7 = alloca [4 x i32], align 16
  %8 = alloca [4 x float], align 16
  %9 = alloca %struct.silk_nsq_state, align 4
  %10 = alloca %struct.silk_encoder_control_FLP, align 4
  %11 = alloca [672 x float], align 16
  %12 = alloca %struct.ec_ctx, align 8
  %13 = alloca [28 x i8], align 8
  %14 = alloca [24 x i8], align 8
  %15 = alloca %struct.silk_nsq_state, align 4
  %16 = alloca %struct.silk_nsq_state, align 4
  %17 = alloca [4 x i32], align 16
  %18 = alloca [1275 x i8], align 16
  %19 = alloca [4 x i32], align 16
  %20 = alloca i64, align 8
  %21 = bitcast i64* %20 to [4 x i16]*
  %22 = alloca [4 x i32], align 16
  %23 = bitcast %struct.silk_encoder_control_FLP* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 748, i8* nonnull %23) #5
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 4 %23, i8* align 4 bitcast ({ [4 x float], [2 x [16 x float]], [20 x float], float, [4 x i32], [96 x float], [4 x float], [4 x float], [4 x float], [4 x float], float, float, float, float, float, [4 x float], [4 x i32], i8, [3 x i8] }* @__const.silk_encode_frame_FLP.sEncCtrl to i8*), i64 748, i1 false)
  %24 = bitcast [672 x float]* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 2688, i8* nonnull %24) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %24, i8 -1, i64 2688, i1 false)
  %25 = bitcast %struct.ec_ctx* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 56, i8* nonnull %25)
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %25, i8 -86, i64 56, i1 false)
  %26 = getelementptr inbounds [28 x i8], [28 x i8]* %13, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 28, i8* nonnull %26)
  %27 = getelementptr inbounds [24 x i8], [24 x i8]* %14, i64 0, i64 0
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %27)
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %26, i8 -86, i64 28, i1 false)
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %27, i8 -86, i64 24, i1 false)
  %28 = bitcast %struct.silk_nsq_state* %15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4352, i8* nonnull %28)
  call void @llvm.memset.p0i8.i64(i8* nonnull align 4 %28, i8 -86, i64 4352, i1 false)
  %29 = bitcast %struct.silk_nsq_state* %16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4352, i8* nonnull %29)
  call void @llvm.memset.p0i8.i64(i8* nonnull align 4 %29, i8 -86, i64 4352, i1 false)
  %30 = bitcast [4 x i32]* %17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %30) #5
  %31 = getelementptr inbounds [4 x i32], [4 x i32]* %17, i64 0, i64 0
  %32 = getelementptr inbounds [1275 x i8], [1275 x i8]* %18, i64 0, i64 0
  %33 = bitcast [4 x i32]* %17 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %33, i8 -86, i64 16, i1 false)
  call void @llvm.lifetime.start.p0i8(i64 1275, i8* nonnull %32)
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %32, i8 -86, i64 1275, i1 false)
  %34 = bitcast [4 x i32]* %19 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %34) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %34, i8 0, i64 16, i1 false)
  %35 = bitcast i64* %20 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %35) #5
  %36 = bitcast [4 x i32]* %22 to i8*
  store i64 -6148914691236517206, i64* %20, align 8
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %36) #5
  %37 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0
  %38 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 30
  %39 = bitcast [4 x i32]* %22 to i8*
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %39, i8 -86, i64 16, i1 false)
  %40 = load i32, i32* %38, align 4
  %41 = add nsw i32 %40, 1
  store i32 %41, i32* %38, align 4
  %42 = trunc i32 %40 to i8
  %43 = and i8 %42, 3
  %44 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55
  %45 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 10
  store i8 %43, i8* %45, align 2
  %46 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 2
  %47 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 23
  %48 = load i32, i32* %47, align 8
  %49 = sext i32 %48 to i64
  %50 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 2, i64 %49
  %51 = getelementptr inbounds [672 x float], [672 x float]* %11, i64 0, i64 0
  %52 = getelementptr inbounds [672 x float], [672 x float]* %11, i64 0, i64 %49
  %53 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 3
  %54 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 1
  %55 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 21
  %56 = load i32, i32* %55, align 8
  tail call void @silk_LP_variable_cutoff(%struct.silk_LP_state* %53, i16* %54, i32 %56) #5
  %57 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 19
  %58 = load i32, i32* %57, align 8
  %59 = mul nsw i32 %58, 5
  %60 = sext i32 %59 to i64
  %61 = getelementptr inbounds float, float* %50, i64 %60
  %62 = load i32, i32* %55, align 8
  %63 = icmp sgt i32 %62, 0
  br i1 %63, label %64, label %209

64:                                               ; preds = %6
  %65 = sext i32 %62 to i64
  %66 = icmp ult i32 %62, 8
  br i1 %66, label %195, label %67

67:                                               ; preds = %64
  %68 = add nsw i64 %65, -1
  %69 = add nsw i64 %49, %65
  %70 = add nsw i64 %69, %60
  %71 = add nsw i64 %70, 1800
  %72 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 0, i64 %71
  %73 = ptrtoint i32* %72 to i64
  %74 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %68, i64 4)
  %75 = extractvalue { i64, i1 } %74, 0
  %76 = extractvalue { i64, i1 } %74, 1
  %77 = icmp ugt i64 %75, %73
  %78 = or i1 %77, %76
  %79 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 0, i64 1278
  %80 = bitcast i32* %79 to i8*
  %81 = shl nsw i64 %65, 1
  %82 = getelementptr i8, i8* %80, i64 %81
  %83 = ptrtoint i8* %82 to i64
  %84 = call { i64, i1 } @llvm.umul.with.overflow.i64(i64 %68, i64 2)
  %85 = extractvalue { i64, i1 } %84, 0
  %86 = extractvalue { i64, i1 } %84, 1
  %87 = icmp ugt i64 %85, %83
  %88 = or i1 %87, %86
  %89 = or i1 %78, %88
  br i1 %89, label %195, label %90

90:                                               ; preds = %67
  %91 = add nsw i64 %49, %60
  %92 = add nsw i64 %91, 1801
  %93 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 0, i64 %92
  %94 = bitcast i32* %93 to i8*
  %95 = add nsw i64 %49, %65
  %96 = add nsw i64 %95, %60
  %97 = add nsw i64 %96, 1801
  %98 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 0, i64 %97
  %99 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 1
  %100 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 0, i64 1278
  %101 = bitcast i32* %100 to i8*
  %102 = shl nsw i64 %65, 1
  %103 = add nsw i64 %102, 2
  %104 = getelementptr i8, i8* %101, i64 %103
  %105 = icmp ugt i8* %104, %94
  %106 = bitcast i32* %98 to i16*
  %107 = icmp ult i16* %99, %106
  %108 = and i1 %105, %107
  br i1 %108, label %195, label %109

109:                                              ; preds = %90
  %110 = and i64 %65, -8
  %111 = sub nsw i64 %65, %110
  %112 = add nsw i64 %110, -8
  %113 = lshr exact i64 %112, 3
  %114 = add nuw nsw i64 %113, 1
  %115 = and i64 %114, 1
  %116 = icmp eq i64 %112, 0
  br i1 %116, label %168, label %117

117:                                              ; preds = %109
  %118 = sub nuw nsw i64 %114, %115
  br label %119

119:                                              ; preds = %119, %117
  %120 = phi i64 [ 0, %117 ], [ %165, %119 ]
  %121 = phi i64 [ %118, %117 ], [ %166, %119 ]
  %122 = sub i64 %65, %120
  %123 = add nsw i64 %122, -1
  %124 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 %122
  %125 = getelementptr inbounds i16, i16* %124, i64 -3
  %126 = bitcast i16* %125 to <4 x i16>*
  %127 = load <4 x i16>, <4 x i16>* %126, align 2, !alias.scope !2
  %128 = shufflevector <4 x i16> %127, <4 x i16> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %129 = getelementptr inbounds i16, i16* %124, i64 -7
  %130 = bitcast i16* %129 to <4 x i16>*
  %131 = load <4 x i16>, <4 x i16>* %130, align 2, !alias.scope !2
  %132 = shufflevector <4 x i16> %131, <4 x i16> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %133 = sitofp <4 x i16> %128 to <4 x float>
  %134 = sitofp <4 x i16> %132 to <4 x float>
  %135 = getelementptr inbounds float, float* %61, i64 %123
  %136 = shufflevector <4 x float> %133, <4 x float> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %137 = getelementptr inbounds float, float* %135, i64 -3
  %138 = bitcast float* %137 to <4 x float>*
  store <4 x float> %136, <4 x float>* %138, align 4, !alias.scope !5, !noalias !2
  %139 = shufflevector <4 x float> %134, <4 x float> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %140 = getelementptr inbounds float, float* %135, i64 -4
  %141 = getelementptr inbounds float, float* %140, i64 -3
  %142 = bitcast float* %141 to <4 x float>*
  store <4 x float> %139, <4 x float>* %142, align 4, !alias.scope !5, !noalias !2
  %143 = or i64 %120, 8
  %144 = sub i64 %65, %143
  %145 = add nsw i64 %144, -1
  %146 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 %144
  %147 = getelementptr inbounds i16, i16* %146, i64 -3
  %148 = bitcast i16* %147 to <4 x i16>*
  %149 = load <4 x i16>, <4 x i16>* %148, align 2, !alias.scope !2
  %150 = shufflevector <4 x i16> %149, <4 x i16> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %151 = getelementptr inbounds i16, i16* %146, i64 -7
  %152 = bitcast i16* %151 to <4 x i16>*
  %153 = load <4 x i16>, <4 x i16>* %152, align 2, !alias.scope !2
  %154 = shufflevector <4 x i16> %153, <4 x i16> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %155 = sitofp <4 x i16> %150 to <4 x float>
  %156 = sitofp <4 x i16> %154 to <4 x float>
  %157 = getelementptr inbounds float, float* %61, i64 %145
  %158 = shufflevector <4 x float> %155, <4 x float> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %159 = getelementptr inbounds float, float* %157, i64 -3
  %160 = bitcast float* %159 to <4 x float>*
  store <4 x float> %158, <4 x float>* %160, align 4, !alias.scope !5, !noalias !2
  %161 = shufflevector <4 x float> %156, <4 x float> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %162 = getelementptr inbounds float, float* %157, i64 -4
  %163 = getelementptr inbounds float, float* %162, i64 -3
  %164 = bitcast float* %163 to <4 x float>*
  store <4 x float> %161, <4 x float>* %164, align 4, !alias.scope !5, !noalias !2
  %165 = add i64 %120, 16
  %166 = add i64 %121, -2
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %168, label %119, !llvm.loop !7

168:                                              ; preds = %119, %109
  %169 = phi i64 [ 0, %109 ], [ %165, %119 ]
  %170 = icmp eq i64 %115, 0
  br i1 %170, label %193, label %171

171:                                              ; preds = %168
  %172 = sub i64 %65, %169
  %173 = add nsw i64 %172, -1
  %174 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 %172
  %175 = getelementptr inbounds i16, i16* %174, i64 -3
  %176 = bitcast i16* %175 to <4 x i16>*
  %177 = load <4 x i16>, <4 x i16>* %176, align 2, !alias.scope !2
  %178 = shufflevector <4 x i16> %177, <4 x i16> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %179 = getelementptr inbounds i16, i16* %174, i64 -7
  %180 = bitcast i16* %179 to <4 x i16>*
  %181 = load <4 x i16>, <4 x i16>* %180, align 2, !alias.scope !2
  %182 = shufflevector <4 x i16> %181, <4 x i16> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %183 = sitofp <4 x i16> %178 to <4 x float>
  %184 = sitofp <4 x i16> %182 to <4 x float>
  %185 = getelementptr inbounds float, float* %61, i64 %173
  %186 = shufflevector <4 x float> %183, <4 x float> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %187 = getelementptr inbounds float, float* %185, i64 -3
  %188 = bitcast float* %187 to <4 x float>*
  store <4 x float> %186, <4 x float>* %188, align 4, !alias.scope !5, !noalias !2
  %189 = shufflevector <4 x float> %184, <4 x float> undef, <4 x i32> <i32 3, i32 2, i32 1, i32 0>
  %190 = getelementptr inbounds float, float* %185, i64 -4
  %191 = getelementptr inbounds float, float* %190, i64 -3
  %192 = bitcast float* %191 to <4 x float>*
  store <4 x float> %189, <4 x float>* %192, align 4, !alias.scope !5, !noalias !2
  br label %193

193:                                              ; preds = %168, %171
  %194 = icmp eq i64 %110, %65
  br i1 %194, label %205, label %195

195:                                              ; preds = %193, %90, %67, %64
  %196 = phi i64 [ %65, %90 ], [ %65, %67 ], [ %65, %64 ], [ %111, %193 ]
  br label %197

197:                                              ; preds = %195, %197
  %198 = phi i64 [ %199, %197 ], [ %196, %195 ]
  %199 = add nsw i64 %198, -1
  %200 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 58, i64 %198
  %201 = load i16, i16* %200, align 2
  %202 = sitofp i16 %201 to float
  %203 = getelementptr inbounds float, float* %61, i64 %199
  store float %202, float* %203, align 4
  %204 = icmp sgt i64 %199, 0
  br i1 %204, label %197, label %205, !llvm.loop !9

205:                                              ; preds = %197, %193
  %206 = load i32, i32* %57, align 8
  %207 = mul nsw i32 %206, 5
  %208 = sext i32 %207 to i64
  br label %209

209:                                              ; preds = %205, %6
  %210 = phi i64 [ %208, %205 ], [ %60, %6 ]
  %211 = getelementptr inbounds float, float* %50, i64 %210
  %212 = load float, float* %211, align 4
  %213 = fadd float %212, 0x3EB0C6F7A0000000
  store float %213, float* %211, align 4
  %214 = load i32, i32* %57, align 8
  %215 = mul nsw i32 %214, 5
  %216 = load i32, i32* %55, align 8
  %217 = ashr i32 %216, 3
  %218 = add nsw i32 %217, %215
  %219 = sext i32 %218 to i64
  %220 = getelementptr inbounds float, float* %50, i64 %219
  %221 = load float, float* %220, align 4
  %222 = fadd float %221, 0x3EB0C6F7A0000000
  store float %222, float* %220, align 4
  %223 = load i32, i32* %57, align 8
  %224 = mul nsw i32 %223, 5
  %225 = load i32, i32* %55, align 8
  %226 = ashr i32 %225, 3
  %227 = shl nsw i32 %226, 1
  %228 = add nsw i32 %227, %224
  %229 = sext i32 %228 to i64
  %230 = getelementptr inbounds float, float* %50, i64 %229
  %231 = load float, float* %230, align 4
  %232 = fadd float %231, 0xBEB0C6F7A0000000
  store float %232, float* %230, align 4
  %233 = load i32, i32* %57, align 8
  %234 = mul nsw i32 %233, 5
  %235 = load i32, i32* %55, align 8
  %236 = ashr i32 %235, 3
  %237 = mul nsw i32 %236, 3
  %238 = add nsw i32 %237, %234
  %239 = sext i32 %238 to i64
  %240 = getelementptr inbounds float, float* %50, i64 %239
  %241 = load float, float* %240, align 4
  %242 = fadd float %241, 0xBEB0C6F7A0000000
  store float %242, float* %240, align 4
  %243 = load i32, i32* %57, align 8
  %244 = mul nsw i32 %243, 5
  %245 = load i32, i32* %55, align 8
  %246 = ashr i32 %245, 3
  %247 = shl nsw i32 %246, 2
  %248 = add nsw i32 %247, %244
  %249 = sext i32 %248 to i64
  %250 = getelementptr inbounds float, float* %50, i64 %249
  %251 = load float, float* %250, align 4
  %252 = fadd float %251, 0x3EB0C6F7A0000000
  store float %252, float* %250, align 4
  %253 = load i32, i32* %57, align 8
  %254 = load i32, i32* %55, align 8
  %255 = ashr i32 %254, 3
  %256 = add i32 %255, %253
  %257 = mul i32 %256, 5
  %258 = sext i32 %257 to i64
  %259 = getelementptr inbounds float, float* %50, i64 %258
  %260 = load float, float* %259, align 4
  %261 = fadd float %260, 0x3EB0C6F7A0000000
  store float %261, float* %259, align 4
  %262 = load i32, i32* %57, align 8
  %263 = mul nsw i32 %262, 5
  %264 = load i32, i32* %55, align 8
  %265 = ashr i32 %264, 3
  %266 = mul nsw i32 %265, 6
  %267 = add nsw i32 %266, %263
  %268 = sext i32 %267 to i64
  %269 = getelementptr inbounds float, float* %50, i64 %268
  %270 = load float, float* %269, align 4
  %271 = fadd float %270, 0xBEB0C6F7A0000000
  store float %271, float* %269, align 4
  %272 = load i32, i32* %57, align 8
  %273 = mul nsw i32 %272, 5
  %274 = load i32, i32* %55, align 8
  %275 = ashr i32 %274, 3
  %276 = mul nsw i32 %275, 7
  %277 = add nsw i32 %276, %273
  %278 = sext i32 %277 to i64
  %279 = getelementptr inbounds float, float* %50, i64 %278
  %280 = load float, float* %279, align 4
  %281 = fadd float %280, 0xBEB0C6F7A0000000
  store float %281, float* %279, align 4
  %282 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 45
  %283 = load i32, i32* %282, align 8
  %284 = icmp eq i32 %283, 0
  br i1 %284, label %285, label %896

285:                                              ; preds = %209
  %286 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 57
  %287 = load i32, i32* %286, align 4
  call void @silk_find_pitch_lags_FLP(%struct.silk_encoder_state_FLP* %0, %struct.silk_encoder_control_FLP* nonnull %10, float* nonnull %51, float* %50, i32 %287) #5
  call void @silk_noise_shape_analysis_FLP(%struct.silk_encoder_state_FLP* %0, %struct.silk_encoder_control_FLP* nonnull %10, float* %52, float* %50) #5
  call void @silk_find_pred_coefs_FLP(%struct.silk_encoder_state_FLP* %0, %struct.silk_encoder_control_FLP* nonnull %10, float* %52, float* %50, i32 %3) #5
  call void @silk_process_gains_FLP(%struct.silk_encoder_state_FLP* %0, %struct.silk_encoder_control_FLP* nonnull %10, i32 %3) #5
  %288 = bitcast [4 x i32]* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %288) #5
  %289 = getelementptr inbounds [4 x i32], [4 x i32]* %7, i64 0, i64 0
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %288, i8 -86, i64 16, i1 false) #5
  %290 = bitcast [4 x float]* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 16, i8* nonnull %290)
  %291 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 61
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %290, i8 -1, i64 16, i1 false)
  %292 = load i32, i32* %291, align 4
  %293 = sext i32 %292 to i64
  %294 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 75, i64 %293
  %295 = bitcast %struct.silk_nsq_state* %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4352, i8* nonnull %295) #5
  call void @llvm.memset.p0i8.i64(i8* nonnull align 4 %295, i8 -86, i64 4352, i1 false) #5
  %296 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 73
  %297 = load i32, i32* %296, align 8
  %298 = icmp eq i32 %297, 0
  br i1 %298, label %425, label %299

299:                                              ; preds = %285
  %300 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 7
  %301 = load i32, i32* %300, align 4
  %302 = icmp sgt i32 %301, 77
  br i1 %302, label %303, label %425

303:                                              ; preds = %299
  %304 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 54, i64 %293
  store i32 1, i32* %304, align 4
  %305 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 5
  %306 = bitcast %struct.silk_nsq_state* %305 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 4 %295, i8* align 4 %306, i64 4352, i1 false) #5
  %307 = getelementptr inbounds %struct.SideInfoIndices, %struct.SideInfoIndices* %294, i64 0, i32 0, i64 0
  %308 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 0, i64 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %307, i8* align 8 %308, i64 36, i1 false) #5
  %309 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 20
  %310 = load i32, i32* %309, align 4
  %311 = sext i32 %310 to i64
  %312 = shl nsw i64 %311, 2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 %290, i8* nonnull align 4 %23, i64 %312, i1 false) #5
  %313 = load i32, i32* %291, align 4
  %314 = icmp eq i32 %313, 0
  br i1 %314, label %321, label %315

315:                                              ; preds = %303
  %316 = add nsw i32 %313, -1
  %317 = sext i32 %316 to i64
  %318 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 54, i64 %317
  %319 = load i32, i32* %318, align 4
  %320 = icmp eq i32 %319, 0
  br i1 %320, label %321, label %333

321:                                              ; preds = %315, %303
  %322 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 1, i32 0
  %323 = load i8, i8* %322, align 8
  %324 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 9
  store i8 %323, i8* %324, align 4
  %325 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 74
  %326 = load i32, i32* %325, align 4
  %327 = load i8, i8* %307, align 2
  %328 = trunc i32 %326 to i8
  %329 = add i8 %327, %328
  %330 = icmp slt i8 %329, 63
  %331 = select i1 %330, i8 %329, i8 63
  store i8 %331, i8* %307, align 2
  %332 = load i32, i32* %309, align 4
  br label %333

333:                                              ; preds = %321, %315
  %334 = phi i32 [ %332, %321 ], [ %310, %315 ]
  %335 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 9
  %336 = icmp eq i32 %3, 2
  %337 = zext i1 %336 to i32
  call void @silk_gains_dequant(i32* nonnull %289, i8* %307, i8* %335, i32 %337, i32 %334) #5
  %338 = load i32, i32* %309, align 4
  %339 = icmp sgt i32 %338, 0
  br i1 %339, label %340, label %418

340:                                              ; preds = %333
  %341 = sext i32 %338 to i64
  %342 = icmp ult i32 %338, 8
  br i1 %342, label %407, label %343

343:                                              ; preds = %340
  %344 = and i64 %341, -8
  %345 = add nsw i64 %344, -8
  %346 = lshr exact i64 %345, 3
  %347 = add nuw nsw i64 %346, 1
  %348 = and i64 %347, 1
  %349 = icmp eq i64 %345, 0
  br i1 %349, label %387, label %350

350:                                              ; preds = %343
  %351 = sub nuw nsw i64 %347, %348
  br label %352

352:                                              ; preds = %352, %350
  %353 = phi i64 [ 0, %350 ], [ %384, %352 ]
  %354 = phi i64 [ %351, %350 ], [ %385, %352 ]
  %355 = getelementptr inbounds [4 x i32], [4 x i32]* %7, i64 0, i64 %353
  %356 = bitcast i32* %355 to <4 x i32>*
  %357 = load <4 x i32>, <4 x i32>* %356, align 16
  %358 = getelementptr inbounds i32, i32* %355, i64 4
  %359 = bitcast i32* %358 to <4 x i32>*
  %360 = load <4 x i32>, <4 x i32>* %359, align 16
  %361 = sitofp <4 x i32> %357 to <4 x float>
  %362 = sitofp <4 x i32> %360 to <4 x float>
  %363 = fmul <4 x float> %361, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %364 = fmul <4 x float> %362, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %365 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %353
  %366 = bitcast float* %365 to <4 x float>*
  store <4 x float> %363, <4 x float>* %366, align 4
  %367 = getelementptr inbounds float, float* %365, i64 4
  %368 = bitcast float* %367 to <4 x float>*
  store <4 x float> %364, <4 x float>* %368, align 4
  %369 = or i64 %353, 8
  %370 = getelementptr inbounds [4 x i32], [4 x i32]* %7, i64 0, i64 %369
  %371 = bitcast i32* %370 to <4 x i32>*
  %372 = load <4 x i32>, <4 x i32>* %371, align 16
  %373 = getelementptr inbounds i32, i32* %370, i64 4
  %374 = bitcast i32* %373 to <4 x i32>*
  %375 = load <4 x i32>, <4 x i32>* %374, align 16
  %376 = sitofp <4 x i32> %372 to <4 x float>
  %377 = sitofp <4 x i32> %375 to <4 x float>
  %378 = fmul <4 x float> %376, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %379 = fmul <4 x float> %377, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %380 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %369
  %381 = bitcast float* %380 to <4 x float>*
  store <4 x float> %378, <4 x float>* %381, align 4
  %382 = getelementptr inbounds float, float* %380, i64 4
  %383 = bitcast float* %382 to <4 x float>*
  store <4 x float> %379, <4 x float>* %383, align 4
  %384 = add i64 %353, 16
  %385 = add i64 %354, -2
  %386 = icmp eq i64 %385, 0
  br i1 %386, label %387, label %352, !llvm.loop !10

387:                                              ; preds = %352, %343
  %388 = phi i64 [ 0, %343 ], [ %384, %352 ]
  %389 = icmp eq i64 %348, 0
  br i1 %389, label %405, label %390

390:                                              ; preds = %387
  %391 = getelementptr inbounds [4 x i32], [4 x i32]* %7, i64 0, i64 %388
  %392 = bitcast i32* %391 to <4 x i32>*
  %393 = load <4 x i32>, <4 x i32>* %392, align 16
  %394 = getelementptr inbounds i32, i32* %391, i64 4
  %395 = bitcast i32* %394 to <4 x i32>*
  %396 = load <4 x i32>, <4 x i32>* %395, align 16
  %397 = sitofp <4 x i32> %393 to <4 x float>
  %398 = sitofp <4 x i32> %396 to <4 x float>
  %399 = fmul <4 x float> %397, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %400 = fmul <4 x float> %398, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %401 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %388
  %402 = bitcast float* %401 to <4 x float>*
  store <4 x float> %399, <4 x float>* %402, align 4
  %403 = getelementptr inbounds float, float* %401, i64 4
  %404 = bitcast float* %403 to <4 x float>*
  store <4 x float> %400, <4 x float>* %404, align 4
  br label %405

405:                                              ; preds = %387, %390
  %406 = icmp eq i64 %344, %341
  br i1 %406, label %418, label %407

407:                                              ; preds = %405, %340
  %408 = phi i64 [ 0, %340 ], [ %344, %405 ]
  br label %409

409:                                              ; preds = %407, %409
  %410 = phi i64 [ %416, %409 ], [ %408, %407 ]
  %411 = getelementptr inbounds [4 x i32], [4 x i32]* %7, i64 0, i64 %410
  %412 = load i32, i32* %411, align 4
  %413 = sitofp i32 %412 to float
  %414 = fmul float %413, 0x3EF0000000000000
  %415 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %410
  store float %414, float* %415, align 4
  %416 = add nuw nsw i64 %410, 1
  %417 = icmp eq i64 %416, %341
  br i1 %417, label %418, label %409, !llvm.loop !11

418:                                              ; preds = %409, %405, %333
  %419 = load i32, i32* %291, align 4
  %420 = sext i32 %419 to i64
  %421 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 76, i64 %420, i64 0
  call void @silk_NSQ_wrapper_FLP(%struct.silk_encoder_state_FLP* %0, %struct.silk_encoder_control_FLP* nonnull %10, %struct.SideInfoIndices* %294, %struct.silk_nsq_state* nonnull %9, i8* %421, float* %50) #5
  %422 = load i32, i32* %309, align 4
  %423 = sext i32 %422 to i64
  %424 = shl nsw i64 %423, 2
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 4 %23, i8* nonnull align 16 %290, i64 %424, i1 false) #5
  br label %425

425:                                              ; preds = %285, %299, %418
  call void @llvm.lifetime.end.p0i8(i64 4352, i8* nonnull %295) #5
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %290)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %288) #5
  %426 = getelementptr inbounds %struct.SideInfoIndices, %struct.SideInfoIndices* %44, i64 0, i32 0, i64 0
  %427 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 20
  %428 = load i32, i32* %427, align 4
  %429 = call i32 @silk_gains_ID(i8* %426, i32 %428) #5
  %430 = bitcast %struct.ec_ctx* %2 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %25, i8* align 8 %430, i64 56, i1 false)
  %431 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 5
  %432 = bitcast %struct.silk_nsq_state* %431 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 4 %28, i8* align 4 %432, i64 4352, i1 false)
  %433 = load i8, i8* %45, align 2
  %434 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 67
  %435 = load i16, i16* %434, align 4
  %436 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 66
  %437 = load i32, i32* %436, align 8
  %438 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 56, i64 0
  %439 = getelementptr inbounds %struct.ec_ctx, %struct.ec_ctx* %2, i64 0, i32 6
  %440 = getelementptr %struct.ec_ctx, %struct.ec_ctx* %2, i64 0, i32 7
  %441 = bitcast i32* %440 to i8*
  %442 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 5
  %443 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 6
  %444 = getelementptr %struct.ec_ctx, %struct.ec_ctx* %2, i64 0, i32 5
  %445 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 17
  %446 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 1, i32 0
  %447 = icmp eq i32 %3, 2
  %448 = add nsw i32 %4, -5
  %449 = getelementptr inbounds %struct.ec_ctx, %struct.ec_ctx* %2, i64 0, i32 0
  %450 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 10
  %451 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 22
  %452 = zext i1 %447 to i32
  %453 = getelementptr %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 0, i64 0
  br label %454

454:                                              ; preds = %894, %425
  %455 = phi i32 [ 0, %425 ], [ %895, %894 ]
  %456 = phi i32 [ 0, %425 ], [ %740, %894 ]
  %457 = phi i32 [ 0, %425 ], [ %739, %894 ]
  %458 = phi i32 [ -1431655766, %425 ], [ %738, %894 ]
  %459 = phi i32 [ 0, %425 ], [ %737, %894 ]
  %460 = phi i32 [ 0, %425 ], [ %736, %894 ]
  %461 = phi i32 [ 0, %425 ], [ %735, %894 ]
  %462 = phi i32 [ 0, %425 ], [ %734, %894 ]
  %463 = phi i32 [ %429, %425 ], [ %813, %894 ]
  %464 = phi i32 [ -1, %425 ], [ %733, %894 ]
  %465 = phi i32 [ -1, %425 ], [ %732, %894 ]
  %466 = phi i16 [ 256, %425 ], [ %780, %894 ]
  %467 = phi i8 [ 0, %425 ], [ %731, %894 ]
  %468 = icmp eq i32 %463, %464
  br i1 %468, label %528, label %469

469:                                              ; preds = %454
  %470 = icmp eq i32 %463, %465
  br i1 %470, label %528, label %471

471:                                              ; preds = %469
  %472 = icmp eq i32 %455, 0
  br i1 %472, label %474, label %473

473:                                              ; preds = %471
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %430, i8* nonnull align 8 %25, i64 56, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %432, i8* nonnull align 4 %28, i64 4352, i1 false)
  store i8 %433, i8* %45, align 2
  store i16 %435, i16* %434, align 4
  store i32 %437, i32* %436, align 8
  br label %474

474:                                              ; preds = %471, %473
  call void @silk_NSQ_wrapper_FLP(%struct.silk_encoder_state_FLP* %0, %struct.silk_encoder_control_FLP* nonnull %10, %struct.SideInfoIndices* %44, %struct.silk_nsq_state* %431, i8* %438, float* %50) #5
  %475 = icmp ne i32 %455, 6
  %476 = icmp ne i32 %457, 0
  %477 = or i1 %475, %476
  br i1 %477, label %480, label %478

478:                                              ; preds = %474
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %26, i8* align 8 %430, i64 28, i1 false)
  %479 = load i32, i32* %439, align 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %27, i8* align 8 %441, i64 24, i1 false)
  br label %480

480:                                              ; preds = %474, %478
  %481 = phi i32 [ %458, %474 ], [ %479, %478 ]
  %482 = load i32, i32* %291, align 4
  call void @silk_encode_indices(%struct.silk_encoder_state* %37, %struct.ec_ctx* %2, i32 %482, i32 0, i32 %3) #5
  %483 = load i8, i8* %442, align 1
  %484 = sext i8 %483 to i32
  %485 = load i8, i8* %443, align 2
  %486 = sext i8 %485 to i32
  %487 = load i32, i32* %55, align 8
  call void @silk_encode_pulses(%struct.ec_ctx* %2, i32 %484, i32 %486, i8* %438, i32 %487) #5
  %488 = load i32, i32* %444, align 8
  %489 = load i32, i32* %440, align 8
  %490 = call i32 @llvm.ctlz.i32(i32 %489, i1 true) #5, !range !13
  %491 = or i32 %490, -32
  %492 = add i32 %491, %488
  %493 = or i1 %475, %476
  %494 = xor i1 %493, true
  %495 = icmp sgt i32 %492, %4
  %496 = and i1 %495, %494
  br i1 %496, label %497, label %522

497:                                              ; preds = %480
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %430, i8* nonnull align 8 %26, i64 28, i1 false)
  store i32 %481, i32* %439, align 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %441, i8* nonnull align 8 %27, i64 24, i1 false)
  %498 = load i8, i8* %445, align 4
  store i8 %498, i8* %446, align 8
  %499 = load i32, i32* %427, align 4
  %500 = icmp sgt i32 %499, 0
  br i1 %500, label %501, label %503

501:                                              ; preds = %497
  %502 = zext i32 %499 to i64
  call void @llvm.memset.p0i8.i64(i8* align 1 %453, i8 4, i64 %502, i1 false)
  br label %503

503:                                              ; preds = %501, %497
  br i1 %447, label %505, label %504

504:                                              ; preds = %503
  store i8 %498, i8* %426, align 8
  br label %505

505:                                              ; preds = %503, %504
  store i16 %435, i16* %434, align 4
  store i32 %437, i32* %436, align 8
  %506 = load i32, i32* %55, align 8
  %507 = icmp sgt i32 %506, 0
  br i1 %507, label %508, label %510

508:                                              ; preds = %505
  %509 = zext i32 %506 to i64
  call void @llvm.memset.p0i8.i64(i8* align 1 %438, i8 0, i64 %509, i1 false)
  br label %510

510:                                              ; preds = %508, %505
  %511 = load i32, i32* %291, align 4
  call void @silk_encode_indices(%struct.silk_encoder_state* %37, %struct.ec_ctx* %2, i32 %511, i32 0, i32 %3) #5
  %512 = load i8, i8* %442, align 1
  %513 = sext i8 %512 to i32
  %514 = load i8, i8* %443, align 2
  %515 = sext i8 %514 to i32
  %516 = load i32, i32* %55, align 8
  call void @silk_encode_pulses(%struct.ec_ctx* %2, i32 %513, i32 %515, i8* %438, i32 %516) #5
  %517 = load i32, i32* %444, align 8
  %518 = load i32, i32* %440, align 8
  %519 = call i32 @llvm.ctlz.i32(i32 %518, i1 true) #5, !range !13
  %520 = or i32 %519, -32
  %521 = add i32 %520, %517
  br label %522

522:                                              ; preds = %480, %510
  %523 = phi i32 [ %492, %480 ], [ %521, %510 ]
  %524 = or i32 %455, %5
  %525 = icmp ne i32 %524, 0
  %526 = icmp sgt i32 %523, %4
  %527 = or i1 %525, %526
  br i1 %527, label %528, label %896

528:                                              ; preds = %522, %469, %454
  %529 = phi i32 [ %481, %522 ], [ %458, %454 ], [ %458, %469 ]
  %530 = phi i32 [ %523, %522 ], [ %459, %454 ], [ %460, %469 ]
  %531 = icmp eq i32 %455, 6
  br i1 %531, label %532, label %543

532:                                              ; preds = %528
  %533 = icmp ne i32 %457, 0
  %534 = icmp sgt i32 %530, %4
  %535 = or i1 %468, %534
  %536 = and i1 %533, %535
  br i1 %536, label %537, label %896

537:                                              ; preds = %532
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %430, i8* nonnull align 8 %26, i64 28, i1 false)
  store i32 %529, i32* %439, align 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %441, i8* nonnull align 8 %27, i64 24, i1 false)
  %538 = icmp ult i32 %529, 1276
  br i1 %538, label %540, label %539

539:                                              ; preds = %537
  call void @celt_fatal(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.1, i64 0, i64 0), i32 251) #6
  unreachable

540:                                              ; preds = %537
  %541 = load i8*, i8** %449, align 8
  %542 = zext i32 %529 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %541, i8* nonnull align 16 %32, i64 %542, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %432, i8* nonnull align 4 %29, i64 4352, i1 false)
  store i8 %467, i8* %446, align 8
  br label %896

543:                                              ; preds = %528
  %544 = icmp sgt i32 %530, %4
  br i1 %544, label %545, label %554

545:                                              ; preds = %543
  %546 = icmp eq i32 %457, 0
  %547 = icmp ugt i32 %455, 1
  %548 = and i1 %547, %546
  br i1 %548, label %549, label %566

549:                                              ; preds = %545
  %550 = load float, float* %450, align 4
  %551 = fmul float %550, 1.500000e+00
  %552 = fcmp ogt float %551, 1.500000e+00
  %553 = select i1 %552, float %551, float 1.500000e+00
  store float %553, float* %450, align 4
  store i8 0, i8* %443, align 2
  br label %569

554:                                              ; preds = %543
  %555 = icmp slt i32 %530, %448
  br i1 %555, label %556, label %896

556:                                              ; preds = %554
  %557 = sext i16 %466 to i32
  br i1 %468, label %730, label %558

558:                                              ; preds = %556
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %26, i8* align 8 %430, i64 28, i1 false)
  %559 = load i32, i32* %439, align 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 8 %27, i8* align 8 %441, i64 24, i1 false)
  %560 = icmp ult i32 %559, 1276
  br i1 %560, label %562, label %561

561:                                              ; preds = %558
  call void @celt_fatal(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.2, i64 0, i64 0), i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.1, i64 0, i64 0), i32 281) #6
  unreachable

562:                                              ; preds = %558
  %563 = load i8*, i8** %449, align 8
  %564 = zext i32 %559 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 %32, i8* align 1 %563, i64 %564, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 4 %29, i8* align 4 %432, i64 4352, i1 false)
  %565 = load i8, i8* %446, align 8
  br label %730

566:                                              ; preds = %545
  %567 = sext i16 %466 to i32
  %568 = icmp eq i32 %457, 0
  br i1 %568, label %569, label %730

569:                                              ; preds = %549, %566
  %570 = phi i32 [ -1, %549 ], [ %463, %566 ]
  %571 = phi i32 [ %462, %549 ], [ %567, %566 ]
  %572 = phi i32 [ %460, %549 ], [ %530, %566 ]
  %573 = phi i32 [ 0, %549 ], [ 1, %566 ]
  %574 = load i32, i32* %427, align 4
  %575 = icmp sgt i32 %574, 0
  br i1 %575, label %576, label %730

576:                                              ; preds = %569
  %577 = load i32, i32* %451, align 4
  %578 = icmp eq i32 %455, 0
  %579 = sext i32 %574 to i64
  %580 = add i32 %577, -1
  %581 = zext i32 %580 to i64
  %582 = add nuw nsw i64 %581, 1
  %583 = icmp ult i64 %582, 8
  %584 = and i64 %582, 8589934584
  %585 = icmp eq i64 %582, %584
  br i1 %578, label %586, label %653

586:                                              ; preds = %576, %633
  %587 = phi i64 [ %592, %633 ], [ 0, %576 ]
  %588 = phi i32 [ %639, %633 ], [ %577, %576 ]
  %589 = phi i32 [ %638, %633 ], [ 0, %576 ]
  %590 = trunc i64 %587 to i32
  %591 = mul nsw i32 %577, %590
  %592 = add nuw nsw i64 %587, 1
  %593 = trunc i64 %592 to i32
  %594 = mul nsw i32 %577, %593
  %595 = icmp slt i32 %591, %594
  br i1 %595, label %596, label %633

596:                                              ; preds = %586
  %597 = sext i32 %589 to i64
  br i1 %583, label %598, label %601

598:                                              ; preds = %626, %596
  %599 = phi i64 [ %597, %596 ], [ %602, %626 ]
  %600 = phi i32 [ 0, %596 ], [ %632, %626 ]
  br label %640

601:                                              ; preds = %596
  %602 = add nsw i64 %584, %597
  br label %603

603:                                              ; preds = %603, %601
  %604 = phi i64 [ 0, %601 ], [ %624, %603 ]
  %605 = phi <4 x i32> [ zeroinitializer, %601 ], [ %622, %603 ]
  %606 = phi <4 x i32> [ zeroinitializer, %601 ], [ %623, %603 ]
  %607 = add i64 %604, %597
  %608 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 56, i64 %607
  %609 = bitcast i8* %608 to <4 x i8>*
  %610 = load <4 x i8>, <4 x i8>* %609, align 1
  %611 = getelementptr inbounds i8, i8* %608, i64 4
  %612 = bitcast i8* %611 to <4 x i8>*
  %613 = load <4 x i8>, <4 x i8>* %612, align 1
  %614 = sext <4 x i8> %610 to <4 x i32>
  %615 = sext <4 x i8> %613 to <4 x i32>
  %616 = icmp slt <4 x i32> %614, zeroinitializer
  %617 = icmp slt <4 x i32> %615, zeroinitializer
  %618 = sub nsw <4 x i32> zeroinitializer, %614
  %619 = sub nsw <4 x i32> zeroinitializer, %615
  %620 = select <4 x i1> %616, <4 x i32> %618, <4 x i32> %614
  %621 = select <4 x i1> %617, <4 x i32> %619, <4 x i32> %615
  %622 = add nuw nsw <4 x i32> %620, %605
  %623 = add nuw nsw <4 x i32> %621, %606
  %624 = add i64 %604, 8
  %625 = icmp eq i64 %624, %584
  br i1 %625, label %626, label %603, !llvm.loop !14

626:                                              ; preds = %603
  %627 = add nuw <4 x i32> %623, %622
  %628 = shufflevector <4 x i32> %627, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %629 = add <4 x i32> %627, %628
  %630 = shufflevector <4 x i32> %629, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %631 = add <4 x i32> %629, %630
  %632 = extractelement <4 x i32> %631, i32 0
  br i1 %585, label %633, label %598

633:                                              ; preds = %640, %626, %586
  %634 = phi i32 [ 0, %586 ], [ %632, %626 ], [ %649, %640 ]
  %635 = getelementptr inbounds [4 x i32], [4 x i32]* %22, i64 0, i64 %587
  store i32 %634, i32* %635, align 4
  %636 = getelementptr inbounds [4 x i16], [4 x i16]* %21, i64 0, i64 %587
  store i16 %466, i16* %636, align 2
  %637 = icmp slt i64 %592, %579
  %638 = add i32 %589, %577
  %639 = add i32 %588, %577
  br i1 %637, label %586, label %730

640:                                              ; preds = %598, %640
  %641 = phi i64 [ %650, %640 ], [ %599, %598 ]
  %642 = phi i32 [ %649, %640 ], [ %600, %598 ]
  %643 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 56, i64 %641
  %644 = load i8, i8* %643, align 1
  %645 = sext i8 %644 to i32
  %646 = icmp slt i32 %645, 0
  %647 = sub nsw i32 0, %645
  %648 = select i1 %646, i32 %647, i32 %645
  %649 = add nuw nsw i32 %648, %642
  %650 = add nsw i64 %641, 1
  %651 = trunc i64 %650 to i32
  %652 = icmp eq i32 %588, %651
  br i1 %652, label %633, label %640, !llvm.loop !15

653:                                              ; preds = %576, %726
  %654 = phi i64 [ %659, %726 ], [ 0, %576 ]
  %655 = phi i32 [ %729, %726 ], [ %577, %576 ]
  %656 = phi i32 [ %728, %726 ], [ 0, %576 ]
  %657 = trunc i64 %654 to i32
  %658 = mul nsw i32 %577, %657
  %659 = add nuw nsw i64 %654, 1
  %660 = trunc i64 %659 to i32
  %661 = mul nsw i32 %577, %660
  %662 = icmp slt i32 %658, %661
  br i1 %662, label %663, label %713

663:                                              ; preds = %653
  %664 = sext i32 %656 to i64
  br i1 %583, label %697, label %665

665:                                              ; preds = %663
  %666 = add nsw i64 %584, %664
  br label %667

667:                                              ; preds = %667, %665
  %668 = phi i64 [ 0, %665 ], [ %688, %667 ]
  %669 = phi <4 x i32> [ zeroinitializer, %665 ], [ %686, %667 ]
  %670 = phi <4 x i32> [ zeroinitializer, %665 ], [ %687, %667 ]
  %671 = add i64 %668, %664
  %672 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 56, i64 %671
  %673 = bitcast i8* %672 to <4 x i8>*
  %674 = load <4 x i8>, <4 x i8>* %673, align 1
  %675 = getelementptr inbounds i8, i8* %672, i64 4
  %676 = bitcast i8* %675 to <4 x i8>*
  %677 = load <4 x i8>, <4 x i8>* %676, align 1
  %678 = sext <4 x i8> %674 to <4 x i32>
  %679 = sext <4 x i8> %677 to <4 x i32>
  %680 = icmp slt <4 x i32> %678, zeroinitializer
  %681 = icmp slt <4 x i32> %679, zeroinitializer
  %682 = sub nsw <4 x i32> zeroinitializer, %678
  %683 = sub nsw <4 x i32> zeroinitializer, %679
  %684 = select <4 x i1> %680, <4 x i32> %682, <4 x i32> %678
  %685 = select <4 x i1> %681, <4 x i32> %683, <4 x i32> %679
  %686 = add nuw nsw <4 x i32> %684, %669
  %687 = add nuw nsw <4 x i32> %685, %670
  %688 = add i64 %668, 8
  %689 = icmp eq i64 %688, %584
  br i1 %689, label %690, label %667, !llvm.loop !16

690:                                              ; preds = %667
  %691 = add nuw <4 x i32> %687, %686
  %692 = shufflevector <4 x i32> %691, <4 x i32> undef, <4 x i32> <i32 2, i32 3, i32 undef, i32 undef>
  %693 = add <4 x i32> %691, %692
  %694 = shufflevector <4 x i32> %693, <4 x i32> undef, <4 x i32> <i32 1, i32 undef, i32 undef, i32 undef>
  %695 = add <4 x i32> %693, %694
  %696 = extractelement <4 x i32> %695, i32 0
  br i1 %585, label %713, label %697

697:                                              ; preds = %690, %663
  %698 = phi i64 [ %664, %663 ], [ %666, %690 ]
  %699 = phi i32 [ 0, %663 ], [ %696, %690 ]
  br label %700

700:                                              ; preds = %697, %700
  %701 = phi i64 [ %710, %700 ], [ %698, %697 ]
  %702 = phi i32 [ %709, %700 ], [ %699, %697 ]
  %703 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 56, i64 %701
  %704 = load i8, i8* %703, align 1
  %705 = sext i8 %704 to i32
  %706 = icmp slt i32 %705, 0
  %707 = sub nsw i32 0, %705
  %708 = select i1 %706, i32 %707, i32 %705
  %709 = add nuw nsw i32 %708, %702
  %710 = add nsw i64 %701, 1
  %711 = trunc i64 %710 to i32
  %712 = icmp eq i32 %655, %711
  br i1 %712, label %713, label %700, !llvm.loop !17

713:                                              ; preds = %700, %690, %653
  %714 = phi i32 [ 0, %653 ], [ %696, %690 ], [ %709, %700 ]
  %715 = getelementptr inbounds [4 x i32], [4 x i32]* %22, i64 0, i64 %654
  %716 = load i32, i32* %715, align 4
  %717 = icmp slt i32 %714, %716
  br i1 %717, label %718, label %724

718:                                              ; preds = %713
  %719 = getelementptr inbounds [4 x i32], [4 x i32]* %19, i64 0, i64 %654
  %720 = load i32, i32* %719, align 4
  %721 = icmp eq i32 %720, 0
  br i1 %721, label %722, label %724

722:                                              ; preds = %718
  store i32 %714, i32* %715, align 4
  %723 = getelementptr inbounds [4 x i16], [4 x i16]* %21, i64 0, i64 %654
  store i16 %466, i16* %723, align 2
  br label %726

724:                                              ; preds = %718, %713
  %725 = getelementptr inbounds [4 x i32], [4 x i32]* %19, i64 0, i64 %654
  store i32 1, i32* %725, align 4
  br label %726

726:                                              ; preds = %724, %722
  %727 = icmp slt i64 %659, %579
  %728 = add i32 %656, %577
  %729 = add i32 %655, %577
  br i1 %727, label %653, label %730

730:                                              ; preds = %726, %633, %566, %569, %556, %562
  %731 = phi i8 [ %467, %566 ], [ %467, %556 ], [ %565, %562 ], [ %467, %569 ], [ %467, %633 ], [ %467, %726 ]
  %732 = phi i32 [ %463, %566 ], [ %465, %556 ], [ %465, %562 ], [ %570, %569 ], [ %570, %633 ], [ %570, %726 ]
  %733 = phi i32 [ %464, %566 ], [ %463, %556 ], [ %463, %562 ], [ %464, %569 ], [ %464, %633 ], [ %464, %726 ]
  %734 = phi i32 [ %567, %566 ], [ %462, %556 ], [ %462, %562 ], [ %571, %569 ], [ %571, %633 ], [ %571, %726 ]
  %735 = phi i32 [ %461, %566 ], [ %557, %556 ], [ %557, %562 ], [ %461, %569 ], [ %461, %633 ], [ %461, %726 ]
  %736 = phi i32 [ %530, %566 ], [ %460, %556 ], [ %460, %562 ], [ %572, %569 ], [ %572, %633 ], [ %572, %726 ]
  %737 = phi i32 [ %459, %566 ], [ %530, %556 ], [ %530, %562 ], [ %459, %569 ], [ %459, %633 ], [ %459, %726 ]
  %738 = phi i32 [ %529, %566 ], [ %529, %556 ], [ %559, %562 ], [ %529, %569 ], [ %529, %633 ], [ %529, %726 ]
  %739 = phi i32 [ %457, %566 ], [ 1, %556 ], [ 1, %562 ], [ 0, %569 ], [ 0, %633 ], [ 0, %726 ]
  %740 = phi i32 [ 1, %566 ], [ %456, %556 ], [ %456, %562 ], [ %573, %569 ], [ %573, %633 ], [ %573, %726 ]
  %741 = and i32 %740, %739
  %742 = icmp eq i32 %741, 0
  br i1 %742, label %743, label %760

743:                                              ; preds = %730
  br i1 %544, label %744, label %748

744:                                              ; preds = %743
  %745 = icmp slt i16 %466, 16384
  %746 = shl i16 %466, 1
  %747 = select i1 %745, i16 %746, i16 32767
  br label %779

748:                                              ; preds = %743
  %749 = sub nsw i32 %530, %4
  %750 = shl i32 %749, 7
  %751 = load i32, i32* %55, align 8
  %752 = sdiv i32 %750, %751
  %753 = add nsw i32 %752, 2048
  %754 = call i32 @silk_log2lin(i32 %753) #5
  %755 = sext i32 %754 to i64
  %756 = sext i16 %466 to i64
  %757 = mul nsw i64 %755, %756
  %758 = lshr i64 %757, 16
  %759 = trunc i64 %758 to i16
  br label %779

760:                                              ; preds = %730
  %761 = sub nsw i32 %734, %735
  %762 = sub nsw i32 %4, %737
  %763 = mul nsw i32 %762, %761
  %764 = sub nsw i32 %736, %737
  %765 = sdiv i32 %763, %764
  %766 = add nsw i32 %765, %735
  %767 = shl i32 %766, 16
  %768 = ashr exact i32 %767, 16
  %769 = ashr i32 %761, 2
  %770 = add nsw i32 %769, %735
  %771 = icmp sgt i32 %768, %770
  br i1 %771, label %772, label %774

772:                                              ; preds = %760
  %773 = trunc i32 %770 to i16
  br label %779

774:                                              ; preds = %760
  %775 = sub nsw i32 %734, %769
  %776 = icmp slt i32 %768, %775
  %777 = select i1 %776, i32 %775, i32 %766
  %778 = trunc i32 %777 to i16
  br label %779

779:                                              ; preds = %744, %774, %772, %748
  %780 = phi i16 [ %759, %748 ], [ %773, %772 ], [ %778, %774 ], [ %747, %744 ]
  %781 = load i32, i32* %427, align 4
  %782 = icmp sgt i32 %781, 0
  br i1 %782, label %783, label %810

783:                                              ; preds = %779
  %784 = sext i32 %781 to i64
  br label %785

785:                                              ; preds = %783, %793
  %786 = phi i64 [ 0, %783 ], [ %808, %793 ]
  %787 = getelementptr inbounds [4 x i32], [4 x i32]* %19, i64 0, i64 %786
  %788 = load i32, i32* %787, align 4
  %789 = icmp eq i32 %788, 0
  br i1 %789, label %793, label %790

790:                                              ; preds = %785
  %791 = getelementptr inbounds [4 x i16], [4 x i16]* %21, i64 0, i64 %786
  %792 = load i16, i16* %791, align 2
  br label %793

793:                                              ; preds = %785, %790
  %794 = phi i16 [ %792, %790 ], [ %780, %785 ]
  %795 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 16, i64 %786
  %796 = load i32, i32* %795, align 4
  %797 = sext i32 %796 to i64
  %798 = sext i16 %794 to i64
  %799 = mul nsw i64 %797, %798
  %800 = lshr i64 %799, 16
  %801 = trunc i64 %800 to i32
  %802 = icmp sgt i32 %801, -8388608
  %803 = select i1 %802, i32 %801, i32 -8388608
  %804 = icmp slt i32 %803, 8388607
  %805 = select i1 %804, i32 %803, i32 8388607
  %806 = shl nsw i32 %805, 8
  %807 = getelementptr inbounds [4 x i32], [4 x i32]* %17, i64 0, i64 %786
  store i32 %806, i32* %807, align 4
  %808 = add nuw nsw i64 %786, 1
  %809 = icmp slt i64 %808, %784
  br i1 %809, label %785, label %810

810:                                              ; preds = %793, %779
  %811 = load i8, i8* %445, align 4
  store i8 %811, i8* %446, align 8
  call void @silk_gains_quant(i8* %426, i32* nonnull %31, i8* %446, i32 %452, i32 %781) #5
  %812 = load i32, i32* %427, align 4
  %813 = call i32 @silk_gains_ID(i8* %426, i32 %812) #5
  %814 = load i32, i32* %427, align 4
  %815 = icmp sgt i32 %814, 0
  br i1 %815, label %816, label %894

816:                                              ; preds = %810
  %817 = sext i32 %814 to i64
  %818 = icmp ult i32 %814, 8
  br i1 %818, label %883, label %819

819:                                              ; preds = %816
  %820 = and i64 %817, -8
  %821 = add nsw i64 %820, -8
  %822 = lshr exact i64 %821, 3
  %823 = add nuw nsw i64 %822, 1
  %824 = and i64 %823, 1
  %825 = icmp eq i64 %821, 0
  br i1 %825, label %863, label %826

826:                                              ; preds = %819
  %827 = sub nuw nsw i64 %823, %824
  br label %828

828:                                              ; preds = %828, %826
  %829 = phi i64 [ 0, %826 ], [ %860, %828 ]
  %830 = phi i64 [ %827, %826 ], [ %861, %828 ]
  %831 = getelementptr inbounds [4 x i32], [4 x i32]* %17, i64 0, i64 %829
  %832 = bitcast i32* %831 to <4 x i32>*
  %833 = load <4 x i32>, <4 x i32>* %832, align 16
  %834 = getelementptr inbounds i32, i32* %831, i64 4
  %835 = bitcast i32* %834 to <4 x i32>*
  %836 = load <4 x i32>, <4 x i32>* %835, align 16
  %837 = sitofp <4 x i32> %833 to <4 x float>
  %838 = sitofp <4 x i32> %836 to <4 x float>
  %839 = fmul <4 x float> %837, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %840 = fmul <4 x float> %838, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %841 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %829
  %842 = bitcast float* %841 to <4 x float>*
  store <4 x float> %839, <4 x float>* %842, align 4
  %843 = getelementptr inbounds float, float* %841, i64 4
  %844 = bitcast float* %843 to <4 x float>*
  store <4 x float> %840, <4 x float>* %844, align 4
  %845 = or i64 %829, 8
  %846 = getelementptr inbounds [4 x i32], [4 x i32]* %17, i64 0, i64 %845
  %847 = bitcast i32* %846 to <4 x i32>*
  %848 = load <4 x i32>, <4 x i32>* %847, align 16
  %849 = getelementptr inbounds i32, i32* %846, i64 4
  %850 = bitcast i32* %849 to <4 x i32>*
  %851 = load <4 x i32>, <4 x i32>* %850, align 16
  %852 = sitofp <4 x i32> %848 to <4 x float>
  %853 = sitofp <4 x i32> %851 to <4 x float>
  %854 = fmul <4 x float> %852, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %855 = fmul <4 x float> %853, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %856 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %845
  %857 = bitcast float* %856 to <4 x float>*
  store <4 x float> %854, <4 x float>* %857, align 4
  %858 = getelementptr inbounds float, float* %856, i64 4
  %859 = bitcast float* %858 to <4 x float>*
  store <4 x float> %855, <4 x float>* %859, align 4
  %860 = add i64 %829, 16
  %861 = add i64 %830, -2
  %862 = icmp eq i64 %861, 0
  br i1 %862, label %863, label %828, !llvm.loop !18

863:                                              ; preds = %828, %819
  %864 = phi i64 [ 0, %819 ], [ %860, %828 ]
  %865 = icmp eq i64 %824, 0
  br i1 %865, label %881, label %866

866:                                              ; preds = %863
  %867 = getelementptr inbounds [4 x i32], [4 x i32]* %17, i64 0, i64 %864
  %868 = bitcast i32* %867 to <4 x i32>*
  %869 = load <4 x i32>, <4 x i32>* %868, align 16
  %870 = getelementptr inbounds i32, i32* %867, i64 4
  %871 = bitcast i32* %870 to <4 x i32>*
  %872 = load <4 x i32>, <4 x i32>* %871, align 16
  %873 = sitofp <4 x i32> %869 to <4 x float>
  %874 = sitofp <4 x i32> %872 to <4 x float>
  %875 = fmul <4 x float> %873, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %876 = fmul <4 x float> %874, <float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000, float 0x3EF0000000000000>
  %877 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %864
  %878 = bitcast float* %877 to <4 x float>*
  store <4 x float> %875, <4 x float>* %878, align 4
  %879 = getelementptr inbounds float, float* %877, i64 4
  %880 = bitcast float* %879 to <4 x float>*
  store <4 x float> %876, <4 x float>* %880, align 4
  br label %881

881:                                              ; preds = %863, %866
  %882 = icmp eq i64 %820, %817
  br i1 %882, label %894, label %883

883:                                              ; preds = %881, %816
  %884 = phi i64 [ 0, %816 ], [ %820, %881 ]
  br label %885

885:                                              ; preds = %883, %885
  %886 = phi i64 [ %892, %885 ], [ %884, %883 ]
  %887 = getelementptr inbounds [4 x i32], [4 x i32]* %17, i64 0, i64 %886
  %888 = load i32, i32* %887, align 4
  %889 = sitofp i32 %888 to float
  %890 = fmul float %889, 0x3EF0000000000000
  %891 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 0, i64 %886
  store float %890, float* %891, align 4
  %892 = add nuw nsw i64 %886, 1
  %893 = icmp slt i64 %892, %817
  br i1 %893, label %885, label %894, !llvm.loop !19

894:                                              ; preds = %885, %881, %810
  %895 = add nuw nsw i32 %455, 1
  br label %454

896:                                              ; preds = %522, %554, %532, %209, %540
  %897 = bitcast [720 x float]* %46 to i8*
  %898 = load i32, i32* %55, align 8
  %899 = sext i32 %898 to i64
  %900 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 2, i64 %899
  %901 = bitcast float* %900 to i8*
  %902 = load i32, i32* %47, align 8
  %903 = load i32, i32* %57, align 8
  %904 = mul nsw i32 %903, 5
  %905 = add nsw i32 %904, %902
  %906 = sext i32 %905 to i64
  %907 = shl nsw i64 %906, 2
  call void @llvm.memmove.p0i8.p0i8.i64(i8* align 4 %897, i8* align 4 %901, i64 %907, i1 false)
  %908 = load i32, i32* %282, align 8
  %909 = icmp eq i32 %908, 0
  br i1 %909, label %910, label %931

910:                                              ; preds = %896
  %911 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 20
  %912 = load i32, i32* %911, align 4
  %913 = add nsw i32 %912, -1
  %914 = sext i32 %913 to i64
  %915 = getelementptr inbounds %struct.silk_encoder_control_FLP, %struct.silk_encoder_control_FLP* %10, i64 0, i32 4, i64 %914
  %916 = load i32, i32* %915, align 4
  %917 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 11
  store i32 %916, i32* %917, align 8
  %918 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 55, i32 5
  %919 = load i8, i8* %918, align 1
  %920 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 10
  store i8 %919, i8* %920, align 1
  %921 = getelementptr inbounds %struct.silk_encoder_state_FLP, %struct.silk_encoder_state_FLP* %0, i64 0, i32 0, i32 41
  store i32 0, i32* %921, align 8
  %922 = getelementptr %struct.ec_ctx, %struct.ec_ctx* %2, i64 0, i32 5
  %923 = load i32, i32* %922, align 8
  %924 = getelementptr %struct.ec_ctx, %struct.ec_ctx* %2, i64 0, i32 7
  %925 = load i32, i32* %924, align 8
  %926 = call i32 @llvm.ctlz.i32(i32 %925, i1 true) #5, !range !13
  %927 = or i32 %926, -32
  %928 = add i32 %923, 7
  %929 = add i32 %928, %927
  %930 = ashr i32 %929, 3
  br label %931

931:                                              ; preds = %896, %910
  %932 = phi i32 [ %930, %910 ], [ 0, %896 ]
  store i32 %932, i32* %1, align 4
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %36) #5
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %35) #5
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %34) #5
  call void @llvm.lifetime.end.p0i8(i64 1275, i8* nonnull %32)
  call void @llvm.lifetime.end.p0i8(i64 16, i8* nonnull %30) #5
  call void @llvm.lifetime.end.p0i8(i64 4352, i8* nonnull %29)
  call void @llvm.lifetime.end.p0i8(i64 4352, i8* nonnull %28)
  call void @llvm.lifetime.end.p0i8(i64 28, i8* nonnull %26)
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %27)
  call void @llvm.lifetime.end.p0i8(i64 56, i8* nonnull %25)
  call void @llvm.lifetime.end.p0i8(i64 2688, i8* nonnull %24) #5
  call void @llvm.lifetime.end.p0i8(i64 748, i8* nonnull %23) #5
  ret i32 0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #1

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #1

declare void @silk_LP_variable_cutoff(%struct.silk_LP_state*, i16*, i32) local_unnamed_addr #2

declare void @silk_find_pitch_lags_FLP(%struct.silk_encoder_state_FLP*, %struct.silk_encoder_control_FLP*, float*, float*, i32) local_unnamed_addr #2

declare void @silk_noise_shape_analysis_FLP(%struct.silk_encoder_state_FLP*, %struct.silk_encoder_control_FLP*, float*, float*) local_unnamed_addr #2

declare void @silk_find_pred_coefs_FLP(%struct.silk_encoder_state_FLP*, %struct.silk_encoder_control_FLP*, float*, float*, i32) local_unnamed_addr #2

declare void @silk_process_gains_FLP(%struct.silk_encoder_state_FLP*, %struct.silk_encoder_control_FLP*, i32) local_unnamed_addr #2

declare i32 @silk_gains_ID(i8*, i32) local_unnamed_addr #2

declare void @silk_NSQ_wrapper_FLP(%struct.silk_encoder_state_FLP*, %struct.silk_encoder_control_FLP*, %struct.SideInfoIndices*, %struct.silk_nsq_state*, i8*, float*) local_unnamed_addr #2

declare void @silk_encode_indices(%struct.silk_encoder_state*, %struct.ec_ctx*, i32, i32, i32) local_unnamed_addr #2

declare void @silk_encode_pulses(%struct.ec_ctx*, i32, i32, i8*, i32) local_unnamed_addr #2

; Function Attrs: noreturn
declare void @celt_fatal(i8*, i8*, i32) local_unnamed_addr #3

declare i32 @silk_log2lin(i32) local_unnamed_addr #2

declare void @silk_gains_quant(i8*, i32*, i8*, i32, i32) local_unnamed_addr #2

; Function Attrs: argmemonly nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i1 immarg) #1

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #4

declare void @silk_gains_dequant(i32*, i8*, i8*, i32, i32) local_unnamed_addr #2

; Function Attrs: nounwind readnone speculatable
declare { i64, i1 } @llvm.umul.with.overflow.i64(i64, i64) #4

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone speculatable }
attributes #5 = { nounwind }
attributes #6 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{!3}
!3 = distinct !{!3, !4}
!4 = distinct !{!4, !"LVerDomain"}
!5 = !{!6}
!6 = distinct !{!6, !4}
!7 = distinct !{!7, !8}
!8 = !{!"llvm.loop.isvectorized", i32 1}
!9 = distinct !{!9, !8}
!10 = distinct !{!10, !8}
!11 = distinct !{!11, !12, !8}
!12 = !{!"llvm.loop.unroll.runtime.disable"}
!13 = !{i32 0, i32 33}
!14 = distinct !{!14, !8}
!15 = distinct !{!15, !12, !8}
!16 = distinct !{!16, !8}
!17 = distinct !{!17, !12, !8}
!18 = distinct !{!18, !8}
!19 = distinct !{!19, !12, !8}
