; ModuleID = '../../third_party/unrar/src/secpassword.cpp'
source_filename = "../../third_party/unrar/src/secpassword.cpp"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver fmemopen, fmemopen@GLIBC_2.2.5"
module asm ".symver glob, glob@GLIBC_2.2.5"
module asm ".symver glob64, glob64@GLIBC_2.2.5"
module asm ".symver quick_exit, quick_exit@GLIBC_2.10"
module asm ".symver fmemopen, fmemopen@GLIBC_2.2.5"
module asm ".symver glob, glob@GLIBC_2.2.5"
module asm ".symver glob64, glob64@GLIBC_2.2.5"
module asm ".symver quick_exit, quick_exit@GLIBC_2.10"

%class.SecPassword = type <{ [128 x i32], i8, i8, [2 x i8] }>

@_ZN11SecPasswordC1Ev = hidden unnamed_addr alias void (%class.SecPassword*), void (%class.SecPassword*)* @_ZN11SecPasswordC2Ev
@_ZN11SecPasswordD1Ev = hidden unnamed_addr alias void (%class.SecPassword*), void (%class.SecPassword*)* @_ZN11SecPasswordD2Ev

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN11SecPasswordC2Ev(%class.SecPassword* nocapture) unnamed_addr #0 align 2 {
  %2 = bitcast %class.SecPassword* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %2, i8 0, i64 514, i1 false)
  ret void
}

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN11SecPassword3SetEPKw(%class.SecPassword* nocapture, i32* nocapture readonly) local_unnamed_addr #0 align 2 {
  %3 = load i32, i32* %1, align 4
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %5, label %7

5:                                                ; preds = %2
  %6 = bitcast %class.SecPassword* %0 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %6, i8 0, i64 513, i1 false)
  br label %44

7:                                                ; preds = %2
  %8 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %0, i64 0, i32 1
  store i8 1, i8* %8, align 4
  %9 = tail call i64 @wcslen(i32* %1) #6
  %10 = add i64 %9, 1
  %11 = bitcast %class.SecPassword* %0 to i8*
  %12 = bitcast i32* %1 to i8*
  %13 = icmp ult i64 %10, 128
  %14 = select i1 %13, i64 %10, i64 128
  %15 = shl nuw nsw i64 %14, 2
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %12, i64 %15, i1 false) #7
  %16 = tail call i32 @getpid() #7
  %17 = zext i32 %16 to i64
  %18 = insertelement <16 x i64> undef, i64 %17, i32 0
  %19 = shufflevector <16 x i64> %18, <16 x i64> undef, <16 x i32> zeroinitializer
  br label %20

20:                                               ; preds = %20, %7
  %21 = phi i64 [ 0, %7 ], [ %41, %20 ]
  %22 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %7 ], [ %42, %20 ]
  %23 = add nuw nsw <16 x i64> %22, %19
  %24 = getelementptr inbounds i8, i8* %11, i64 %21
  %25 = bitcast i8* %24 to <16 x i8>*
  %26 = load <16 x i8>, <16 x i8>* %25, align 1
  %27 = trunc <16 x i64> %23 to <16 x i8>
  %28 = add <16 x i8> %27, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %29 = xor <16 x i8> %28, %26
  %30 = bitcast i8* %24 to <16 x i8>*
  store <16 x i8> %29, <16 x i8>* %30, align 1
  %31 = or i64 %21, 16
  %32 = add <16 x i64> %22, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %33 = add nuw nsw <16 x i64> %32, %19
  %34 = getelementptr inbounds i8, i8* %11, i64 %31
  %35 = bitcast i8* %34 to <16 x i8>*
  %36 = load <16 x i8>, <16 x i8>* %35, align 1
  %37 = trunc <16 x i64> %33 to <16 x i8>
  %38 = add <16 x i8> %37, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %39 = xor <16 x i8> %38, %36
  %40 = bitcast i8* %34 to <16 x i8>*
  store <16 x i8> %39, <16 x i8>* %40, align 1
  %41 = add nuw nsw i64 %21, 32
  %42 = add <16 x i64> %22, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %43 = icmp eq i64 %41, 512
  br i1 %43, label %44, label %20, !llvm.loop !2

44:                                               ; preds = %20, %5
  ret void
}

; Function Attrs: nofree norecurse nounwind ssp uwtable
define hidden void @_ZN11SecPasswordD2Ev(%class.SecPassword*) unnamed_addr #1 align 2 {
  %2 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %0, i64 0, i32 1
  store i8 0, i8* %2, align 4
  %3 = bitcast %class.SecPassword* %0 to i8*
  %4 = icmp eq %class.SecPassword* %0, null
  br i1 %4, label %24, label %5

5:                                                ; preds = %1, %5
  %6 = phi i64 [ %22, %5 ], [ 0, %1 ]
  %7 = getelementptr inbounds i8, i8* %3, i64 %6
  store volatile i8 0, i8* %7, align 1
  %8 = or i64 %6, 1
  %9 = getelementptr inbounds i8, i8* %3, i64 %8
  store volatile i8 0, i8* %9, align 1
  %10 = or i64 %6, 2
  %11 = getelementptr inbounds i8, i8* %3, i64 %10
  store volatile i8 0, i8* %11, align 1
  %12 = or i64 %6, 3
  %13 = getelementptr inbounds i8, i8* %3, i64 %12
  store volatile i8 0, i8* %13, align 1
  %14 = or i64 %6, 4
  %15 = getelementptr inbounds i8, i8* %3, i64 %14
  store volatile i8 0, i8* %15, align 1
  %16 = or i64 %6, 5
  %17 = getelementptr inbounds i8, i8* %3, i64 %16
  store volatile i8 0, i8* %17, align 1
  %18 = or i64 %6, 6
  %19 = getelementptr inbounds i8, i8* %3, i64 %18
  store volatile i8 0, i8* %19, align 1
  %20 = or i64 %6, 7
  %21 = getelementptr inbounds i8, i8* %3, i64 %20
  store volatile i8 0, i8* %21, align 1
  %22 = add nuw nsw i64 %6, 8
  %23 = icmp eq i64 %22, 512
  br i1 %23, label %24, label %5

24:                                               ; preds = %5, %1
  ret void
}

; Function Attrs: nofree norecurse nounwind ssp uwtable
define hidden void @_ZN11SecPassword5CleanEv(%class.SecPassword*) local_unnamed_addr #1 align 2 {
  %2 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %0, i64 0, i32 1
  store i8 0, i8* %2, align 4
  %3 = bitcast %class.SecPassword* %0 to i8*
  %4 = icmp eq %class.SecPassword* %0, null
  br i1 %4, label %24, label %5

5:                                                ; preds = %1, %5
  %6 = phi i64 [ %22, %5 ], [ 0, %1 ]
  %7 = getelementptr inbounds i8, i8* %3, i64 %6
  store volatile i8 0, i8* %7, align 1
  %8 = or i64 %6, 1
  %9 = getelementptr inbounds i8, i8* %3, i64 %8
  store volatile i8 0, i8* %9, align 1
  %10 = or i64 %6, 2
  %11 = getelementptr inbounds i8, i8* %3, i64 %10
  store volatile i8 0, i8* %11, align 1
  %12 = or i64 %6, 3
  %13 = getelementptr inbounds i8, i8* %3, i64 %12
  store volatile i8 0, i8* %13, align 1
  %14 = or i64 %6, 4
  %15 = getelementptr inbounds i8, i8* %3, i64 %14
  store volatile i8 0, i8* %15, align 1
  %16 = or i64 %6, 5
  %17 = getelementptr inbounds i8, i8* %3, i64 %16
  store volatile i8 0, i8* %17, align 1
  %18 = or i64 %6, 6
  %19 = getelementptr inbounds i8, i8* %3, i64 %18
  store volatile i8 0, i8* %19, align 1
  %20 = or i64 %6, 7
  %21 = getelementptr inbounds i8, i8* %3, i64 %20
  store volatile i8 0, i8* %21, align 1
  %22 = add nuw nsw i64 %6, 8
  %23 = icmp eq i64 %22, 512
  br i1 %23, label %24, label %5

24:                                               ; preds = %5, %1
  ret void
}

; Function Attrs: nofree norecurse nounwind ssp uwtable
define hidden void @_Z9cleandataPvm(i8*, i64) local_unnamed_addr #1 {
  %3 = icmp ne i8* %0, null
  %4 = icmp ne i64 %1, 0
  %5 = and i1 %4, %3
  br i1 %5, label %6, label %43

6:                                                ; preds = %2
  %7 = add i64 %1, -1
  %8 = and i64 %1, 7
  %9 = icmp ult i64 %7, 7
  br i1 %9, label %33, label %10

10:                                               ; preds = %6
  %11 = sub i64 %1, %8
  br label %12

12:                                               ; preds = %12, %10
  %13 = phi i64 [ 0, %10 ], [ %30, %12 ]
  %14 = phi i64 [ %11, %10 ], [ %31, %12 ]
  %15 = getelementptr inbounds i8, i8* %0, i64 %13
  store volatile i8 0, i8* %15, align 1
  %16 = or i64 %13, 1
  %17 = getelementptr inbounds i8, i8* %0, i64 %16
  store volatile i8 0, i8* %17, align 1
  %18 = or i64 %13, 2
  %19 = getelementptr inbounds i8, i8* %0, i64 %18
  store volatile i8 0, i8* %19, align 1
  %20 = or i64 %13, 3
  %21 = getelementptr inbounds i8, i8* %0, i64 %20
  store volatile i8 0, i8* %21, align 1
  %22 = or i64 %13, 4
  %23 = getelementptr inbounds i8, i8* %0, i64 %22
  store volatile i8 0, i8* %23, align 1
  %24 = or i64 %13, 5
  %25 = getelementptr inbounds i8, i8* %0, i64 %24
  store volatile i8 0, i8* %25, align 1
  %26 = or i64 %13, 6
  %27 = getelementptr inbounds i8, i8* %0, i64 %26
  store volatile i8 0, i8* %27, align 1
  %28 = or i64 %13, 7
  %29 = getelementptr inbounds i8, i8* %0, i64 %28
  store volatile i8 0, i8* %29, align 1
  %30 = add nuw i64 %13, 8
  %31 = add i64 %14, -8
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %33, label %12

33:                                               ; preds = %12, %6
  %34 = phi i64 [ 0, %6 ], [ %30, %12 ]
  %35 = icmp eq i64 %8, 0
  br i1 %35, label %43, label %36

36:                                               ; preds = %33, %36
  %37 = phi i64 [ %40, %36 ], [ %34, %33 ]
  %38 = phi i64 [ %41, %36 ], [ %8, %33 ]
  %39 = getelementptr inbounds i8, i8* %0, i64 %37
  store volatile i8 0, i8* %39, align 1
  %40 = add nuw i64 %37, 1
  %41 = add i64 %38, -1
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %43, label %36, !llvm.loop !4

43:                                               ; preds = %33, %36, %2
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #2

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #2

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN11SecPassword7ProcessEPKwmPwmb(%class.SecPassword* nocapture readnone, i32* nocapture readonly, i64, i32* nocapture, i64, i1 zeroext) local_unnamed_addr #0 align 2 {
  %7 = bitcast i32* %3 to i8*
  %8 = bitcast i32* %1 to i8*
  %9 = icmp ult i64 %2, %4
  %10 = select i1 %9, i64 %2, i64 %4
  %11 = shl i64 %10, 2
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %7, i8* align 4 %8, i64 %11, i1 false)
  %12 = shl i64 %4, 2
  %13 = tail call i32 @getpid() #7
  %14 = icmp eq i64 %12, 0
  br i1 %14, label %82, label %15

15:                                               ; preds = %6
  %16 = zext i32 %13 to i64
  %17 = icmp ult i64 %12, 16
  br i1 %17, label %70, label %18

18:                                               ; preds = %15
  %19 = and i64 %12, -16
  %20 = insertelement <16 x i64> undef, i64 %16, i32 0
  %21 = shufflevector <16 x i64> %20, <16 x i64> undef, <16 x i32> zeroinitializer
  %22 = add i64 %19, -16
  %23 = lshr exact i64 %22, 4
  %24 = add nuw nsw i64 %23, 1
  %25 = and i64 %24, 1
  %26 = icmp eq i64 %22, 0
  br i1 %26, label %55, label %27

27:                                               ; preds = %18
  %28 = sub nuw nsw i64 %24, %25
  br label %29

29:                                               ; preds = %29, %27
  %30 = phi i64 [ 0, %27 ], [ %51, %29 ]
  %31 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %27 ], [ %52, %29 ]
  %32 = phi i64 [ %28, %27 ], [ %53, %29 ]
  %33 = add <16 x i64> %31, %21
  %34 = getelementptr inbounds i8, i8* %7, i64 %30
  %35 = bitcast i8* %34 to <16 x i8>*
  %36 = load <16 x i8>, <16 x i8>* %35, align 1
  %37 = trunc <16 x i64> %33 to <16 x i8>
  %38 = add <16 x i8> %37, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %39 = xor <16 x i8> %38, %36
  %40 = bitcast i8* %34 to <16 x i8>*
  store <16 x i8> %39, <16 x i8>* %40, align 1
  %41 = or i64 %30, 16
  %42 = add <16 x i64> %31, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %43 = add <16 x i64> %42, %21
  %44 = getelementptr inbounds i8, i8* %7, i64 %41
  %45 = bitcast i8* %44 to <16 x i8>*
  %46 = load <16 x i8>, <16 x i8>* %45, align 1
  %47 = trunc <16 x i64> %43 to <16 x i8>
  %48 = add <16 x i8> %47, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %49 = xor <16 x i8> %48, %46
  %50 = bitcast i8* %44 to <16 x i8>*
  store <16 x i8> %49, <16 x i8>* %50, align 1
  %51 = add i64 %30, 32
  %52 = add <16 x i64> %31, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %53 = add i64 %32, -2
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %55, label %29, !llvm.loop !6

55:                                               ; preds = %29, %18
  %56 = phi i64 [ 0, %18 ], [ %51, %29 ]
  %57 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %18 ], [ %52, %29 ]
  %58 = icmp eq i64 %25, 0
  br i1 %58, label %68, label %59

59:                                               ; preds = %55
  %60 = add <16 x i64> %57, %21
  %61 = getelementptr inbounds i8, i8* %7, i64 %56
  %62 = bitcast i8* %61 to <16 x i8>*
  %63 = load <16 x i8>, <16 x i8>* %62, align 1
  %64 = trunc <16 x i64> %60 to <16 x i8>
  %65 = add <16 x i8> %64, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %66 = xor <16 x i8> %65, %63
  %67 = bitcast i8* %61 to <16 x i8>*
  store <16 x i8> %66, <16 x i8>* %67, align 1
  br label %68

68:                                               ; preds = %55, %59
  %69 = icmp eq i64 %12, %19
  br i1 %69, label %82, label %70

70:                                               ; preds = %68, %15
  %71 = phi i64 [ 0, %15 ], [ %19, %68 ]
  br label %72

72:                                               ; preds = %70, %72
  %73 = phi i64 [ %80, %72 ], [ %71, %70 ]
  %74 = add i64 %73, %16
  %75 = getelementptr inbounds i8, i8* %7, i64 %73
  %76 = load i8, i8* %75, align 1
  %77 = trunc i64 %74 to i8
  %78 = add i8 %77, 75
  %79 = xor i8 %78, %76
  store i8 %79, i8* %75, align 1
  %80 = add nuw i64 %73, 1
  %81 = icmp eq i64 %80, %12
  br i1 %81, label %82, label %72, !llvm.loop !7

82:                                               ; preds = %72, %68, %6
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #2

; Function Attrs: nounwind ssp uwtable
define hidden void @_Z11SecHideDataPvmbb(i8* nocapture, i64, i1 zeroext, i1 zeroext) local_unnamed_addr #0 {
  %5 = tail call i32 @getpid() #7
  %6 = icmp eq i64 %1, 0
  br i1 %6, label %64, label %7

7:                                                ; preds = %4
  %8 = zext i32 %5 to i64
  %9 = icmp ult i64 %1, 16
  br i1 %9, label %10, label %12

10:                                               ; preds = %62, %7
  %11 = phi i64 [ 0, %7 ], [ %13, %62 ]
  br label %65

12:                                               ; preds = %7
  %13 = and i64 %1, -16
  %14 = insertelement <16 x i64> undef, i64 %8, i32 0
  %15 = shufflevector <16 x i64> %14, <16 x i64> undef, <16 x i32> zeroinitializer
  %16 = add i64 %13, -16
  %17 = lshr exact i64 %16, 4
  %18 = add nuw nsw i64 %17, 1
  %19 = and i64 %18, 1
  %20 = icmp eq i64 %16, 0
  br i1 %20, label %49, label %21

21:                                               ; preds = %12
  %22 = sub nuw nsw i64 %18, %19
  br label %23

23:                                               ; preds = %23, %21
  %24 = phi i64 [ 0, %21 ], [ %45, %23 ]
  %25 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %21 ], [ %46, %23 ]
  %26 = phi i64 [ %22, %21 ], [ %47, %23 ]
  %27 = add <16 x i64> %25, %15
  %28 = getelementptr inbounds i8, i8* %0, i64 %24
  %29 = bitcast i8* %28 to <16 x i8>*
  %30 = load <16 x i8>, <16 x i8>* %29, align 1
  %31 = trunc <16 x i64> %27 to <16 x i8>
  %32 = add <16 x i8> %31, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %33 = xor <16 x i8> %30, %32
  %34 = bitcast i8* %28 to <16 x i8>*
  store <16 x i8> %33, <16 x i8>* %34, align 1
  %35 = or i64 %24, 16
  %36 = add <16 x i64> %25, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %37 = add <16 x i64> %36, %15
  %38 = getelementptr inbounds i8, i8* %0, i64 %35
  %39 = bitcast i8* %38 to <16 x i8>*
  %40 = load <16 x i8>, <16 x i8>* %39, align 1
  %41 = trunc <16 x i64> %37 to <16 x i8>
  %42 = add <16 x i8> %41, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %43 = xor <16 x i8> %40, %42
  %44 = bitcast i8* %38 to <16 x i8>*
  store <16 x i8> %43, <16 x i8>* %44, align 1
  %45 = add i64 %24, 32
  %46 = add <16 x i64> %25, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %47 = add i64 %26, -2
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %49, label %23, !llvm.loop !9

49:                                               ; preds = %23, %12
  %50 = phi i64 [ 0, %12 ], [ %45, %23 ]
  %51 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %12 ], [ %46, %23 ]
  %52 = icmp eq i64 %19, 0
  br i1 %52, label %62, label %53

53:                                               ; preds = %49
  %54 = add <16 x i64> %51, %15
  %55 = getelementptr inbounds i8, i8* %0, i64 %50
  %56 = bitcast i8* %55 to <16 x i8>*
  %57 = load <16 x i8>, <16 x i8>* %56, align 1
  %58 = trunc <16 x i64> %54 to <16 x i8>
  %59 = add <16 x i8> %58, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %60 = xor <16 x i8> %57, %59
  %61 = bitcast i8* %55 to <16 x i8>*
  store <16 x i8> %60, <16 x i8>* %61, align 1
  br label %62

62:                                               ; preds = %49, %53
  %63 = icmp eq i64 %13, %1
  br i1 %63, label %64, label %10

64:                                               ; preds = %65, %62, %4
  ret void

65:                                               ; preds = %10, %65
  %66 = phi i64 [ %73, %65 ], [ %11, %10 ]
  %67 = add i64 %66, %8
  %68 = getelementptr inbounds i8, i8* %0, i64 %66
  %69 = load i8, i8* %68, align 1
  %70 = trunc i64 %67 to i8
  %71 = add i8 %70, 75
  %72 = xor i8 %69, %71
  store i8 %72, i8* %68, align 1
  %73 = add nuw i64 %66, 1
  %74 = icmp eq i64 %73, %1
  br i1 %74, label %64, label %65, !llvm.loop !10
}

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN11SecPassword3GetEPwm(%class.SecPassword* nocapture readonly, i32* nocapture, i64) local_unnamed_addr #0 align 2 {
  %4 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %0, i64 0, i32 1
  %5 = load i8, i8* %4, align 4, !range !11
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %86, label %7

7:                                                ; preds = %3
  %8 = bitcast i32* %1 to i8*
  %9 = bitcast %class.SecPassword* %0 to i8*
  %10 = icmp ult i64 %2, 128
  %11 = select i1 %10, i64 %2, i64 128
  %12 = shl nuw nsw i64 %11, 2
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %8, i8* align 4 %9, i64 %12, i1 false) #7
  %13 = shl i64 %2, 2
  %14 = tail call i32 @getpid() #7
  %15 = icmp eq i64 %13, 0
  br i1 %15, label %83, label %16

16:                                               ; preds = %7
  %17 = zext i32 %14 to i64
  %18 = icmp ult i64 %13, 16
  br i1 %18, label %71, label %19

19:                                               ; preds = %16
  %20 = and i64 %13, -16
  %21 = insertelement <16 x i64> undef, i64 %17, i32 0
  %22 = shufflevector <16 x i64> %21, <16 x i64> undef, <16 x i32> zeroinitializer
  %23 = add i64 %20, -16
  %24 = lshr exact i64 %23, 4
  %25 = add nuw nsw i64 %24, 1
  %26 = and i64 %25, 1
  %27 = icmp eq i64 %23, 0
  br i1 %27, label %56, label %28

28:                                               ; preds = %19
  %29 = sub nuw nsw i64 %25, %26
  br label %30

30:                                               ; preds = %30, %28
  %31 = phi i64 [ 0, %28 ], [ %52, %30 ]
  %32 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %28 ], [ %53, %30 ]
  %33 = phi i64 [ %29, %28 ], [ %54, %30 ]
  %34 = add <16 x i64> %32, %22
  %35 = getelementptr inbounds i8, i8* %8, i64 %31
  %36 = bitcast i8* %35 to <16 x i8>*
  %37 = load <16 x i8>, <16 x i8>* %36, align 1
  %38 = trunc <16 x i64> %34 to <16 x i8>
  %39 = add <16 x i8> %38, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %40 = xor <16 x i8> %39, %37
  %41 = bitcast i8* %35 to <16 x i8>*
  store <16 x i8> %40, <16 x i8>* %41, align 1
  %42 = or i64 %31, 16
  %43 = add <16 x i64> %32, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %44 = add <16 x i64> %43, %22
  %45 = getelementptr inbounds i8, i8* %8, i64 %42
  %46 = bitcast i8* %45 to <16 x i8>*
  %47 = load <16 x i8>, <16 x i8>* %46, align 1
  %48 = trunc <16 x i64> %44 to <16 x i8>
  %49 = add <16 x i8> %48, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %50 = xor <16 x i8> %49, %47
  %51 = bitcast i8* %45 to <16 x i8>*
  store <16 x i8> %50, <16 x i8>* %51, align 1
  %52 = add i64 %31, 32
  %53 = add <16 x i64> %32, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %54 = add i64 %33, -2
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %56, label %30, !llvm.loop !12

56:                                               ; preds = %30, %19
  %57 = phi i64 [ 0, %19 ], [ %52, %30 ]
  %58 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %19 ], [ %53, %30 ]
  %59 = icmp eq i64 %26, 0
  br i1 %59, label %69, label %60

60:                                               ; preds = %56
  %61 = add <16 x i64> %58, %22
  %62 = getelementptr inbounds i8, i8* %8, i64 %57
  %63 = bitcast i8* %62 to <16 x i8>*
  %64 = load <16 x i8>, <16 x i8>* %63, align 1
  %65 = trunc <16 x i64> %61 to <16 x i8>
  %66 = add <16 x i8> %65, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %67 = xor <16 x i8> %66, %64
  %68 = bitcast i8* %62 to <16 x i8>*
  store <16 x i8> %67, <16 x i8>* %68, align 1
  br label %69

69:                                               ; preds = %56, %60
  %70 = icmp eq i64 %13, %20
  br i1 %70, label %83, label %71

71:                                               ; preds = %69, %16
  %72 = phi i64 [ 0, %16 ], [ %20, %69 ]
  br label %73

73:                                               ; preds = %71, %73
  %74 = phi i64 [ %81, %73 ], [ %72, %71 ]
  %75 = add i64 %74, %17
  %76 = getelementptr inbounds i8, i8* %8, i64 %74
  %77 = load i8, i8* %76, align 1
  %78 = trunc i64 %75 to i8
  %79 = add i8 %78, 75
  %80 = xor i8 %79, %77
  store i8 %80, i8* %76, align 1
  %81 = add nuw i64 %74, 1
  %82 = icmp eq i64 %81, %13
  br i1 %82, label %83, label %73, !llvm.loop !13

83:                                               ; preds = %73, %69, %7
  %84 = add i64 %2, -1
  %85 = getelementptr inbounds i32, i32* %1, i64 %84
  br label %86

86:                                               ; preds = %3, %83
  %87 = phi i32* [ %85, %83 ], [ %1, %3 ]
  store i32 0, i32* %87, align 4
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #2

; Function Attrs: argmemonly nofree nounwind readonly
declare i64 @wcslen(i32* nocapture) local_unnamed_addr #3

; Function Attrs: nounwind ssp uwtable
define hidden i64 @_ZN11SecPassword6LengthEv(%class.SecPassword* nocapture readonly) local_unnamed_addr #0 align 2 {
  %2 = alloca [128 x i32], align 16
  %3 = bitcast [128 x i32]* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %3) #7
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %3, i8 -86, i64 512, i1 false)
  %4 = getelementptr inbounds [128 x i32], [128 x i32]* %2, i64 0, i64 0
  %5 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %0, i64 0, i32 1
  %6 = load i8, i8* %5, align 4, !range !11
  %7 = icmp eq i8 %6, 0
  br i1 %7, label %40, label %8

8:                                                ; preds = %1
  %9 = bitcast %class.SecPassword* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 %3, i8* align 4 %9, i64 512, i1 false) #7
  %10 = tail call i32 @getpid() #7
  %11 = zext i32 %10 to i64
  %12 = insertelement <16 x i64> undef, i64 %11, i32 0
  %13 = shufflevector <16 x i64> %12, <16 x i64> undef, <16 x i32> zeroinitializer
  br label %14

14:                                               ; preds = %14, %8
  %15 = phi i64 [ 0, %8 ], [ %35, %14 ]
  %16 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %8 ], [ %36, %14 ]
  %17 = add nuw nsw <16 x i64> %16, %13
  %18 = getelementptr inbounds i8, i8* %3, i64 %15
  %19 = bitcast i8* %18 to <16 x i8>*
  %20 = load <16 x i8>, <16 x i8>* %19, align 16
  %21 = trunc <16 x i64> %17 to <16 x i8>
  %22 = add <16 x i8> %21, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %23 = xor <16 x i8> %22, %20
  %24 = bitcast i8* %18 to <16 x i8>*
  store <16 x i8> %23, <16 x i8>* %24, align 16
  %25 = or i64 %15, 16
  %26 = add <16 x i64> %16, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %27 = add nuw nsw <16 x i64> %26, %13
  %28 = getelementptr inbounds i8, i8* %3, i64 %25
  %29 = bitcast i8* %28 to <16 x i8>*
  %30 = load <16 x i8>, <16 x i8>* %29, align 16
  %31 = trunc <16 x i64> %27 to <16 x i8>
  %32 = add <16 x i8> %31, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %33 = xor <16 x i8> %32, %30
  %34 = bitcast i8* %28 to <16 x i8>*
  store <16 x i8> %33, <16 x i8>* %34, align 16
  %35 = add nuw nsw i64 %15, 32
  %36 = add <16 x i64> %16, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %37 = icmp eq i64 %35, 512
  br i1 %37, label %38, label %14, !llvm.loop !14

38:                                               ; preds = %14
  %39 = getelementptr inbounds [128 x i32], [128 x i32]* %2, i64 0, i64 127
  store i32 0, i32* %39, align 4
  br label %41

40:                                               ; preds = %1
  store i32 0, i32* %4, align 16
  br label %41

41:                                               ; preds = %38, %40
  %42 = call i64 @wcslen(i32* nonnull %4) #6
  br label %43

43:                                               ; preds = %43, %41
  %44 = phi i64 [ 0, %41 ], [ %60, %43 ]
  %45 = getelementptr inbounds i8, i8* %3, i64 %44
  store volatile i8 0, i8* %45, align 8
  %46 = or i64 %44, 1
  %47 = getelementptr inbounds i8, i8* %3, i64 %46
  store volatile i8 0, i8* %47, align 1
  %48 = or i64 %44, 2
  %49 = getelementptr inbounds i8, i8* %3, i64 %48
  store volatile i8 0, i8* %49, align 2
  %50 = or i64 %44, 3
  %51 = getelementptr inbounds i8, i8* %3, i64 %50
  store volatile i8 0, i8* %51, align 1
  %52 = or i64 %44, 4
  %53 = getelementptr inbounds i8, i8* %3, i64 %52
  store volatile i8 0, i8* %53, align 4
  %54 = or i64 %44, 5
  %55 = getelementptr inbounds i8, i8* %3, i64 %54
  store volatile i8 0, i8* %55, align 1
  %56 = or i64 %44, 6
  %57 = getelementptr inbounds i8, i8* %3, i64 %56
  store volatile i8 0, i8* %57, align 2
  %58 = or i64 %44, 7
  %59 = getelementptr inbounds i8, i8* %3, i64 %58
  store volatile i8 0, i8* %59, align 1
  %60 = add nuw nsw i64 %44, 8
  %61 = icmp eq i64 %60, 128
  br i1 %61, label %62, label %43

62:                                               ; preds = %43
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %3) #7
  ret i64 %42
}

; Function Attrs: nounwind ssp uwtable
define hidden zeroext i1 @_ZN11SecPasswordeqERS_(%class.SecPassword* nocapture readonly, %class.SecPassword* nocapture readonly dereferenceable(516)) local_unnamed_addr #0 align 2 {
  %3 = alloca [128 x i32], align 16
  %4 = alloca [128 x i32], align 16
  %5 = bitcast [128 x i32]* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %5) #7
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %5, i8 -86, i64 512, i1 false)
  %6 = bitcast [128 x i32]* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 512, i8* nonnull %6) #7
  call void @llvm.memset.p0i8.i64(i8* nonnull align 16 %6, i8 -86, i64 512, i1 false)
  %7 = getelementptr inbounds [128 x i32], [128 x i32]* %3, i64 0, i64 0
  %8 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %0, i64 0, i32 1
  %9 = load i8, i8* %8, align 4, !range !11
  %10 = icmp eq i8 %9, 0
  br i1 %10, label %43, label %11

11:                                               ; preds = %2
  %12 = bitcast %class.SecPassword* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 %5, i8* align 4 %12, i64 512, i1 false) #7
  %13 = tail call i32 @getpid() #7
  %14 = zext i32 %13 to i64
  %15 = insertelement <16 x i64> undef, i64 %14, i32 0
  %16 = shufflevector <16 x i64> %15, <16 x i64> undef, <16 x i32> zeroinitializer
  br label %17

17:                                               ; preds = %17, %11
  %18 = phi i64 [ 0, %11 ], [ %38, %17 ]
  %19 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %11 ], [ %39, %17 ]
  %20 = add nuw nsw <16 x i64> %19, %16
  %21 = getelementptr inbounds i8, i8* %5, i64 %18
  %22 = bitcast i8* %21 to <16 x i8>*
  %23 = load <16 x i8>, <16 x i8>* %22, align 16
  %24 = trunc <16 x i64> %20 to <16 x i8>
  %25 = add <16 x i8> %24, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %26 = xor <16 x i8> %25, %23
  %27 = bitcast i8* %21 to <16 x i8>*
  store <16 x i8> %26, <16 x i8>* %27, align 16
  %28 = or i64 %18, 16
  %29 = add <16 x i64> %19, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %30 = add nuw nsw <16 x i64> %29, %16
  %31 = getelementptr inbounds i8, i8* %5, i64 %28
  %32 = bitcast i8* %31 to <16 x i8>*
  %33 = load <16 x i8>, <16 x i8>* %32, align 16
  %34 = trunc <16 x i64> %30 to <16 x i8>
  %35 = add <16 x i8> %34, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %36 = xor <16 x i8> %35, %33
  %37 = bitcast i8* %31 to <16 x i8>*
  store <16 x i8> %36, <16 x i8>* %37, align 16
  %38 = add nuw nsw i64 %18, 32
  %39 = add <16 x i64> %19, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %40 = icmp eq i64 %38, 512
  br i1 %40, label %41, label %17, !llvm.loop !15

41:                                               ; preds = %17
  %42 = getelementptr inbounds [128 x i32], [128 x i32]* %3, i64 0, i64 127
  store i32 0, i32* %42, align 4
  br label %44

43:                                               ; preds = %2
  store i32 0, i32* %7, align 16
  br label %44

44:                                               ; preds = %41, %43
  %45 = getelementptr inbounds [128 x i32], [128 x i32]* %4, i64 0, i64 0
  %46 = getelementptr inbounds %class.SecPassword, %class.SecPassword* %1, i64 0, i32 1
  %47 = load i8, i8* %46, align 4, !range !11
  %48 = icmp eq i8 %47, 0
  br i1 %48, label %81, label %49

49:                                               ; preds = %44
  %50 = bitcast %class.SecPassword* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 16 %6, i8* align 4 %50, i64 512, i1 false) #7
  %51 = tail call i32 @getpid() #7
  %52 = zext i32 %51 to i64
  %53 = insertelement <16 x i64> undef, i64 %52, i32 0
  %54 = shufflevector <16 x i64> %53, <16 x i64> undef, <16 x i32> zeroinitializer
  br label %55

55:                                               ; preds = %55, %49
  %56 = phi i64 [ 0, %49 ], [ %76, %55 ]
  %57 = phi <16 x i64> [ <i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15>, %49 ], [ %77, %55 ]
  %58 = add nuw nsw <16 x i64> %57, %54
  %59 = getelementptr inbounds i8, i8* %6, i64 %56
  %60 = bitcast i8* %59 to <16 x i8>*
  %61 = load <16 x i8>, <16 x i8>* %60, align 16
  %62 = trunc <16 x i64> %58 to <16 x i8>
  %63 = add <16 x i8> %62, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %64 = xor <16 x i8> %63, %61
  %65 = bitcast i8* %59 to <16 x i8>*
  store <16 x i8> %64, <16 x i8>* %65, align 16
  %66 = or i64 %56, 16
  %67 = add <16 x i64> %57, <i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16, i64 16>
  %68 = add nuw nsw <16 x i64> %67, %54
  %69 = getelementptr inbounds i8, i8* %6, i64 %66
  %70 = bitcast i8* %69 to <16 x i8>*
  %71 = load <16 x i8>, <16 x i8>* %70, align 16
  %72 = trunc <16 x i64> %68 to <16 x i8>
  %73 = add <16 x i8> %72, <i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75, i8 75>
  %74 = xor <16 x i8> %73, %71
  %75 = bitcast i8* %69 to <16 x i8>*
  store <16 x i8> %74, <16 x i8>* %75, align 16
  %76 = add nuw nsw i64 %56, 32
  %77 = add <16 x i64> %57, <i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32, i64 32>
  %78 = icmp eq i64 %76, 512
  br i1 %78, label %79, label %55, !llvm.loop !16

79:                                               ; preds = %55
  %80 = getelementptr inbounds [128 x i32], [128 x i32]* %4, i64 0, i64 127
  store i32 0, i32* %80, align 4
  br label %82

81:                                               ; preds = %44
  store i32 0, i32* %45, align 16
  br label %82

82:                                               ; preds = %79, %81
  %83 = call i32 @wcscmp(i32* nonnull %7, i32* nonnull %45) #6
  br label %84

84:                                               ; preds = %84, %82
  %85 = phi i64 [ 0, %82 ], [ %101, %84 ]
  %86 = getelementptr inbounds i8, i8* %5, i64 %85
  store volatile i8 0, i8* %86, align 8
  %87 = or i64 %85, 1
  %88 = getelementptr inbounds i8, i8* %5, i64 %87
  store volatile i8 0, i8* %88, align 1
  %89 = or i64 %85, 2
  %90 = getelementptr inbounds i8, i8* %5, i64 %89
  store volatile i8 0, i8* %90, align 2
  %91 = or i64 %85, 3
  %92 = getelementptr inbounds i8, i8* %5, i64 %91
  store volatile i8 0, i8* %92, align 1
  %93 = or i64 %85, 4
  %94 = getelementptr inbounds i8, i8* %5, i64 %93
  store volatile i8 0, i8* %94, align 4
  %95 = or i64 %85, 5
  %96 = getelementptr inbounds i8, i8* %5, i64 %95
  store volatile i8 0, i8* %96, align 1
  %97 = or i64 %85, 6
  %98 = getelementptr inbounds i8, i8* %5, i64 %97
  store volatile i8 0, i8* %98, align 2
  %99 = or i64 %85, 7
  %100 = getelementptr inbounds i8, i8* %5, i64 %99
  store volatile i8 0, i8* %100, align 1
  %101 = add nuw nsw i64 %85, 8
  %102 = icmp eq i64 %101, 128
  br i1 %102, label %103, label %84

103:                                              ; preds = %84
  %104 = icmp eq i32 %83, 0
  br label %105

105:                                              ; preds = %105, %103
  %106 = phi i64 [ 0, %103 ], [ %122, %105 ]
  %107 = getelementptr inbounds i8, i8* %6, i64 %106
  store volatile i8 0, i8* %107, align 8
  %108 = or i64 %106, 1
  %109 = getelementptr inbounds i8, i8* %6, i64 %108
  store volatile i8 0, i8* %109, align 1
  %110 = or i64 %106, 2
  %111 = getelementptr inbounds i8, i8* %6, i64 %110
  store volatile i8 0, i8* %111, align 2
  %112 = or i64 %106, 3
  %113 = getelementptr inbounds i8, i8* %6, i64 %112
  store volatile i8 0, i8* %113, align 1
  %114 = or i64 %106, 4
  %115 = getelementptr inbounds i8, i8* %6, i64 %114
  store volatile i8 0, i8* %115, align 4
  %116 = or i64 %106, 5
  %117 = getelementptr inbounds i8, i8* %6, i64 %116
  store volatile i8 0, i8* %117, align 1
  %118 = or i64 %106, 6
  %119 = getelementptr inbounds i8, i8* %6, i64 %118
  store volatile i8 0, i8* %119, align 2
  %120 = or i64 %106, 7
  %121 = getelementptr inbounds i8, i8* %6, i64 %120
  store volatile i8 0, i8* %121, align 1
  %122 = add nuw nsw i64 %106, 8
  %123 = icmp eq i64 %122, 128
  br i1 %123, label %124, label %105

124:                                              ; preds = %105
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %6) #7
  call void @llvm.lifetime.end.p0i8(i64 512, i8* nonnull %5) #7
  ret i1 %104
}

; Function Attrs: nounwind readonly
declare i32 @wcscmp(i32*, i32*) local_unnamed_addr #4

; Function Attrs: nounwind
declare i32 @getpid() local_unnamed_addr #5

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nofree norecurse nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { argmemonly nounwind }
attributes #3 = { argmemonly nofree nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readonly }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = distinct !{!2, !3}
!3 = !{!"llvm.loop.isvectorized", i32 1}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.unroll.disable"}
!6 = distinct !{!6, !3}
!7 = distinct !{!7, !8, !3}
!8 = !{!"llvm.loop.unroll.runtime.disable"}
!9 = distinct !{!9, !3}
!10 = distinct !{!10, !8, !3}
!11 = !{i8 0, i8 2}
!12 = distinct !{!12, !3}
!13 = distinct !{!13, !8, !3}
!14 = distinct !{!14, !3}
!15 = distinct !{!15, !3}
!16 = distinct !{!16, !3}
