; ModuleID = '../../third_party/libjxl/src/lib/jxl/enc_ar_control_field.cc'
source_filename = "../../third_party/libjxl/src/lib/jxl/enc_ar_control_field.cc"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

module asm ".symver exp, exp@GLIBC_2.2.5"
module asm ".symver exp2, exp2@GLIBC_2.2.5"
module asm ".symver exp2f, exp2f@GLIBC_2.2.5"
module asm ".symver expf, expf@GLIBC_2.2.5"
module asm ".symver lgamma, lgamma@GLIBC_2.2.5"
module asm ".symver lgammaf, lgammaf@GLIBC_2.2.5"
module asm ".symver lgammal, lgammal@GLIBC_2.2.5"
module asm ".symver log, log@GLIBC_2.2.5"
module asm ".symver log2, log2@GLIBC_2.2.5"
module asm ".symver log2f, log2f@GLIBC_2.2.5"
module asm ".symver logf, logf@GLIBC_2.2.5"
module asm ".symver pow, pow@GLIBC_2.2.5"
module asm ".symver powf, powf@GLIBC_2.2.5"

%"class.jxl::Image3" = type { [3 x %"class.jxl::Plane"] }
%"class.jxl::Plane" = type { %"struct.jxl::PlaneBase" }
%"struct.jxl::PlaneBase" = type { i32, i32, i32, i32, i64, %"class.std::__1::unique_ptr" }
%"class.std::__1::unique_ptr" = type { %"class.std::__1::__compressed_pair" }
%"class.std::__1::__compressed_pair" = type { %"struct.std::__1::__compressed_pair_elem" }
%"struct.std::__1::__compressed_pair_elem" = type { i8* }
%"struct.jxl::PassesEncoderState" = type { %"struct.jxl::PassesSharedState", %"class.jxl::Plane", %"class.jxl::Plane", %"class.std::__1::vector.184", %"class.std::__1::vector.192", %"class.jxl::ProgressiveSplitter", %"struct.jxl::CompressParams", %"class.std::__1::vector.201", %"class.std::__1::vector.105", %"class.std::__1::vector.17", float, float, %"class.std::__1::unique_ptr.231" }
%"struct.jxl::PassesSharedState" = type { %"struct.jxl::CodecMetadata"*, %"struct.jxl::FrameHeader", %"struct.jxl::FrameDimensions", %"class.jxl::AcStrategyImage", %"class.jxl::DequantMatrices", %"class.jxl::Quantizer", %"class.jxl::Plane.61", %"class.jxl::Plane.4", %"struct.jxl::ColorCorrelationMap", %"struct.jxl::ImageFeatures", i64, %"class.std::__1::vector.17", %"class.jxl::Plane.4", %"class.jxl::Image3", %"class.jxl::Image3"*, %"struct.jxl::BlockCtxMap", [4 x %"class.jxl::Image3"], [4 x %struct.anon.111], i64 }
%"struct.jxl::CodecMetadata" = type { %"struct.jxl::ImageMetadata", %"class.jxl::SizeHeader", %"struct.jxl::CustomTransformData" }
%"struct.jxl::ImageMetadata" = type <{ %"class.jxl::Fields", i8, [7 x i8], %"struct.jxl::BitDepth", i8, i8, [6 x i8], %"struct.jxl::ColorEncoding", i32, i8, i8, i8, i8, %"class.jxl::SizeHeader", %"struct.jxl::ToneMapping", i32, [4 x i8], %"class.std::__1::vector.5", %"struct.jxl::CustomTransformData", %"class.jxl::PreviewHeader", %"struct.jxl::AnimationHeader", i64, i8, [7 x i8] }>
%"class.jxl::Fields" = type { i32 (...)** }
%"struct.jxl::BitDepth" = type <{ %"class.jxl::Fields", i8, [3 x i8], i32, i32, [4 x i8] }>
%"struct.jxl::ColorEncoding" = type { %"class.jxl::Fields", i8, i32, i32, %"struct.jxl::CustomTransferFunction", i32, i8, i8, %"class.jxl::PaddedBytes", i32, %"struct.jxl::Customxy", %"struct.jxl::Customxy", %"struct.jxl::Customxy", %"struct.jxl::Customxy" }
%"struct.jxl::CustomTransferFunction" = type { %"class.jxl::Fields", i32, i8, i32, i32 }
%"class.jxl::PaddedBytes" = type { i64, i64, %"class.std::__1::unique_ptr" }
%"struct.jxl::Customxy" = type { %"class.jxl::Fields", i32, i32 }
%"struct.jxl::ToneMapping" = type <{ %"class.jxl::Fields", i8, [3 x i8], float, float, i8, [3 x i8], float, [4 x i8] }>
%"class.std::__1::vector.5" = type { %"class.std::__1::__vector_base.6" }
%"class.std::__1::__vector_base.6" = type { %"struct.jxl::ExtraChannelInfo"*, %"struct.jxl::ExtraChannelInfo"*, %"class.std::__1::__compressed_pair.12" }
%"struct.jxl::ExtraChannelInfo" = type { %"class.jxl::Fields", i8, i32, %"struct.jxl::BitDepth", i32, %"class.std::__1::basic_string", i8, [4 x float], i32 }
%"class.std::__1::basic_string" = type { %"class.std::__1::__compressed_pair.7" }
%"class.std::__1::__compressed_pair.7" = type { %"struct.std::__1::__compressed_pair_elem.8" }
%"struct.std::__1::__compressed_pair_elem.8" = type { %"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep" }
%"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep" = type { %union.anon }
%union.anon = type { %"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long" }
%"struct.std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__long" = type { i8*, i64, i64 }
%"class.std::__1::__compressed_pair.12" = type { %"struct.std::__1::__compressed_pair_elem.13" }
%"struct.std::__1::__compressed_pair_elem.13" = type { %"struct.jxl::ExtraChannelInfo"* }
%"class.jxl::PreviewHeader" = type { %"class.jxl::Fields", i8, i32, i32, i32, i32, i32 }
%"struct.jxl::AnimationHeader" = type <{ %"class.jxl::Fields", i32, i32, i32, i8, [3 x i8] }>
%"class.jxl::SizeHeader" = type { %"class.jxl::Fields", i8, i32, i32, i32, i32, i32 }
%"struct.jxl::CustomTransformData" = type <{ %"class.jxl::Fields", i8, i8, [6 x i8], %"struct.jxl::OpsinInverseMatrix", i32, [15 x float], [55 x float], [210 x float], [4 x i8] }>
%"struct.jxl::OpsinInverseMatrix" = type <{ %"class.jxl::Fields", i8, [3 x i8], [9 x float], [3 x float], [4 x float], [4 x i8] }>
%"struct.jxl::FrameHeader" = type { %"class.jxl::Fields", i8, i32, i32, i64, i32, [4 x i8], %"struct.jxl::YCbCrChromaSubsampling", i32, i32, i32, %"class.std::__1::basic_string", %"struct.jxl::Passes", i8, %"struct.jxl::FrameSize", i32, %"class.std::__1::vector.17", %"struct.jxl::FrameOrigin", %"struct.jxl::BlendingInfo", %"class.std::__1::vector.24", %"struct.jxl::AnimationFrame", i8, i32, i8, i32, %"struct.jxl::CodecMetadata"*, %"struct.jxl::LoopFilter", i8, i64 }
%"struct.jxl::YCbCrChromaSubsampling" = type <{ %"class.jxl::Fields", [3 x i32], i8, i8, [2 x i8] }>
%"struct.jxl::Passes" = type <{ %"class.jxl::Fields", i32, i32, [11 x i32], [11 x i32], [11 x i32], [4 x i8] }>
%"struct.jxl::FrameSize" = type { i32, i32 }
%"struct.jxl::FrameOrigin" = type { i32, i32 }
%"struct.jxl::BlendingInfo" = type <{ %"class.jxl::Fields", i32, i32, i8, [3 x i8], i32, i64, i8, [7 x i8] }>
%"class.std::__1::vector.24" = type { %"class.std::__1::__vector_base.25" }
%"class.std::__1::__vector_base.25" = type { %"struct.jxl::BlendingInfo"*, %"struct.jxl::BlendingInfo"*, %"class.std::__1::__compressed_pair.26" }
%"class.std::__1::__compressed_pair.26" = type { %"struct.std::__1::__compressed_pair_elem.27" }
%"struct.std::__1::__compressed_pair_elem.27" = type { %"struct.jxl::BlendingInfo"* }
%"struct.jxl::AnimationFrame" = type { %"class.jxl::Fields", i32, i32, %"struct.jxl::CodecMetadata"* }
%"struct.jxl::LoopFilter" = type <{ %"class.jxl::Fields", i8, i8, i8, i8, float, float, float, float, float, float, i32, i8, [3 x i8], [8 x float], i8, [3 x i8], [3 x float], float, float, i8, [3 x i8], float, float, float, float, float, [4 x i8], i64, i8, [7 x i8] }>
%"struct.jxl::FrameDimensions" = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%"class.jxl::AcStrategyImage" = type { %"class.jxl::Plane.4", i8*, i64 }
%"class.jxl::DequantMatrices" = type { %"class.std::__1::unique_ptr.31", float*, float*, [3 x float], [3 x float], [81 x i64], %"class.std::__1::vector.35" }
%"class.std::__1::unique_ptr.31" = type { %"class.std::__1::__compressed_pair.32" }
%"class.std::__1::__compressed_pair.32" = type { %"struct.std::__1::__compressed_pair_elem.33", %"struct.std::__1::__compressed_pair_elem.34" }
%"struct.std::__1::__compressed_pair_elem.33" = type { float* }
%"struct.std::__1::__compressed_pair_elem.34" = type { %"class.hwy::AlignedFreer" }
%"class.hwy::AlignedFreer" = type { void (i8*, i8*)*, i8* }
%"class.std::__1::vector.35" = type { %"class.std::__1::__vector_base.36" }
%"class.std::__1::__vector_base.36" = type { %"class.jxl::QuantEncoding"*, %"class.jxl::QuantEncoding"*, %"class.std::__1::__compressed_pair.56" }
%"class.jxl::QuantEncoding" = type { %"struct.jxl::QuantEncodingInternal.base", [7 x i8] }
%"struct.jxl::QuantEncodingInternal.base" = type <{ i32, [4 x i8], %"struct.jxl::DctQuantWeightParams", %union.anon.38, %"struct.jxl::DctQuantWeightParams", %union.anon.55 }>
%union.anon.38 = type { %"struct.std::__1::array.45", [4 x i8] }
%"struct.std::__1::array.45" = type { [3 x %"struct.std::__1::array.46"] }
%"struct.std::__1::array.46" = type { [9 x float] }
%"struct.jxl::DctQuantWeightParams" = type <{ i64, %"struct.std::__1::array", [4 x i8] }>
%"struct.std::__1::array" = type { [3 x %"struct.std::__1::array.37"] }
%"struct.std::__1::array.37" = type { [17 x float] }
%union.anon.55 = type { i8 }
%"class.std::__1::__compressed_pair.56" = type { %"struct.std::__1::__compressed_pair_elem.57" }
%"struct.std::__1::__compressed_pair_elem.57" = type { %"class.jxl::QuantEncoding"* }
%"class.jxl::Quantizer" = type { [4 x float], [4 x float], i32, i32, float, float, float, [3 x float], %"class.jxl::DequantMatrices"* }
%"class.jxl::Plane.61" = type { %"struct.jxl::PlaneBase" }
%"struct.jxl::ColorCorrelationMap" = type { %"class.jxl::Plane.62", %"class.jxl::Plane.62", [4 x float], i32, float, float, float, i32, i32 }
%"class.jxl::Plane.62" = type { %"struct.jxl::PlaneBase" }
%"struct.jxl::ImageFeatures" = type { %"struct.jxl::NoiseParams", %"class.jxl::PatchDictionary", %"class.jxl::Splines" }
%"struct.jxl::NoiseParams" = type { [8 x float] }
%"class.jxl::PatchDictionary" = type { %"struct.jxl::PassesSharedState"*, %"class.std::__1::vector.63", %"class.std::__1::vector.77", %"class.std::__1::vector.77" }
%"class.std::__1::vector.63" = type { %"class.std::__1::__vector_base.64" }
%"class.std::__1::__vector_base.64" = type { %"struct.jxl::PatchPosition"*, %"struct.jxl::PatchPosition"*, %"class.std::__1::__compressed_pair.72" }
%"struct.jxl::PatchPosition" = type { i64, i64, %"class.std::__1::vector.65", %"struct.jxl::PatchReferencePosition" }
%"class.std::__1::vector.65" = type { %"class.std::__1::__vector_base.66" }
%"class.std::__1::__vector_base.66" = type { %"struct.jxl::PatchBlending"*, %"struct.jxl::PatchBlending"*, %"class.std::__1::__compressed_pair.67" }
%"struct.jxl::PatchBlending" = type { i8, i32, i8 }
%"class.std::__1::__compressed_pair.67" = type { %"struct.std::__1::__compressed_pair_elem.68" }
%"struct.std::__1::__compressed_pair_elem.68" = type { %"struct.jxl::PatchBlending"* }
%"struct.jxl::PatchReferencePosition" = type { i64, i64, i64, i64, i64 }
%"class.std::__1::__compressed_pair.72" = type { %"struct.std::__1::__compressed_pair_elem.73" }
%"struct.std::__1::__compressed_pair_elem.73" = type { %"struct.jxl::PatchPosition"* }
%"class.std::__1::vector.77" = type { %"class.std::__1::__vector_base.78" }
%"class.std::__1::__vector_base.78" = type { i64*, i64*, %"class.std::__1::__compressed_pair.79" }
%"class.std::__1::__compressed_pair.79" = type { %"struct.std::__1::__compressed_pair_elem.80" }
%"struct.std::__1::__compressed_pair_elem.80" = type { i64* }
%"class.jxl::Splines" = type { i32, %"class.std::__1::vector.84", %"class.std::__1::vector.98" }
%"class.std::__1::vector.84" = type { %"class.std::__1::__vector_base.85" }
%"class.std::__1::__vector_base.85" = type { %"class.jxl::QuantizedSpline"*, %"class.jxl::QuantizedSpline"*, %"class.std::__1::__compressed_pair.93" }
%"class.jxl::QuantizedSpline" = type { %"class.std::__1::vector.86", [3 x [32 x i32]], [32 x i32] }
%"class.std::__1::vector.86" = type { %"class.std::__1::__vector_base.87" }
%"class.std::__1::__vector_base.87" = type { %"struct.std::__1::pair"*, %"struct.std::__1::pair"*, %"class.std::__1::__compressed_pair.88" }
%"struct.std::__1::pair" = type { i64, i64 }
%"class.std::__1::__compressed_pair.88" = type { %"struct.std::__1::__compressed_pair_elem.89" }
%"struct.std::__1::__compressed_pair_elem.89" = type { %"struct.std::__1::pair"* }
%"class.std::__1::__compressed_pair.93" = type { %"struct.std::__1::__compressed_pair_elem.94" }
%"struct.std::__1::__compressed_pair_elem.94" = type { %"class.jxl::QuantizedSpline"* }
%"class.std::__1::vector.98" = type { %"class.std::__1::__vector_base.99" }
%"class.std::__1::__vector_base.99" = type { %"struct.jxl::Spline::Point"*, %"struct.jxl::Spline::Point"*, %"class.std::__1::__compressed_pair.100" }
%"struct.jxl::Spline::Point" = type { float, float }
%"class.std::__1::__compressed_pair.100" = type { %"struct.std::__1::__compressed_pair_elem.101" }
%"struct.std::__1::__compressed_pair_elem.101" = type { %"struct.jxl::Spline::Point"* }
%"class.jxl::Plane.4" = type { %"struct.jxl::PlaneBase" }
%"struct.jxl::BlockCtxMap" = type { [3 x %"class.std::__1::vector.48"], %"class.std::__1::vector.17", %"class.std::__1::vector.105", i64, i64 }
%"class.std::__1::vector.48" = type { %"class.std::__1::__vector_base.49" }
%"class.std::__1::__vector_base.49" = type { i32*, i32*, %"class.std::__1::__compressed_pair.50" }
%"class.std::__1::__compressed_pair.50" = type { %"struct.std::__1::__compressed_pair_elem.51" }
%"struct.std::__1::__compressed_pair_elem.51" = type { i32* }
%struct.anon.111 = type <{ %"class.jxl::ImageBundle", %"class.jxl::ImageBundle"*, i8, [7 x i8] }>
%"class.jxl::ImageBundle" = type { %"class.std::__1::unique_ptr.112", i32, [4 x i8], %"struct.jxl::YCbCrChromaSubsampling", %"struct.jxl::FrameOrigin", i32, i8, i8, %"class.std::__1::basic_string", %"struct.jxl::ImageMetadata"*, %"class.jxl::Image3", %"struct.jxl::ColorEncoding", %"class.std::__1::vector.176", i64 }
%"class.std::__1::unique_ptr.112" = type { %"class.std::__1::__compressed_pair.113" }
%"class.std::__1::__compressed_pair.113" = type { %"struct.std::__1::__compressed_pair_elem.114" }
%"struct.std::__1::__compressed_pair_elem.114" = type { %"struct.jxl::jpeg::JPEGData"* }
%"struct.jxl::jpeg::JPEGData" = type { %"class.jxl::Fields", i32, i32, i32, %"class.std::__1::vector.115", %"class.std::__1::vector.122", %"class.std::__1::vector.115", %"class.std::__1::vector.129", %"class.std::__1::vector.137", %"class.std::__1::vector.146", %"class.std::__1::vector.160", %"class.std::__1::vector.105", %"class.std::__1::vector.115", %"class.std::__1::vector.105", i32, i8, %"class.std::__1::vector.105" }
%"class.std::__1::vector.122" = type { %"class.std::__1::__vector_base.123" }
%"class.std::__1::__vector_base.123" = type { i32*, i32*, %"class.std::__1::__compressed_pair.124" }
%"class.std::__1::__compressed_pair.124" = type { %"struct.std::__1::__compressed_pair_elem.125" }
%"struct.std::__1::__compressed_pair_elem.125" = type { i32* }
%"class.std::__1::vector.129" = type { %"class.std::__1::__vector_base.130" }
%"class.std::__1::__vector_base.130" = type { %"struct.jxl::jpeg::JPEGQuantTable"*, %"struct.jxl::jpeg::JPEGQuantTable"*, %"class.std::__1::__compressed_pair.132" }
%"struct.jxl::jpeg::JPEGQuantTable" = type <{ %"struct.std::__1::array.131", i32, i32, i8, [3 x i8] }>
%"struct.std::__1::array.131" = type { [64 x i32] }
%"class.std::__1::__compressed_pair.132" = type { %"struct.std::__1::__compressed_pair_elem.133" }
%"struct.std::__1::__compressed_pair_elem.133" = type { %"struct.jxl::jpeg::JPEGQuantTable"* }
%"class.std::__1::vector.137" = type { %"class.std::__1::__vector_base.138" }
%"class.std::__1::__vector_base.138" = type { %"struct.jxl::jpeg::JPEGHuffmanCode"*, %"struct.jxl::jpeg::JPEGHuffmanCode"*, %"class.std::__1::__compressed_pair.141" }
%"struct.jxl::jpeg::JPEGHuffmanCode" = type <{ %"struct.std::__1::array.139", %"struct.std::__1::array.140", i32, i8, [3 x i8] }>
%"struct.std::__1::array.139" = type { [17 x i32] }
%"struct.std::__1::array.140" = type { [257 x i32] }
%"class.std::__1::__compressed_pair.141" = type { %"struct.std::__1::__compressed_pair_elem.142" }
%"struct.std::__1::__compressed_pair_elem.142" = type { %"struct.jxl::jpeg::JPEGHuffmanCode"* }
%"class.std::__1::vector.146" = type { %"class.std::__1::__vector_base.147" }
%"class.std::__1::__vector_base.147" = type { %"struct.jxl::jpeg::JPEGComponent"*, %"struct.jxl::jpeg::JPEGComponent"*, %"class.std::__1::__compressed_pair.155" }
%"struct.jxl::jpeg::JPEGComponent" = type { i32, i32, i32, i32, i32, i32, %"class.std::__1::vector.148" }
%"class.std::__1::vector.148" = type { %"class.std::__1::__vector_base.149" }
%"class.std::__1::__vector_base.149" = type { i16*, i16*, %"class.std::__1::__compressed_pair.150" }
%"class.std::__1::__compressed_pair.150" = type { %"struct.std::__1::__compressed_pair_elem.151" }
%"struct.std::__1::__compressed_pair_elem.151" = type { i16* }
%"class.std::__1::__compressed_pair.155" = type { %"struct.std::__1::__compressed_pair_elem.156" }
%"struct.std::__1::__compressed_pair_elem.156" = type { %"struct.jxl::jpeg::JPEGComponent"* }
%"class.std::__1::vector.160" = type { %"class.std::__1::__vector_base.161" }
%"class.std::__1::__vector_base.161" = type { %"struct.jxl::jpeg::JPEGScanInfo"*, %"struct.jxl::jpeg::JPEGScanInfo"*, %"class.std::__1::__compressed_pair.170" }
%"struct.jxl::jpeg::JPEGScanInfo" = type { i32, i32, i32, i32, i32, %"struct.std::__1::array.162", i32, %"class.std::__1::vector.17", %"class.std::__1::vector.163" }
%"struct.std::__1::array.162" = type { [4 x %"struct.jxl::jpeg::JPEGComponentScanInfo"] }
%"struct.jxl::jpeg::JPEGComponentScanInfo" = type { i32, i32, i32 }
%"class.std::__1::vector.163" = type { %"class.std::__1::__vector_base.164" }
%"class.std::__1::__vector_base.164" = type { %"struct.jxl::jpeg::JPEGScanInfo::ExtraZeroRunInfo"*, %"struct.jxl::jpeg::JPEGScanInfo::ExtraZeroRunInfo"*, %"class.std::__1::__compressed_pair.165" }
%"struct.jxl::jpeg::JPEGScanInfo::ExtraZeroRunInfo" = type { i32, i32 }
%"class.std::__1::__compressed_pair.165" = type { %"struct.std::__1::__compressed_pair_elem.166" }
%"struct.std::__1::__compressed_pair_elem.166" = type { %"struct.jxl::jpeg::JPEGScanInfo::ExtraZeroRunInfo"* }
%"class.std::__1::__compressed_pair.170" = type { %"struct.std::__1::__compressed_pair_elem.171" }
%"struct.std::__1::__compressed_pair_elem.171" = type { %"struct.jxl::jpeg::JPEGScanInfo"* }
%"class.std::__1::vector.115" = type { %"class.std::__1::__vector_base.116" }
%"class.std::__1::__vector_base.116" = type { %"class.std::__1::vector.105"*, %"class.std::__1::vector.105"*, %"class.std::__1::__compressed_pair.117" }
%"class.std::__1::__compressed_pair.117" = type { %"struct.std::__1::__compressed_pair_elem.118" }
%"struct.std::__1::__compressed_pair_elem.118" = type { %"class.std::__1::vector.105"* }
%"class.std::__1::vector.176" = type { %"class.std::__1::__vector_base.177" }
%"class.std::__1::__vector_base.177" = type { %"class.jxl::Plane"*, %"class.jxl::Plane"*, %"class.std::__1::__compressed_pair.178" }
%"class.std::__1::__compressed_pair.178" = type { %"struct.std::__1::__compressed_pair_elem.179" }
%"struct.std::__1::__compressed_pair_elem.179" = type { %"class.jxl::Plane"* }
%"class.std::__1::vector.184" = type { %"class.std::__1::__vector_base.185" }
%"class.std::__1::__vector_base.185" = type { %"class.std::__1::unique_ptr.186"*, %"class.std::__1::unique_ptr.186"*, %"class.std::__1::__compressed_pair.187" }
%"class.std::__1::unique_ptr.186" = type opaque
%"class.std::__1::__compressed_pair.187" = type { %"struct.std::__1::__compressed_pair_elem.188" }
%"struct.std::__1::__compressed_pair_elem.188" = type { %"class.std::__1::unique_ptr.186"* }
%"class.std::__1::vector.192" = type { %"class.std::__1::__vector_base.193" }
%"class.std::__1::__vector_base.193" = type { %"class.std::__1::unique_ptr.194"*, %"class.std::__1::unique_ptr.194"*, %"class.std::__1::__compressed_pair.195" }
%"class.std::__1::unique_ptr.194" = type opaque
%"class.std::__1::__compressed_pair.195" = type { %"struct.std::__1::__compressed_pair_elem.196" }
%"struct.std::__1::__compressed_pair_elem.196" = type { %"class.std::__1::unique_ptr.194"* }
%"class.jxl::ProgressiveSplitter" = type <{ %"struct.jxl::ProgressiveMode", %"class.jxl::Plane"*, float, [4 x i8] }>
%"struct.jxl::ProgressiveMode" = type { i64, [11 x %"struct.jxl::PassDefinition"] }
%"struct.jxl::PassDefinition" = type { i64, i64, i8, i64 }
%"struct.jxl::CompressParams" = type { float, i64, float, float, float, i8, [3 x float], i32, i64, i32, i32, i32, [4 x i8], %"struct.jxl::YCbCrChromaSubsampling", i8, i64, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i32, i8, i64, float, %"class.jxl::Plane"*, i8*, i8*, i8, i8, [2 x i8], %"struct.jxl::ButteraugliParams", i8, [3 x i8], %"struct.jxl::ModularOptions", i32, %"struct.std::__1::pair.200", i32, float, float, i32, i32, i8, i8, i64, i64 }
%"struct.jxl::ButteraugliParams" = type <{ float, float, float, i8, [3 x i8] }>
%"struct.jxl::ModularOptions" = type <{ i64, float, i32, %"class.std::__1::vector.17", float, [4 x i8], i64, i32, i32, float, i32, i8, [3 x i8], i32, i8, [7 x i8] }>
%"struct.std::__1::pair.200" = type { float, float }
%"class.std::__1::vector.201" = type { %"class.std::__1::__vector_base.202" }
%"class.std::__1::__vector_base.202" = type { %"struct.jxl::PassesEncoderState::PassData"*, %"struct.jxl::PassesEncoderState::PassData"*, %"class.std::__1::__compressed_pair.226" }
%"struct.jxl::PassesEncoderState::PassData" = type { %"class.std::__1::vector.203", %"class.std::__1::vector.105", %"struct.jxl::EntropyEncodingData" }
%"class.std::__1::vector.203" = type { %"class.std::__1::__vector_base.204" }
%"class.std::__1::__vector_base.204" = type { %"class.std::__1::vector.205"*, %"class.std::__1::vector.205"*, %"class.std::__1::__compressed_pair.206" }
%"class.std::__1::vector.205" = type opaque
%"class.std::__1::__compressed_pair.206" = type { %"struct.std::__1::__compressed_pair_elem.207" }
%"struct.std::__1::__compressed_pair_elem.207" = type { %"class.std::__1::vector.205"* }
%"struct.jxl::EntropyEncodingData" = type { %"class.std::__1::vector.211", i8, %"class.std::__1::vector.219", %"struct.jxl::LZ77Params" }
%"class.std::__1::vector.211" = type { %"class.std::__1::__vector_base.212" }
%"class.std::__1::__vector_base.212" = type { %"class.std::__1::vector.213"*, %"class.std::__1::vector.213"*, %"class.std::__1::__compressed_pair.214" }
%"class.std::__1::vector.213" = type opaque
%"class.std::__1::__compressed_pair.214" = type { %"struct.std::__1::__compressed_pair_elem.215" }
%"struct.std::__1::__compressed_pair_elem.215" = type { %"class.std::__1::vector.213"* }
%"class.std::__1::vector.219" = type { %"class.std::__1::__vector_base.220" }
%"class.std::__1::__vector_base.220" = type { %"struct.jxl::HybridUintConfig"*, %"struct.jxl::HybridUintConfig"*, %"class.std::__1::__compressed_pair.221" }
%"struct.jxl::HybridUintConfig" = type { i32, i32, i32, i32 }
%"class.std::__1::__compressed_pair.221" = type { %"struct.std::__1::__compressed_pair_elem.222" }
%"struct.std::__1::__compressed_pair_elem.222" = type { %"struct.jxl::HybridUintConfig"* }
%"struct.jxl::LZ77Params" = type { %"class.jxl::Fields", i8, i32, i32, %"struct.jxl::HybridUintConfig", i64 }
%"class.std::__1::__compressed_pair.226" = type { %"struct.std::__1::__compressed_pair_elem.227" }
%"struct.std::__1::__compressed_pair_elem.227" = type { %"struct.jxl::PassesEncoderState::PassData"* }
%"class.std::__1::vector.105" = type { %"class.std::__1::__vector_base.106" }
%"class.std::__1::__vector_base.106" = type { i8*, i8*, %"class.std::__1::__compressed_pair.107" }
%"class.std::__1::__compressed_pair.107" = type { %"struct.std::__1::__compressed_pair_elem" }
%"class.std::__1::vector.17" = type { %"class.std::__1::__vector_base.18" }
%"class.std::__1::__vector_base.18" = type { i32*, i32*, %"class.std::__1::__compressed_pair.19" }
%"class.std::__1::__compressed_pair.19" = type { %"struct.std::__1::__compressed_pair_elem.20" }
%"struct.std::__1::__compressed_pair_elem.20" = type { i32* }
%"class.std::__1::unique_ptr.231" = type { %"class.std::__1::__compressed_pair.232" }
%"class.std::__1::__compressed_pair.232" = type { %"struct.std::__1::__compressed_pair_elem.233" }
%"struct.std::__1::__compressed_pair_elem.233" = type { %"class.jxl::EncoderHeuristics"* }
%"class.jxl::EncoderHeuristics" = type { i32 (...)** }
%"class.jxl::Rect" = type { i64, i64, i64, i64 }
%"struct.jxl::ArControlFieldHeuristics::TempImages" = type { %"class.jxl::Plane", %"class.jxl::Plane", %"class.jxl::Plane" }
%"struct.hwy::ChosenTarget" = type { %"struct.std::__1::atomic" }
%"struct.std::__1::atomic" = type { %"struct.std::__1::__atomic_base" }
%"struct.std::__1::__atomic_base" = type { %"struct.std::__1::__atomic_base.237" }
%"struct.std::__1::__atomic_base.237" = type { %"struct.std::__1::__cxx_atomic_impl" }
%"struct.std::__1::__cxx_atomic_impl" = type { %"struct.std::__1::__cxx_atomic_base_impl" }
%"struct.std::__1::__cxx_atomic_base_impl" = type { i32 }
%"struct.jxl::ArControlFieldHeuristics" = type <{ %"class.std::__1::vector", %"class.jxl::Plane.4"*, %"class.jxl::Plane"*, i8, [7 x i8] }>
%"class.std::__1::vector" = type { %"class.std::__1::__vector_base" }
%"class.std::__1::__vector_base" = type { %"struct.jxl::ArControlFieldHeuristics::TempImages"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*, %"class.std::__1::__compressed_pair.1" }
%"class.std::__1::__compressed_pair.1" = type { %"struct.std::__1::__compressed_pair_elem.2" }
%"struct.std::__1::__compressed_pair_elem.2" = type { %"struct.jxl::ArControlFieldHeuristics::TempImages"* }

$_ZN3jxl24ArControlFieldHeuristics10TempImages8InitOnceEv = comdat any

$_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut = comdat any

$_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut = comdat any

@_ZN3jxlL31ProcessTileHighwayDispatchTableE = internal unnamed_addr constant [12 x void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*] [void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* @_ZN3hwy13FunctionCacheIvJRKN3jxl6Image3IfEEPNS1_18PassesEncoderStateERKNS1_4RectEPNS1_24ArControlFieldHeuristics10TempImagesEEE13ChooseAndCallIXadL_ZNS1_L31ProcessTileHighwayDispatchTableEEEEEvS5_S7_SA_SD_, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* @_ZN3jxl6N_AVX312_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* @_ZN3jxl6N_AVX212_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* @_ZN3jxl6N_SSE412_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* null, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)* @_ZN3jxl8N_SCALAR12_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE], align 16
@_ZN3hwy13chosen_targetE = external global %"struct.hwy::ChosenTarget", align 4
@.str = private unnamed_addr constant [23 x i8] c"%s:%d: JXL_ASSERT: %s\0A\00", align 1
@.str.1 = private unnamed_addr constant [61 x i8] c"../../third_party/libjxl/src/lib/jxl/enc_ar_control_field.cc\00", align 1
@.str.2 = private unnamed_addr constant [137 x i8] c"epf_sharpness->xsize() == enc_state->shared.frame_dim.xsize_blocks && epf_sharpness->ysize() == enc_state->shared.frame_dim.ysize_blocks\00", align 1
@_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut = linkonce_odr hidden local_unnamed_addr constant [27 x i8] c"\01\01\01\01\02\04\02\01\04\01\04\02\01\01\01\01\01\01\08\08\04\10\10\08  \10", comdat, align 16
@_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut = linkonce_odr hidden local_unnamed_addr constant [27 x i8] c"\01\01\01\01\02\04\01\02\01\04\02\04\01\01\01\01\01\01\08\04\08\10\08\10 \10 ", comdat, align 16

; Function Attrs: nounwind ssp uwtable
define hidden void @_ZN3jxl24ArControlFieldHeuristics7RunRectERKNS_4RectERKNS_6Image3IfEEPNS_18PassesEncoderStateEm(%"struct.jxl::ArControlFieldHeuristics"* nocapture readonly, %"class.jxl::Rect"* dereferenceable(32), %"class.jxl::Image3"* dereferenceable(96), %"struct.jxl::PassesEncoderState"*, i64) local_unnamed_addr #0 align 2 {
  %6 = load atomic i32, i32* getelementptr inbounds (%"struct.hwy::ChosenTarget", %"struct.hwy::ChosenTarget"* @_ZN3hwy13chosen_targetE, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0) seq_cst, align 4
  %7 = and i32 %6, 2225
  %8 = tail call i32 @llvm.cttz.i32(i32 %7, i1 true) #7, !range !2
  %9 = zext i32 %8 to i64
  %10 = getelementptr inbounds [12 x void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*], [12 x void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*]* @_ZN3jxlL31ProcessTileHighwayDispatchTableE, i64 0, i64 %9
  %11 = load void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)** %10, align 8
  %12 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics", %"struct.jxl::ArControlFieldHeuristics"* %0, i64 0, i32 0, i32 0, i32 0
  %13 = load %"struct.jxl::ArControlFieldHeuristics::TempImages"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"** %12, align 8
  %14 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %13, i64 %4
  tail call void %11(%"class.jxl::Image3"* dereferenceable(96) %2, %"struct.jxl::PassesEncoderState"* %3, %"class.jxl::Rect"* dereferenceable(32) %1, %"struct.jxl::ArControlFieldHeuristics::TempImages"* %14) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @_ZN3hwy13FunctionCacheIvJRKN3jxl6Image3IfEEPNS1_18PassesEncoderStateERKNS1_4RectEPNS1_24ArControlFieldHeuristics10TempImagesEEE13ChooseAndCallIXadL_ZNS1_L31ProcessTileHighwayDispatchTableEEEEEvS5_S7_SA_SD_(%"class.jxl::Image3"* dereferenceable(96), %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"* dereferenceable(32), %"struct.jxl::ArControlFieldHeuristics::TempImages"*) #0 align 2 {
  tail call void @_ZN3hwy12ChosenTarget6UpdateEv(%"struct.hwy::ChosenTarget"* nonnull @_ZN3hwy13chosen_targetE) #7
  %5 = load atomic i32, i32* getelementptr inbounds (%"struct.hwy::ChosenTarget", %"struct.hwy::ChosenTarget"* @_ZN3hwy13chosen_targetE, i64 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0) seq_cst, align 4
  %6 = and i32 %5, 2225
  %7 = tail call i32 @llvm.cttz.i32(i32 %6, i1 true) #7, !range !2
  %8 = zext i32 %7 to i64
  %9 = getelementptr inbounds [12 x void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*], [12 x void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*]* @_ZN3jxlL31ProcessTileHighwayDispatchTableE, i64 0, i64 %8
  %10 = load void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)*, void (%"class.jxl::Image3"*, %"struct.jxl::PassesEncoderState"*, %"class.jxl::Rect"*, %"struct.jxl::ArControlFieldHeuristics::TempImages"*)** %9, align 8
  tail call void %10(%"class.jxl::Image3"* dereferenceable(96) %0, %"struct.jxl::PassesEncoderState"* %1, %"class.jxl::Rect"* dereferenceable(32) %2, %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3) #7
  ret void
}

; Function Attrs: nounwind ssp uwtable
define internal void @_ZN3jxl6N_AVX312_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE(%"class.jxl::Image3"* dereferenceable(96), %"struct.jxl::PassesEncoderState"* nocapture readonly, %"class.jxl::Rect"* nocapture readonly dereferenceable(32), %"struct.jxl::ArControlFieldHeuristics::TempImages"*) #1 {
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca float*, align 8
  %8 = alloca [3 x float*], align 16
  %9 = alloca [3 x float*], align 16
  %10 = alloca [3 x float*], align 16
  %11 = alloca [4 x float*], align 16
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca float, align 4
  %15 = alloca float, align 4
  %16 = alloca float, align 4
  %17 = alloca float, align 4
  %18 = alloca i32, align 4
  %19 = alloca float, align 4
  %20 = alloca float, align 4
  %21 = alloca float, align 4
  %22 = alloca float, align 4
  %23 = alloca float, align 4
  %24 = alloca float, align 4
  %25 = alloca float, align 4
  %26 = alloca float, align 4
  %27 = alloca float, align 4
  %28 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 0
  %29 = load i32, i32* %28, align 8
  %30 = zext i32 %29 to i64
  %31 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 8
  %32 = load i64, i64* %31, align 8
  %33 = icmp eq i64 %32, %30
  br i1 %33, label %34, label %41

34:                                               ; preds = %4
  %35 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 1
  %36 = load i32, i32* %35, align 4
  %37 = zext i32 %36 to i64
  %38 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 9
  %39 = load i64, i64* %38, align 8
  %40 = icmp eq i64 %39, %37
  br i1 %40, label %44, label %41

41:                                               ; preds = %4, %34
  %42 = tail call zeroext i1 (i8*, ...) @_ZN3jxl5DebugEPKcz(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.1, i64 0, i64 0), i32 54, i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.str.2, i64 0, i64 0)) #7
  %43 = tail call zeroext i1 @_ZN3jxl5AbortEv() #10
  unreachable

44:                                               ; preds = %34
  %45 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 0
  %46 = load float, float* %45, align 8
  %47 = fcmp olt float %46, 5.000000e-01
  br i1 %47, label %56, label %48

48:                                               ; preds = %44
  %49 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 7
  %50 = load i32, i32* %49, align 4
  %51 = icmp sgt i32 %50, 4
  br i1 %51, label %56, label %52

52:                                               ; preds = %48
  %53 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 1, i32 26, i32 11
  %54 = load i32, i32* %53, align 4
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %97

56:                                               ; preds = %52, %48, %44
  %57 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %58 = load i64, i64* %57, align 8
  %59 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %60 = load i64, i64* %59, align 8
  %61 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %62 = load i64, i64* %61, align 8
  %63 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %64 = load i64, i64* %63, align 8
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %1168, label %66

66:                                               ; preds = %56
  %67 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %68 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %69 = icmp eq i64 %62, 0
  %70 = and i64 %64, 1
  %71 = icmp eq i64 %64, 1
  br i1 %71, label %1154, label %72

72:                                               ; preds = %66
  %73 = sub i64 %64, %70
  br label %74

74:                                               ; preds = %1171, %72
  %75 = phi i64 [ 0, %72 ], [ %1172, %1171 ]
  %76 = phi i64 [ %73, %72 ], [ %1173, %1171 ]
  %77 = add i64 %75, %60
  %78 = load i8*, i8** %67, align 8
  %79 = load i64, i64* %68, align 8
  %80 = mul i64 %79, %77
  %81 = getelementptr inbounds i8, i8* %78, i64 %80
  %82 = ptrtoint i8* %81 to i64
  %83 = and i64 %82, 63
  %84 = icmp eq i64 %83, 0
  tail call void @llvm.assume(i1 %84) #7
  br i1 %69, label %87, label %85

85:                                               ; preds = %74
  %86 = getelementptr inbounds i8, i8* %81, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %86, i8 4, i64 %62, i1 false) #7
  br label %87

87:                                               ; preds = %85, %74
  %88 = or i64 %75, 1
  %89 = add i64 %88, %60
  %90 = load i8*, i8** %67, align 8
  %91 = load i64, i64* %68, align 8
  %92 = mul i64 %91, %89
  %93 = getelementptr inbounds i8, i8* %90, i64 %92
  %94 = ptrtoint i8* %93 to i64
  %95 = and i64 %94, 63
  %96 = icmp eq i64 %95, 0
  tail call void @llvm.assume(i1 %96) #7
  br i1 %69, label %1171, label %1169

97:                                               ; preds = %52
  %98 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %99 = load i64, i64* %98, align 8
  %100 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %100) #7
  %101 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %102 = load i64, i64* %101, align 8
  store i64 %102, i64* %5, align 8
  %103 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %104 = load i64, i64* %103, align 8
  %105 = add i64 %104, %102
  %106 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %106) #7
  %107 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %108 = load i64, i64* %107, align 8
  store i64 %108, i64* %6, align 8
  %109 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %110 = load i64, i64* %109, align 8
  %111 = add i64 %110, %108
  tail call void @_ZN3jxl24ArControlFieldHeuristics10TempImages8InitOnceEv(%"struct.jxl::ArControlFieldHeuristics::TempImages"* %3)
  %112 = icmp eq i64 %102, 0
  %113 = select i1 %112, i64 2, i64 0
  %114 = shl i64 %105, 3
  %115 = or i64 %114, 4
  %116 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 1
  %117 = load i32, i32* %116, align 4
  %118 = zext i32 %117 to i64
  %119 = add nuw nsw i64 %118, 2
  %120 = icmp ugt i64 %115, %119
  %121 = shl i64 %104, 3
  %122 = or i64 %121, 4
  %123 = shl i64 %102, 3
  %124 = sub i64 %119, %123
  %125 = select i1 %120, i64 %124, i64 %122
  %126 = icmp eq i64 %108, 0
  %127 = select i1 %126, i64 2, i64 0
  %128 = shl i64 %111, 3
  %129 = or i64 %128, 4
  %130 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 0
  %131 = load i32, i32* %130, align 8
  %132 = zext i32 %131 to i64
  %133 = add nuw nsw i64 %132, 2
  %134 = icmp ugt i64 %129, %133
  %135 = shl i64 %110, 3
  %136 = or i64 %135, 4
  %137 = shl i64 %108, 3
  %138 = sub i64 %133, %137
  %139 = select i1 %134, i64 %138, i64 %136
  %140 = icmp ult i64 %113, %125
  br i1 %140, label %141, label %179

141:                                              ; preds = %97
  %142 = bitcast float** %7 to i8*
  %143 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %144 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %145 = bitcast float** %7 to i8**
  %146 = shl i64 %102, 3
  %147 = bitcast [3 x float*]* %8 to i8*
  %148 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 0
  %149 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 1
  %150 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 2
  %151 = bitcast [3 x float*]* %9 to i8*
  %152 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 0
  %153 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 1
  %154 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 2
  %155 = bitcast [3 x float*]* %10 to i8*
  %156 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 0
  %157 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 1
  %158 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 2
  %159 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 4
  %160 = shl i64 %108, 3
  %161 = or i64 %160, %127
  %162 = icmp ult i64 %161, 3
  %163 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %164 = bitcast [3 x float*]* %8 to i8**
  %165 = bitcast [3 x float*]* %9 to i8**
  %166 = bitcast [3 x float*]* %10 to i8**
  %167 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %168 = bitcast float** %149 to i8**
  %169 = bitcast float** %153 to i8**
  %170 = bitcast float** %157 to i8**
  %171 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %172 = bitcast float** %150 to i8**
  %173 = bitcast float** %154 to i8**
  %174 = bitcast float** %158 to i8**
  %175 = add i64 %160, -1
  %176 = add i64 %160, -2
  br label %207

177:                                              ; preds = %653
  %178 = load i64, i64* %5, align 8
  br label %179

179:                                              ; preds = %177, %97
  %180 = phi i64 [ %178, %177 ], [ %102, %97 ]
  %181 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 4
  %182 = load i64, i64* %181, align 8
  %183 = lshr i64 %182, 2
  %184 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %185 = load i8*, i8** %184, align 8
  %186 = ptrtoint i8* %185 to i64
  %187 = and i64 %186, 63
  %188 = icmp eq i64 %187, 0
  tail call void @llvm.assume(i1 %188) #7
  %189 = sub i64 %105, %180
  %190 = and i64 %189, 9223372036854775807
  %191 = icmp eq i64 %190, 0
  %192 = bitcast i8* %185 to float*
  br i1 %191, label %193, label %198

193:                                              ; preds = %179
  %194 = load i64, i64* %6, align 8
  %195 = sub i64 %111, %194
  %196 = shl i64 %195, 1
  %197 = shl i64 %189, 1
  br label %658

198:                                              ; preds = %179
  %199 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %200 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %201 = load i64, i64* %6, align 8
  %202 = sub i64 %111, %201
  %203 = and i64 %202, 9223372036854775807
  %204 = icmp eq i64 %203, 0
  %205 = shl i64 %202, 1
  %206 = shl i64 %189, 1
  br label %686

207:                                              ; preds = %656, %141
  %208 = phi i32 [ %117, %141 ], [ %657, %656 ]
  %209 = phi i64 [ %113, %141 ], [ %654, %656 ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %142) #7
  %210 = load i8*, i8** %143, align 8
  %211 = load i64, i64* %144, align 8
  %212 = mul i64 %211, %209
  %213 = getelementptr inbounds i8, i8* %210, i64 %212
  %214 = ptrtoint i8* %213 to i64
  %215 = and i64 %214, 63
  %216 = icmp eq i64 %215, 0
  tail call void @llvm.assume(i1 %216) #7
  store i8* %213, i8** %145, align 8
  %217 = add i64 %146, %209
  %218 = add i64 %217, -2
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %155) #7
  %219 = icmp eq i64 %218, 0
  %220 = add i64 %217, -3
  %221 = select i1 %219, i64 0, i64 %220
  %222 = load i64, i64* %159, align 8
  %223 = mul i64 %222, %221
  %224 = mul i64 %222, %218
  %225 = add i64 %217, -1
  %226 = zext i32 %208 to i64
  %227 = icmp ult i64 %225, %226
  %228 = select i1 %227, i64 %225, i64 %218
  %229 = mul i64 %228, %222
  %230 = load i8*, i8** %163, align 8
  %231 = ptrtoint i8* %230 to i64
  %232 = and i64 %231, 63
  %233 = icmp eq i64 %232, 0
  tail call void @llvm.assume(i1 %233) #7
  %234 = getelementptr inbounds i8, i8* %230, i64 %223
  %235 = ptrtoint i8* %234 to i64
  %236 = and i64 %235, 63
  %237 = icmp eq i64 %236, 0
  tail call void @llvm.assume(i1 %237) #7
  store i8* %234, i8** %164, align 16
  %238 = getelementptr inbounds i8, i8* %230, i64 %224
  %239 = ptrtoint i8* %238 to i64
  %240 = and i64 %239, 63
  %241 = icmp eq i64 %240, 0
  tail call void @llvm.assume(i1 %241) #7
  store i8* %238, i8** %165, align 16
  %242 = getelementptr inbounds i8, i8* %230, i64 %229
  %243 = ptrtoint i8* %242 to i64
  %244 = and i64 %243, 63
  %245 = icmp eq i64 %244, 0
  tail call void @llvm.assume(i1 %245) #7
  store i8* %242, i8** %166, align 16
  %246 = load i8*, i8** %167, align 8
  %247 = ptrtoint i8* %246 to i64
  %248 = and i64 %247, 63
  %249 = icmp eq i64 %248, 0
  tail call void @llvm.assume(i1 %249) #7
  %250 = getelementptr inbounds i8, i8* %246, i64 %223
  %251 = ptrtoint i8* %250 to i64
  %252 = and i64 %251, 63
  %253 = icmp eq i64 %252, 0
  tail call void @llvm.assume(i1 %253) #7
  store i8* %250, i8** %168, align 8
  %254 = getelementptr inbounds i8, i8* %246, i64 %224
  %255 = ptrtoint i8* %254 to i64
  %256 = and i64 %255, 63
  %257 = icmp eq i64 %256, 0
  tail call void @llvm.assume(i1 %257) #7
  store i8* %254, i8** %169, align 8
  %258 = getelementptr inbounds i8, i8* %246, i64 %229
  %259 = ptrtoint i8* %258 to i64
  %260 = and i64 %259, 63
  %261 = icmp eq i64 %260, 0
  tail call void @llvm.assume(i1 %261) #7
  store i8* %258, i8** %170, align 8
  %262 = load i8*, i8** %171, align 8
  %263 = ptrtoint i8* %262 to i64
  %264 = and i64 %263, 63
  %265 = icmp eq i64 %264, 0
  tail call void @llvm.assume(i1 %265) #7
  %266 = getelementptr inbounds i8, i8* %262, i64 %223
  %267 = ptrtoint i8* %266 to i64
  %268 = and i64 %267, 63
  %269 = icmp eq i64 %268, 0
  tail call void @llvm.assume(i1 %269) #7
  store i8* %266, i8** %172, align 16
  %270 = getelementptr inbounds i8, i8* %262, i64 %224
  %271 = ptrtoint i8* %270 to i64
  %272 = and i64 %271, 63
  %273 = icmp eq i64 %272, 0
  tail call void @llvm.assume(i1 %273) #7
  store i8* %270, i8** %173, align 16
  %274 = getelementptr inbounds i8, i8* %262, i64 %229
  %275 = ptrtoint i8* %274 to i64
  %276 = and i64 %275, 63
  %277 = icmp eq i64 %276, 0
  tail call void @llvm.assume(i1 %277) #7
  store i8* %274, i8** %174, align 16
  %278 = bitcast i8* %238 to float*
  %279 = bitcast i8* %242 to float*
  %280 = bitcast i8* %234 to float*
  %281 = bitcast i8* %254 to float*
  %282 = bitcast i8* %258 to float*
  %283 = bitcast i8* %250 to float*
  %284 = bitcast i8* %270 to float*
  %285 = bitcast i8* %274 to float*
  %286 = bitcast i8* %266 to float*
  br i1 %162, label %287, label %289

287:                                              ; preds = %207
  %288 = load float*, float** %7, align 8
  br label %304

289:                                              ; preds = %304, %207
  %290 = phi i64 [ %127, %207 ], [ %407, %304 ]
  %291 = add i64 %290, 16
  %292 = icmp ugt i64 %291, %139
  br i1 %292, label %534, label %293

293:                                              ; preds = %289
  %294 = load float*, float** %7, align 8
  %295 = load float*, float** %152, align 16
  %296 = load float*, float** %148, align 16
  %297 = load float*, float** %156, align 16
  %298 = load float*, float** %153, align 8
  %299 = load float*, float** %149, align 8
  %300 = load float*, float** %157, align 8
  %301 = load float*, float** %154, align 16
  %302 = load float*, float** %150, align 16
  %303 = load float*, float** %158, align 16
  br label %410

304:                                              ; preds = %287, %304
  %305 = phi i64 [ %161, %287 ], [ %408, %304 ]
  %306 = phi i64 [ %127, %287 ], [ %407, %304 ]
  %307 = add nsw i64 %305, -2
  %308 = icmp eq i64 %307, 0
  %309 = add nuw nsw i64 %305, -3
  %310 = select i1 %308, i64 0, i64 %309
  %311 = add nsw i64 %305, -1
  %312 = load i32, i32* %130, align 8
  %313 = zext i32 %312 to i64
  %314 = icmp ult i64 %311, %313
  %315 = select i1 %314, i64 %311, i64 %307
  %316 = getelementptr inbounds float, float* %278, i64 %307
  %317 = load float, float* %316, align 4
  %318 = fmul float %317, 0x4011666660000000
  %319 = getelementptr inbounds float, float* %278, i64 %310
  %320 = load float, float* %319, align 4
  %321 = getelementptr inbounds float, float* %278, i64 %315
  %322 = load float, float* %321, align 4
  %323 = fadd float %320, %322
  %324 = getelementptr inbounds float, float* %279, i64 %310
  %325 = load float, float* %324, align 4
  %326 = fadd float %323, %325
  %327 = getelementptr inbounds float, float* %279, i64 %307
  %328 = load float, float* %327, align 4
  %329 = fadd float %326, %328
  %330 = getelementptr inbounds float, float* %279, i64 %315
  %331 = load float, float* %330, align 4
  %332 = fadd float %329, %331
  %333 = getelementptr inbounds float, float* %280, i64 %310
  %334 = load float, float* %333, align 4
  %335 = fadd float %332, %334
  %336 = getelementptr inbounds float, float* %280, i64 %307
  %337 = load float, float* %336, align 4
  %338 = fadd float %335, %337
  %339 = getelementptr inbounds float, float* %280, i64 %315
  %340 = load float, float* %339, align 4
  %341 = fadd float %338, %340
  %342 = fmul float %341, 0x3FE1666660000000
  %343 = fsub float %318, %342
  %344 = fmul float %343, %343
  %345 = fadd float %344, 0.000000e+00
  %346 = getelementptr inbounds float, float* %281, i64 %307
  %347 = load float, float* %346, align 4
  %348 = fmul float %347, 0x4011666660000000
  %349 = getelementptr inbounds float, float* %281, i64 %310
  %350 = load float, float* %349, align 4
  %351 = getelementptr inbounds float, float* %281, i64 %315
  %352 = load float, float* %351, align 4
  %353 = fadd float %350, %352
  %354 = getelementptr inbounds float, float* %282, i64 %310
  %355 = load float, float* %354, align 4
  %356 = fadd float %353, %355
  %357 = getelementptr inbounds float, float* %282, i64 %307
  %358 = load float, float* %357, align 4
  %359 = fadd float %356, %358
  %360 = getelementptr inbounds float, float* %282, i64 %315
  %361 = load float, float* %360, align 4
  %362 = fadd float %359, %361
  %363 = getelementptr inbounds float, float* %283, i64 %310
  %364 = load float, float* %363, align 4
  %365 = fadd float %362, %364
  %366 = getelementptr inbounds float, float* %283, i64 %307
  %367 = load float, float* %366, align 4
  %368 = fadd float %365, %367
  %369 = getelementptr inbounds float, float* %283, i64 %315
  %370 = load float, float* %369, align 4
  %371 = fadd float %368, %370
  %372 = fmul float %371, 0x3FE1666660000000
  %373 = fsub float %348, %372
  %374 = fmul float %373, %373
  %375 = fadd float %345, %374
  %376 = getelementptr inbounds float, float* %284, i64 %307
  %377 = load float, float* %376, align 4
  %378 = fmul float %377, 0x3FD25E3540000000
  %379 = getelementptr inbounds float, float* %284, i64 %310
  %380 = load float, float* %379, align 4
  %381 = getelementptr inbounds float, float* %284, i64 %315
  %382 = load float, float* %381, align 4
  %383 = fadd float %380, %382
  %384 = getelementptr inbounds float, float* %285, i64 %310
  %385 = load float, float* %384, align 4
  %386 = fadd float %383, %385
  %387 = getelementptr inbounds float, float* %285, i64 %307
  %388 = load float, float* %387, align 4
  %389 = fadd float %386, %388
  %390 = getelementptr inbounds float, float* %285, i64 %315
  %391 = load float, float* %390, align 4
  %392 = fadd float %389, %391
  %393 = getelementptr inbounds float, float* %286, i64 %310
  %394 = load float, float* %393, align 4
  %395 = fadd float %392, %394
  %396 = getelementptr inbounds float, float* %286, i64 %307
  %397 = load float, float* %396, align 4
  %398 = fadd float %395, %397
  %399 = getelementptr inbounds float, float* %286, i64 %315
  %400 = load float, float* %399, align 4
  %401 = fadd float %398, %400
  %402 = fmul float %401, 0x3FA25E3540000000
  %403 = fsub float %378, %402
  %404 = fmul float %403, %403
  %405 = fadd float %375, %404
  %406 = getelementptr inbounds float, float* %288, i64 %306
  store float %405, float* %406, align 4
  %407 = add nuw nsw i64 %306, 1
  %408 = add i64 %160, %407
  %409 = icmp ult i64 %408, 3
  br i1 %409, label %304, label %289

410:                                              ; preds = %293, %417
  %411 = phi i64 [ %291, %293 ], [ %532, %417 ]
  %412 = phi i64 [ %290, %293 ], [ %411, %417 ]
  %413 = add i64 %175, %411
  %414 = load i32, i32* %130, align 8
  %415 = zext i32 %414 to i64
  %416 = icmp ugt i64 %413, %415
  br i1 %416, label %534, label %417

417:                                              ; preds = %410
  %418 = add i64 %176, %412
  %419 = getelementptr inbounds float, float* %295, i64 %418
  %420 = bitcast float* %419 to <16 x float>*
  %421 = load <16 x float>, <16 x float>* %420, align 1, !alias.scope !3, !noalias !6
  %422 = fmul <16 x float> %421, <float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000>
  %423 = getelementptr inbounds float, float* %419, i64 -1
  %424 = bitcast float* %423 to <16 x float>*
  %425 = load <16 x float>, <16 x float>* %424, align 1, !alias.scope !8, !noalias !11
  %426 = getelementptr inbounds float, float* %419, i64 1
  %427 = bitcast float* %426 to <16 x float>*
  %428 = load <16 x float>, <16 x float>* %427, align 1, !alias.scope !13, !noalias !16
  %429 = getelementptr inbounds float, float* %296, i64 %418
  %430 = getelementptr inbounds float, float* %429, i64 -1
  %431 = bitcast float* %430 to <16 x float>*
  %432 = load <16 x float>, <16 x float>* %431, align 1, !alias.scope !18, !noalias !21
  %433 = bitcast float* %429 to <16 x float>*
  %434 = load <16 x float>, <16 x float>* %433, align 1, !alias.scope !23, !noalias !26
  %435 = getelementptr inbounds float, float* %429, i64 1
  %436 = bitcast float* %435 to <16 x float>*
  %437 = load <16 x float>, <16 x float>* %436, align 1, !alias.scope !28, !noalias !31
  %438 = fadd <16 x float> %425, %437
  %439 = getelementptr inbounds float, float* %297, i64 %418
  %440 = getelementptr inbounds float, float* %439, i64 -1
  %441 = bitcast float* %440 to <16 x float>*
  %442 = load <16 x float>, <16 x float>* %441, align 1, !alias.scope !33, !noalias !36
  %443 = fadd <16 x float> %428, %442
  %444 = bitcast float* %439 to <16 x float>*
  %445 = load <16 x float>, <16 x float>* %444, align 1, !alias.scope !38, !noalias !41
  %446 = fadd <16 x float> %432, %445
  %447 = getelementptr inbounds float, float* %439, i64 1
  %448 = bitcast float* %447 to <16 x float>*
  %449 = load <16 x float>, <16 x float>* %448, align 1, !alias.scope !43, !noalias !46
  %450 = fadd <16 x float> %434, %449
  %451 = fadd <16 x float> %438, %443
  %452 = fadd <16 x float> %446, %450
  %453 = fadd <16 x float> %451, %452
  %454 = tail call <16 x float> @llvm.fma.v16f32(<16 x float> %453, <16 x float> <float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000>, <16 x float> %422) #7
  %455 = tail call <16 x float> @llvm.fma.v16f32(<16 x float> %454, <16 x float> %454, <16 x float> zeroinitializer) #7
  %456 = getelementptr inbounds float, float* %298, i64 %418
  %457 = bitcast float* %456 to <16 x float>*
  %458 = load <16 x float>, <16 x float>* %457, align 1, !alias.scope !3, !noalias !6
  %459 = fmul <16 x float> %458, <float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000>
  %460 = getelementptr inbounds float, float* %456, i64 -1
  %461 = bitcast float* %460 to <16 x float>*
  %462 = load <16 x float>, <16 x float>* %461, align 1, !alias.scope !8, !noalias !11
  %463 = getelementptr inbounds float, float* %456, i64 1
  %464 = bitcast float* %463 to <16 x float>*
  %465 = load <16 x float>, <16 x float>* %464, align 1, !alias.scope !13, !noalias !16
  %466 = getelementptr inbounds float, float* %299, i64 %418
  %467 = getelementptr inbounds float, float* %466, i64 -1
  %468 = bitcast float* %467 to <16 x float>*
  %469 = load <16 x float>, <16 x float>* %468, align 1, !alias.scope !18, !noalias !21
  %470 = bitcast float* %466 to <16 x float>*
  %471 = load <16 x float>, <16 x float>* %470, align 1, !alias.scope !23, !noalias !26
  %472 = getelementptr inbounds float, float* %466, i64 1
  %473 = bitcast float* %472 to <16 x float>*
  %474 = load <16 x float>, <16 x float>* %473, align 1, !alias.scope !28, !noalias !31
  %475 = fadd <16 x float> %462, %474
  %476 = getelementptr inbounds float, float* %300, i64 %418
  %477 = getelementptr inbounds float, float* %476, i64 -1
  %478 = bitcast float* %477 to <16 x float>*
  %479 = load <16 x float>, <16 x float>* %478, align 1, !alias.scope !33, !noalias !36
  %480 = fadd <16 x float> %465, %479
  %481 = bitcast float* %476 to <16 x float>*
  %482 = load <16 x float>, <16 x float>* %481, align 1, !alias.scope !38, !noalias !41
  %483 = fadd <16 x float> %469, %482
  %484 = getelementptr inbounds float, float* %476, i64 1
  %485 = bitcast float* %484 to <16 x float>*
  %486 = load <16 x float>, <16 x float>* %485, align 1, !alias.scope !43, !noalias !46
  %487 = fadd <16 x float> %471, %486
  %488 = fadd <16 x float> %475, %480
  %489 = fadd <16 x float> %483, %487
  %490 = fadd <16 x float> %488, %489
  %491 = tail call <16 x float> @llvm.fma.v16f32(<16 x float> %490, <16 x float> <float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000>, <16 x float> %459) #7
  %492 = tail call <16 x float> @llvm.fma.v16f32(<16 x float> %491, <16 x float> %491, <16 x float> %455) #7
  %493 = getelementptr inbounds float, float* %301, i64 %418
  %494 = bitcast float* %493 to <16 x float>*
  %495 = load <16 x float>, <16 x float>* %494, align 1, !alias.scope !3, !noalias !6
  %496 = fmul <16 x float> %495, <float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000>
  %497 = getelementptr inbounds float, float* %493, i64 -1
  %498 = bitcast float* %497 to <16 x float>*
  %499 = load <16 x float>, <16 x float>* %498, align 1, !alias.scope !8, !noalias !11
  %500 = getelementptr inbounds float, float* %493, i64 1
  %501 = bitcast float* %500 to <16 x float>*
  %502 = load <16 x float>, <16 x float>* %501, align 1, !alias.scope !13, !noalias !16
  %503 = getelementptr inbounds float, float* %302, i64 %418
  %504 = getelementptr inbounds float, float* %503, i64 -1
  %505 = bitcast float* %504 to <16 x float>*
  %506 = load <16 x float>, <16 x float>* %505, align 1, !alias.scope !18, !noalias !21
  %507 = bitcast float* %503 to <16 x float>*
  %508 = load <16 x float>, <16 x float>* %507, align 1, !alias.scope !23, !noalias !26
  %509 = getelementptr inbounds float, float* %503, i64 1
  %510 = bitcast float* %509 to <16 x float>*
  %511 = load <16 x float>, <16 x float>* %510, align 1, !alias.scope !28, !noalias !31
  %512 = fadd <16 x float> %499, %511
  %513 = getelementptr inbounds float, float* %303, i64 %418
  %514 = getelementptr inbounds float, float* %513, i64 -1
  %515 = bitcast float* %514 to <16 x float>*
  %516 = load <16 x float>, <16 x float>* %515, align 1, !alias.scope !33, !noalias !36
  %517 = fadd <16 x float> %502, %516
  %518 = bitcast float* %513 to <16 x float>*
  %519 = load <16 x float>, <16 x float>* %518, align 1, !alias.scope !38, !noalias !41
  %520 = fadd <16 x float> %506, %519
  %521 = getelementptr inbounds float, float* %513, i64 1
  %522 = bitcast float* %521 to <16 x float>*
  %523 = load <16 x float>, <16 x float>* %522, align 1, !alias.scope !43, !noalias !46
  %524 = fadd <16 x float> %508, %523
  %525 = fadd <16 x float> %512, %517
  %526 = fadd <16 x float> %520, %524
  %527 = fadd <16 x float> %525, %526
  %528 = tail call <16 x float> @llvm.fma.v16f32(<16 x float> %527, <16 x float> <float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000>, <16 x float> %496) #7
  %529 = tail call <16 x float> @llvm.fma.v16f32(<16 x float> %528, <16 x float> %528, <16 x float> %492) #7
  %530 = getelementptr inbounds float, float* %294, i64 %412
  %531 = bitcast float* %530 to <16 x float>*
  store <16 x float> %529, <16 x float>* %531, align 1, !alias.scope !48
  %532 = add i64 %411, 16
  %533 = icmp ugt i64 %532, %139
  br i1 %533, label %534, label %410

534:                                              ; preds = %417, %410, %289
  %535 = phi i64 [ %290, %289 ], [ %412, %410 ], [ %411, %417 ]
  %536 = icmp ult i64 %535, %139
  br i1 %536, label %537, label %653

537:                                              ; preds = %534
  %538 = load float*, float** %152, align 16
  %539 = load float*, float** %156, align 16
  %540 = load float*, float** %148, align 16
  %541 = load float*, float** %153, align 8
  %542 = load float*, float** %157, align 8
  %543 = load float*, float** %149, align 8
  %544 = load float*, float** %154, align 16
  %545 = load float*, float** %158, align 16
  %546 = load float*, float** %150, align 16
  %547 = load float*, float** %7, align 8
  br label %548

548:                                              ; preds = %537, %548
  %549 = phi i64 [ %535, %537 ], [ %651, %548 ]
  %550 = add i64 %160, %549
  %551 = add i64 %550, -2
  %552 = icmp eq i64 %551, 0
  %553 = add i64 %550, -3
  %554 = select i1 %552, i64 0, i64 %553
  %555 = add i64 %550, -1
  %556 = load i32, i32* %130, align 8
  %557 = zext i32 %556 to i64
  %558 = icmp ult i64 %555, %557
  %559 = select i1 %558, i64 %555, i64 %551
  %560 = getelementptr inbounds float, float* %538, i64 %551
  %561 = load float, float* %560, align 4
  %562 = fmul float %561, 0x4011666660000000
  %563 = getelementptr inbounds float, float* %538, i64 %554
  %564 = load float, float* %563, align 4
  %565 = getelementptr inbounds float, float* %538, i64 %559
  %566 = load float, float* %565, align 4
  %567 = fadd float %564, %566
  %568 = getelementptr inbounds float, float* %539, i64 %554
  %569 = load float, float* %568, align 4
  %570 = fadd float %567, %569
  %571 = getelementptr inbounds float, float* %539, i64 %551
  %572 = load float, float* %571, align 4
  %573 = fadd float %570, %572
  %574 = getelementptr inbounds float, float* %539, i64 %559
  %575 = load float, float* %574, align 4
  %576 = fadd float %573, %575
  %577 = getelementptr inbounds float, float* %540, i64 %554
  %578 = load float, float* %577, align 4
  %579 = fadd float %576, %578
  %580 = getelementptr inbounds float, float* %540, i64 %551
  %581 = load float, float* %580, align 4
  %582 = fadd float %579, %581
  %583 = getelementptr inbounds float, float* %540, i64 %559
  %584 = load float, float* %583, align 4
  %585 = fadd float %582, %584
  %586 = fmul float %585, 0x3FE1666660000000
  %587 = fsub float %562, %586
  %588 = fmul float %587, %587
  %589 = fadd float %588, 0.000000e+00
  %590 = getelementptr inbounds float, float* %541, i64 %551
  %591 = load float, float* %590, align 4
  %592 = fmul float %591, 0x4011666660000000
  %593 = getelementptr inbounds float, float* %541, i64 %554
  %594 = load float, float* %593, align 4
  %595 = getelementptr inbounds float, float* %541, i64 %559
  %596 = load float, float* %595, align 4
  %597 = fadd float %594, %596
  %598 = getelementptr inbounds float, float* %542, i64 %554
  %599 = load float, float* %598, align 4
  %600 = fadd float %597, %599
  %601 = getelementptr inbounds float, float* %542, i64 %551
  %602 = load float, float* %601, align 4
  %603 = fadd float %600, %602
  %604 = getelementptr inbounds float, float* %542, i64 %559
  %605 = load float, float* %604, align 4
  %606 = fadd float %603, %605
  %607 = getelementptr inbounds float, float* %543, i64 %554
  %608 = load float, float* %607, align 4
  %609 = fadd float %606, %608
  %610 = getelementptr inbounds float, float* %543, i64 %551
  %611 = load float, float* %610, align 4
  %612 = fadd float %609, %611
  %613 = getelementptr inbounds float, float* %543, i64 %559
  %614 = load float, float* %613, align 4
  %615 = fadd float %612, %614
  %616 = fmul float %615, 0x3FE1666660000000
  %617 = fsub float %592, %616
  %618 = fmul float %617, %617
  %619 = fadd float %589, %618
  %620 = getelementptr inbounds float, float* %544, i64 %551
  %621 = load float, float* %620, align 4
  %622 = fmul float %621, 0x3FD25E3540000000
  %623 = getelementptr inbounds float, float* %544, i64 %554
  %624 = load float, float* %623, align 4
  %625 = getelementptr inbounds float, float* %544, i64 %559
  %626 = load float, float* %625, align 4
  %627 = fadd float %624, %626
  %628 = getelementptr inbounds float, float* %545, i64 %554
  %629 = load float, float* %628, align 4
  %630 = fadd float %627, %629
  %631 = getelementptr inbounds float, float* %545, i64 %551
  %632 = load float, float* %631, align 4
  %633 = fadd float %630, %632
  %634 = getelementptr inbounds float, float* %545, i64 %559
  %635 = load float, float* %634, align 4
  %636 = fadd float %633, %635
  %637 = getelementptr inbounds float, float* %546, i64 %554
  %638 = load float, float* %637, align 4
  %639 = fadd float %636, %638
  %640 = getelementptr inbounds float, float* %546, i64 %551
  %641 = load float, float* %640, align 4
  %642 = fadd float %639, %641
  %643 = getelementptr inbounds float, float* %546, i64 %559
  %644 = load float, float* %643, align 4
  %645 = fadd float %642, %644
  %646 = fmul float %645, 0x3FA25E3540000000
  %647 = fsub float %622, %646
  %648 = fmul float %647, %647
  %649 = fadd float %619, %648
  %650 = getelementptr inbounds float, float* %547, i64 %549
  store float %649, float* %650, align 4
  %651 = add nuw i64 %549, 1
  %652 = icmp ult i64 %651, %139
  br i1 %652, label %548, label %653

653:                                              ; preds = %548, %534
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %155) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %142) #7
  %654 = add nuw i64 %209, 1
  %655 = icmp ult i64 %654, %125
  br i1 %655, label %656, label %177

656:                                              ; preds = %653
  %657 = load i32, i32* %116, align 4
  br label %207

658:                                              ; preds = %755, %193
  %659 = phi i64 [ %197, %193 ], [ %206, %755 ]
  %660 = phi i64 [ %196, %193 ], [ %205, %755 ]
  %661 = phi i64 [ %194, %193 ], [ %201, %755 ]
  %662 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 4
  %663 = load i64, i64* %662, align 8
  %664 = lshr i64 %663, 2
  %665 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %666 = load i8*, i8** %665, align 8
  %667 = ptrtoint i8* %666 to i64
  %668 = and i64 %667, 63
  %669 = icmp eq i64 %668, 0
  tail call void @llvm.assume(i1 %669) #7
  %670 = bitcast [4 x float*]* %11 to i8*
  %671 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 1
  %672 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 2
  %673 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 3
  %674 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %675 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %676 = bitcast i8* %666 to float*
  %677 = or i64 %660, 1
  %678 = or i64 %659, 1
  %679 = bitcast [4 x float*]* %11 to i8**
  %680 = bitcast float** %671 to i8**
  %681 = bitcast float** %672 to i8**
  %682 = bitcast float** %673 to i8**
  %683 = shl i64 %180, 3
  %684 = shl i64 %661, 3
  %685 = sub i64 2, %684
  br label %785

686:                                              ; preds = %198, %755
  %687 = phi i64 [ 0, %198 ], [ %756, %755 ]
  %688 = shl i64 %687, 2
  %689 = or i64 %688, 2
  %690 = load i8*, i8** %199, align 8
  %691 = load i64, i64* %200, align 8
  %692 = mul i64 %691, %689
  %693 = getelementptr inbounds i8, i8* %690, i64 %692
  %694 = ptrtoint i8* %693 to i64
  %695 = and i64 %694, 63
  %696 = icmp eq i64 %695, 0
  tail call void @llvm.assume(i1 %696) #7
  %697 = or i64 %688, 3
  %698 = mul i64 %691, %697
  %699 = getelementptr inbounds i8, i8* %690, i64 %698
  %700 = ptrtoint i8* %699 to i64
  %701 = and i64 %700, 63
  %702 = icmp eq i64 %701, 0
  tail call void @llvm.assume(i1 %702) #7
  %703 = add i64 %689, 2
  %704 = mul i64 %691, %703
  %705 = getelementptr inbounds i8, i8* %690, i64 %704
  %706 = ptrtoint i8* %705 to i64
  %707 = and i64 %706, 63
  %708 = icmp eq i64 %707, 0
  tail call void @llvm.assume(i1 %708) #7
  %709 = add i64 %689, 3
  %710 = mul i64 %691, %709
  %711 = getelementptr inbounds i8, i8* %690, i64 %710
  %712 = ptrtoint i8* %711 to i64
  %713 = and i64 %712, 63
  %714 = icmp eq i64 %713, 0
  tail call void @llvm.assume(i1 %714) #7
  %715 = mul i64 %183, %687
  %716 = getelementptr inbounds float, float* %192, i64 %715
  br i1 %204, label %755, label %717

717:                                              ; preds = %686
  %718 = getelementptr inbounds i8, i8* %693, i64 8
  %719 = bitcast i8* %718 to float*
  %720 = getelementptr inbounds i8, i8* %699, i64 8
  %721 = bitcast i8* %720 to float*
  %722 = getelementptr inbounds i8, i8* %705, i64 8
  %723 = bitcast i8* %722 to float*
  %724 = getelementptr inbounds i8, i8* %711, i64 8
  %725 = bitcast i8* %724 to float*
  br label %726

726:                                              ; preds = %717, %726
  %727 = phi i64 [ %753, %726 ], [ 0, %717 ]
  %728 = shl i64 %727, 2
  %729 = getelementptr inbounds float, float* %719, i64 %728
  %730 = bitcast float* %729 to <4 x float>*
  %731 = load <4 x float>, <4 x float>* %730, align 8, !alias.scope !51
  %732 = fadd <4 x float> %731, zeroinitializer
  %733 = getelementptr inbounds float, float* %721, i64 %728
  %734 = bitcast float* %733 to <4 x float>*
  %735 = load <4 x float>, <4 x float>* %734, align 8, !alias.scope !51
  %736 = fadd <4 x float> %732, %735
  %737 = getelementptr inbounds float, float* %723, i64 %728
  %738 = bitcast float* %737 to <4 x float>*
  %739 = load <4 x float>, <4 x float>* %738, align 8, !alias.scope !51
  %740 = fadd <4 x float> %736, %739
  %741 = getelementptr inbounds float, float* %725, i64 %728
  %742 = bitcast float* %741 to <4 x float>*
  %743 = load <4 x float>, <4 x float>* %742, align 8, !alias.scope !51
  %744 = fadd <4 x float> %740, %743
  %745 = shufflevector <4 x float> %744, <4 x float> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %746 = fadd <4 x float> %744, %745
  %747 = shufflevector <4 x float> %746, <4 x float> undef, <4 x i32> <i32 1, i32 2, i32 3, i32 0>
  %748 = fadd <4 x float> %746, %747
  %749 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %748) #7
  %750 = extractelement <4 x float> %749, i32 0
  %751 = fmul float %750, 2.500000e-01
  %752 = getelementptr inbounds float, float* %716, i64 %727
  store float %751, float* %752, align 4
  %753 = add nuw i64 %727, 1
  %754 = icmp ult i64 %753, %205
  br i1 %754, label %726, label %755

755:                                              ; preds = %726, %686
  %756 = add nuw i64 %687, 1
  %757 = icmp ult i64 %756, %206
  br i1 %757, label %686, label %658

758:                                              ; preds = %836
  %759 = bitcast i64* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %759) #7
  store i64 %180, i64* %12, align 8
  %760 = icmp ugt i64 %105, %180
  br i1 %760, label %761, label %914

761:                                              ; preds = %758
  %762 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %763 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 4
  %764 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %765 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %766 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 4
  %767 = bitcast i64* %13 to i8*
  %768 = icmp ult i64 %661, %111
  %769 = bitcast float* %14 to i8*
  %770 = bitcast float* %15 to i8*
  %771 = bitcast float* %16 to i8*
  %772 = bitcast float* %17 to i8*
  %773 = bitcast i32* %18 to i8*
  %774 = bitcast float* %19 to i8*
  %775 = bitcast i32* %18 to float*
  %776 = bitcast float* %20 to i8*
  %777 = bitcast float* %21 to i8*
  %778 = bitcast float* %22 to i8*
  %779 = bitcast float* %23 to i8*
  %780 = bitcast float* %24 to i8*
  %781 = bitcast float* %25 to i8*
  %782 = bitcast float* %26 to i8*
  %783 = bitcast float* %27 to i8*
  %784 = load i64, i64* %12, align 8
  br label %915

785:                                              ; preds = %836, %658
  %786 = phi i64 [ 0, %658 ], [ %837, %836 ]
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %670) #7
  %787 = shl i64 %786, 2
  %788 = load i8*, i8** %674, align 8
  %789 = load i64, i64* %675, align 8
  %790 = mul i64 %789, %787
  %791 = getelementptr inbounds i8, i8* %788, i64 %790
  %792 = ptrtoint i8* %791 to i64
  %793 = and i64 %792, 63
  %794 = icmp eq i64 %793, 0
  tail call void @llvm.assume(i1 %794) #7
  store i8* %791, i8** %679, align 16
  %795 = or i64 %787, 1
  %796 = mul i64 %789, %795
  %797 = getelementptr inbounds i8, i8* %788, i64 %796
  %798 = ptrtoint i8* %797 to i64
  %799 = and i64 %798, 63
  %800 = icmp eq i64 %799, 0
  tail call void @llvm.assume(i1 %800) #7
  store i8* %797, i8** %680, align 8
  %801 = or i64 %787, 2
  %802 = mul i64 %789, %801
  %803 = getelementptr inbounds i8, i8* %788, i64 %802
  %804 = ptrtoint i8* %803 to i64
  %805 = and i64 %804, 63
  %806 = icmp eq i64 %805, 0
  tail call void @llvm.assume(i1 %806) #7
  store i8* %803, i8** %681, align 16
  %807 = or i64 %787, 3
  %808 = mul i64 %789, %807
  %809 = getelementptr inbounds i8, i8* %788, i64 %808
  %810 = ptrtoint i8* %809 to i64
  %811 = and i64 %810, 63
  %812 = icmp eq i64 %811, 0
  tail call void @llvm.assume(i1 %812) #7
  store i8* %809, i8** %682, align 8
  %813 = mul i64 %664, %786
  %814 = getelementptr inbounds float, float* %676, i64 %813
  %815 = add i64 %683, %787
  %816 = icmp eq i64 %815, 0
  %817 = select i1 %816, i64 2, i64 0
  %818 = add i64 %815, 4
  %819 = load i32, i32* %116, align 4
  %820 = zext i32 %819 to i64
  %821 = add nuw nsw i64 %820, 2
  %822 = icmp ugt i64 %818, %821
  %823 = bitcast i8* %791 to float*
  %824 = bitcast i8* %797 to float*
  %825 = bitcast i8* %803 to float*
  %826 = bitcast i8* %809 to float*
  br i1 %822, label %827, label %831

827:                                              ; preds = %785
  %828 = sub i64 2, %787
  %829 = sub i64 %828, %683
  %830 = add i64 %829, %820
  br label %831

831:                                              ; preds = %785, %827
  %832 = phi i64 [ %830, %827 ], [ 4, %785 ]
  %833 = sub i64 %832, %817
  %834 = icmp eq i64 %833, 4
  %835 = icmp ugt i64 %832, %817
  br label %839

836:                                              ; preds = %908
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %670) #7
  %837 = add nuw i64 %786, 1
  %838 = icmp eq i64 %837, %678
  br i1 %838, label %758, label %785

839:                                              ; preds = %908, %831
  %840 = phi i64 [ 0, %831 ], [ %911, %908 ]
  %841 = shl i64 %840, 2
  %842 = add i64 %684, %841
  %843 = icmp eq i64 %842, 0
  %844 = or i64 %841, 2
  %845 = select i1 %843, i64 %844, i64 %841
  %846 = add i64 %842, 4
  %847 = load i32, i32* %130, align 8
  %848 = zext i32 %847 to i64
  %849 = add nuw nsw i64 %848, 2
  %850 = icmp ugt i64 %846, %849
  %851 = add i64 %841, 4
  %852 = add i64 %685, %848
  %853 = select i1 %850, i64 %852, i64 %851
  %854 = sub i64 %853, %845
  %855 = icmp eq i64 %854, 4
  %856 = and i1 %834, %855
  br i1 %856, label %857, label %881

857:                                              ; preds = %839
  %858 = getelementptr inbounds float, float* %823, i64 %845
  %859 = bitcast float* %858 to <4 x float>*
  %860 = load <4 x float>, <4 x float>* %859, align 16, !alias.scope !54
  %861 = fadd <4 x float> %860, zeroinitializer
  %862 = getelementptr inbounds float, float* %824, i64 %845
  %863 = bitcast float* %862 to <4 x float>*
  %864 = load <4 x float>, <4 x float>* %863, align 16, !alias.scope !54
  %865 = fadd <4 x float> %861, %864
  %866 = getelementptr inbounds float, float* %825, i64 %845
  %867 = bitcast float* %866 to <4 x float>*
  %868 = load <4 x float>, <4 x float>* %867, align 16, !alias.scope !54
  %869 = fadd <4 x float> %865, %868
  %870 = getelementptr inbounds float, float* %826, i64 %845
  %871 = bitcast float* %870 to <4 x float>*
  %872 = load <4 x float>, <4 x float>* %871, align 16, !alias.scope !54
  %873 = fadd <4 x float> %869, %872
  %874 = shufflevector <4 x float> %873, <4 x float> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %875 = fadd <4 x float> %873, %874
  %876 = shufflevector <4 x float> %875, <4 x float> undef, <4 x i32> <i32 1, i32 2, i32 3, i32 0>
  %877 = fadd <4 x float> %875, %876
  %878 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %877) #7
  %879 = extractelement <4 x float> %878, i32 0
  %880 = fmul float %879, 2.500000e-01
  br label %908

881:                                              ; preds = %839
  br i1 %835, label %882, label %890

882:                                              ; preds = %881
  %883 = icmp ugt i64 %853, %845
  br label %884

884:                                              ; preds = %882, %896
  %885 = phi i64 [ %817, %882 ], [ %898, %896 ]
  %886 = phi float [ 0.000000e+00, %882 ], [ %897, %896 ]
  br i1 %883, label %887, label %896

887:                                              ; preds = %884
  %888 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 %885
  %889 = load float*, float** %888, align 8
  br label %900

890:                                              ; preds = %896, %881
  %891 = phi float [ 0.000000e+00, %881 ], [ %897, %896 ]
  %892 = mul i64 %854, %833
  %893 = uitofp i64 %892 to float
  %894 = fdiv float %891, %893
  %895 = tail call float @sqrtf(float %894) #7
  br label %908

896:                                              ; preds = %900, %884
  %897 = phi float [ %886, %884 ], [ %905, %900 ]
  %898 = add nuw i64 %885, 1
  %899 = icmp ult i64 %898, %832
  br i1 %899, label %884, label %890

900:                                              ; preds = %887, %900
  %901 = phi i64 [ %845, %887 ], [ %906, %900 ]
  %902 = phi float [ %886, %887 ], [ %905, %900 ]
  %903 = getelementptr inbounds float, float* %889, i64 %901
  %904 = load float, float* %903, align 4
  %905 = fadd float %902, %904
  %906 = add nuw i64 %901, 1
  %907 = icmp ult i64 %906, %853
  br i1 %907, label %900, label %896

908:                                              ; preds = %890, %857
  %909 = phi float [ %895, %890 ], [ %880, %857 ]
  %910 = getelementptr inbounds float, float* %814, i64 %840
  store float %909, float* %910, align 4
  %911 = add nuw i64 %840, 1
  %912 = icmp eq i64 %911, %677
  br i1 %912, label %836, label %839

913:                                              ; preds = %945
  store i64 %946, i64* %12, align 8
  br label %914

914:                                              ; preds = %913, %758
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %759) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %106) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %100) #7
  br label %1168

915:                                              ; preds = %761, %945
  %916 = phi i64 [ %784, %761 ], [ %946, %945 ]
  %917 = phi i64 [ %180, %761 ], [ %946, %945 ]
  %918 = load i8*, i8** %762, align 8
  %919 = load i64, i64* %763, align 8
  %920 = mul i64 %919, %917
  %921 = getelementptr inbounds i8, i8* %918, i64 %920
  %922 = ptrtoint i8* %921 to i64
  %923 = and i64 %922, 63
  %924 = icmp eq i64 %923, 0
  tail call void @llvm.assume(i1 %924) #7
  %925 = load i8*, i8** %764, align 8
  %926 = load i64, i64* %98, align 8
  %927 = mul i64 %926, %917
  %928 = getelementptr inbounds i8, i8* %925, i64 %927
  %929 = ptrtoint i8* %928 to i64
  %930 = and i64 %929, 63
  %931 = icmp eq i64 %930, 0
  tail call void @llvm.assume(i1 %931) #7
  %932 = load i8*, i8** %765, align 8
  %933 = load i64, i64* %766, align 8
  %934 = mul i64 %933, %917
  %935 = getelementptr inbounds i8, i8* %932, i64 %934
  %936 = ptrtoint i8* %935 to i64
  %937 = and i64 %936, 63
  %938 = icmp eq i64 %937, 0
  tail call void @llvm.assume(i1 %938) #7
  %939 = bitcast i8* %935 to float*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %767) #7
  store i64 %661, i64* %13, align 8
  br i1 %768, label %940, label %945

940:                                              ; preds = %915
  %941 = sub i64 %917, %180
  %942 = shl i64 %941, 1
  %943 = load i64, i64* %13, align 8
  br label %948

944:                                              ; preds = %1151
  store i64 %1152, i64* %13, align 8
  br label %945

945:                                              ; preds = %944, %915
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %767) #7
  %946 = add i64 %916, 1
  %947 = icmp ult i64 %946, %105
  br i1 %947, label %915, label %913

948:                                              ; preds = %940, %1151
  %949 = phi i64 [ %943, %940 ], [ %1152, %1151 ]
  %950 = phi i64 [ %661, %940 ], [ %1152, %1151 ]
  %951 = getelementptr inbounds i8, i8* %921, i64 %950
  %952 = load i8, i8* %951, align 1
  %953 = and i8 %952, 1
  %954 = icmp eq i8 %953, 0
  br i1 %954, label %1151, label %955

955:                                              ; preds = %948
  %956 = lshr i8 %952, 1
  %957 = getelementptr inbounds float, float* %939, i64 %950
  %958 = load float, float* %957, align 4
  %959 = fdiv float 1.000000e+00, %958
  %960 = zext i8 %956 to i64
  %961 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut, i64 0, i64 %960
  %962 = load i8, i8* %961, align 1
  %963 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %960
  %964 = sub i64 %950, %661
  %965 = shl i64 %964, 1
  %966 = zext i8 %962 to i64
  %967 = shl nuw nsw i64 %966, 1
  %968 = load i8, i8* %963, align 1
  %969 = zext i8 %968 to i64
  %970 = shl nuw nsw i64 %969, 1
  br label %971

971:                                              ; preds = %993, %955
  %972 = phi i64 [ 0, %955 ], [ %994, %993 ]
  %973 = phi float [ 0.000000e+00, %955 ], [ %1004, %993 ]
  %974 = add i64 %942, %972
  %975 = mul i64 %974, %183
  br label %996

976:                                              ; preds = %993
  %977 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %960
  %978 = load i8, i8* %977, align 1
  %979 = zext i8 %978 to i64
  %980 = shl nuw nsw i64 %966, 2
  %981 = mul nuw nsw i64 %980, %979
  %982 = uitofp i64 %981 to float
  %983 = fdiv float %1004, %982
  %984 = tail call float @sqrtf(float %983) #7
  %985 = sub i64 %950, %661
  %986 = shl i64 %985, 1
  %987 = fmul float %959, 6.250000e-02
  %988 = fpext float %984 to double
  %989 = fpext float %987 to double
  %990 = fmul double %989, 0x400A000006666666
  %991 = fadd double %990, %988
  %992 = fmul float %987, 0x3FB5C28F60000000
  br label %1007

993:                                              ; preds = %996
  %994 = add nuw nsw i64 %972, 1
  %995 = icmp ult i64 %994, %967
  br i1 %995, label %971, label %976

996:                                              ; preds = %971, %996
  %997 = phi i64 [ 0, %971 ], [ %1005, %996 ]
  %998 = phi float [ %973, %971 ], [ %1004, %996 ]
  %999 = add i64 %975, %997
  %1000 = add i64 %999, %965
  %1001 = getelementptr inbounds float, float* %192, i64 %1000
  %1002 = load float, float* %1001, align 4
  %1003 = fmul float %1002, %1002
  %1004 = fadd float %998, %1003
  %1005 = add nuw nsw i64 %997, 1
  %1006 = icmp ult i64 %1005, %970
  br i1 %1006, label %996, label %993

1007:                                             ; preds = %976, %1020
  %1008 = phi i64 [ 0, %976 ], [ %1021, %1020 ]
  %1009 = shl nuw i64 %1008, 1
  %1010 = add i64 %942, %1009
  %1011 = mul i64 %1010, %183
  %1012 = or i64 %1009, 1
  %1013 = add i64 %942, %1012
  %1014 = mul i64 %1013, %183
  %1015 = mul i64 %664, %1013
  %1016 = mul i64 %664, %1010
  %1017 = add i64 %1010, 2
  %1018 = mul i64 %664, %1017
  %1019 = mul i64 %1008, %99
  br label %1023

1020:                                             ; preds = %1023
  %1021 = add nuw nsw i64 %1008, 1
  %1022 = icmp eq i64 %1021, %966
  br i1 %1022, label %1151, label %1007

1023:                                             ; preds = %1007, %1023
  %1024 = phi i64 [ 0, %1007 ], [ %1149, %1023 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %769)
  %1025 = shl nuw i64 %1024, 1
  %1026 = add i64 %986, %1025
  %1027 = add i64 %1026, %1011
  %1028 = getelementptr inbounds float, float* %192, i64 %1027
  %1029 = load float, float* %1028, align 8
  store float %1029, float* %14, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %770)
  %1030 = or i64 %1025, 1
  %1031 = add i64 %986, %1030
  %1032 = add i64 %1031, %1011
  %1033 = getelementptr inbounds float, float* %192, i64 %1032
  %1034 = load float, float* %1033, align 4
  store float %1034, float* %15, align 4
  %1035 = fcmp olt float %1034, %1029
  %1036 = select i1 %1035, float* %15, float* %14
  %1037 = bitcast float* %1036 to i32*
  %1038 = load i32, i32* %1037, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %770)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %769)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %771)
  %1039 = add i64 %1026, %1014
  %1040 = getelementptr inbounds float, float* %192, i64 %1039
  %1041 = load float, float* %1040, align 4
  store float %1041, float* %16, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %772)
  %1042 = add i64 %1031, %1014
  %1043 = getelementptr inbounds float, float* %192, i64 %1042
  %1044 = load float, float* %1043, align 4
  store float %1044, float* %17, align 4
  %1045 = fcmp olt float %1044, %1041
  %1046 = select i1 %1045, float* %17, float* %16
  %1047 = bitcast float* %1046 to i32*
  %1048 = load i32, i32* %1047, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %772)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %771)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %773)
  %1049 = bitcast i32 %1048 to float
  %1050 = bitcast i32 %1038 to float
  %1051 = fcmp olt float %1049, %1050
  %1052 = select i1 %1051, i32 %1048, i32 %1038
  store i32 %1052, i32* %18, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %774)
  %1053 = add i64 %1031, %1015
  %1054 = getelementptr inbounds float, float* %676, i64 %1053
  %1055 = load float, float* %1054, align 4
  store float %1055, float* %19, align 4
  %1056 = bitcast i32 %1052 to float
  %1057 = fcmp olt float %1055, %1056
  %1058 = select i1 %1057, float* %19, float* %775
  %1059 = bitcast float* %1058 to i32*
  %1060 = load i32, i32* %1059, align 4
  store i32 %1060, i32* %18, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %774)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %776)
  %1061 = add i64 %1026, %1016
  %1062 = getelementptr inbounds float, float* %676, i64 %1061
  %1063 = load float, float* %1062, align 8
  store float %1063, float* %20, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %777)
  %1064 = add i64 %1031, %1016
  %1065 = getelementptr inbounds float, float* %676, i64 %1064
  %1066 = load float, float* %1065, align 4
  store float %1066, float* %21, align 4
  %1067 = fcmp olt float %1066, %1063
  %1068 = select i1 %1067, float* %21, float* %20
  %1069 = bitcast float* %1068 to i32*
  %1070 = load i32, i32* %1069, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %777)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %776)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %778)
  %1071 = add nuw nsw i64 %1025, 2
  %1072 = add i64 %986, %1071
  %1073 = add i64 %1072, %1016
  %1074 = getelementptr inbounds float, float* %676, i64 %1073
  %1075 = load float, float* %1074, align 8
  store float %1075, float* %22, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %779)
  %1076 = add i64 %1026, %1015
  %1077 = getelementptr inbounds float, float* %676, i64 %1076
  %1078 = load float, float* %1077, align 4
  store float %1078, float* %23, align 4
  %1079 = fcmp olt float %1078, %1075
  %1080 = select i1 %1079, float* %23, float* %22
  %1081 = bitcast float* %1080 to i32*
  %1082 = load i32, i32* %1081, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %779)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %778)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %780)
  store float %1055, float* %24, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %781)
  %1083 = add i64 %1072, %1015
  %1084 = getelementptr inbounds float, float* %676, i64 %1083
  %1085 = load float, float* %1084, align 4
  store float %1085, float* %25, align 4
  %1086 = fcmp olt float %1085, %1055
  %1087 = select i1 %1086, float* %25, float* %24
  %1088 = bitcast float* %1087 to i32*
  %1089 = load i32, i32* %1088, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %781)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %780)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %782)
  %1090 = add i64 %1026, %1018
  %1091 = getelementptr inbounds float, float* %676, i64 %1090
  %1092 = load float, float* %1091, align 8
  store float %1092, float* %26, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %783)
  %1093 = add i64 %1031, %1018
  %1094 = getelementptr inbounds float, float* %676, i64 %1093
  %1095 = load float, float* %1094, align 4
  store float %1095, float* %27, align 4
  %1096 = fcmp olt float %1095, %1092
  %1097 = select i1 %1096, float* %27, float* %26
  %1098 = bitcast float* %1097 to i32*
  %1099 = load i32, i32* %1098, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %783)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %782)
  %1100 = bitcast i32 %1082 to float
  %1101 = bitcast i32 %1070 to float
  %1102 = fcmp olt float %1100, %1101
  %1103 = select i1 %1102, i32 %1082, i32 %1070
  %1104 = bitcast i32 %1099 to float
  %1105 = bitcast i32 %1089 to float
  %1106 = fcmp olt float %1104, %1105
  %1107 = select i1 %1106, i32 %1099, i32 %1089
  %1108 = bitcast i32 %1107 to float
  %1109 = bitcast i32 %1103 to float
  %1110 = fcmp olt float %1108, %1109
  %1111 = select i1 %1110, i32 %1107, i32 %1103
  %1112 = add i64 %1072, %1018
  %1113 = getelementptr inbounds float, float* %676, i64 %1112
  %1114 = load float, float* %1113, align 8
  %1115 = bitcast i32 %1111 to float
  %1116 = fcmp olt float %1114, %1115
  %1117 = bitcast i32 %1111 to float
  %1118 = select i1 %1116, float %1114, float %1117
  %1119 = bitcast i32 %1060 to float
  %1120 = fcmp olt float %1118, %1119
  %1121 = load float, float* %775, align 4
  %1122 = select i1 %1120, float %1118, float %1121
  %1123 = fmul float %1119, 1.250000e-01
  %1124 = fmul float %1122, 6.250000e-01
  %1125 = fadd float %1123, %1124
  %1126 = fmul float %1122, 1.500000e+00
  %1127 = fcmp olt float %1055, %1126
  %1128 = select i1 %1127, float %1055, float %1126
  %1129 = fmul float %1128, 1.250000e-01
  %1130 = fadd float %1125, %1129
  %1131 = fmul float %1118, 1.250000e-01
  %1132 = fadd float %1131, %1130
  %1133 = fadd float %987, %1132
  %1134 = fpext float %1133 to double
  %1135 = fdiv double %991, %1134
  %1136 = fptrunc double %1135 to float
  %1137 = fcmp ogt float %1136, 0x40099999A0000000
  %1138 = fadd float %1029, %1034
  %1139 = fadd float %1138, %1041
  %1140 = fadd float %1139, %1044
  %1141 = fadd float %1140, %1132
  %1142 = fmul float %1141, 0x3FC99999A0000000
  %1143 = fcmp olt float %1142, %992
  %1144 = or i1 %1143, %1137
  %1145 = select i1 %1144, i8 4, i8 0
  %1146 = add i64 %1024, %1019
  %1147 = add i64 %1146, %950
  %1148 = getelementptr inbounds i8, i8* %928, i64 %1147
  store i8 %1145, i8* %1148, align 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %773)
  %1149 = add nuw nsw i64 %1024, 1
  %1150 = icmp ult i64 %1149, %979
  br i1 %1150, label %1023, label %1020

1151:                                             ; preds = %1020, %948
  %1152 = add i64 %949, 1
  %1153 = icmp ult i64 %1152, %111
  br i1 %1153, label %948, label %944

1154:                                             ; preds = %1171, %66
  %1155 = phi i64 [ 0, %66 ], [ %1172, %1171 ]
  %1156 = icmp eq i64 %70, 0
  br i1 %1156, label %1168, label %1157

1157:                                             ; preds = %1154
  %1158 = add i64 %1155, %60
  %1159 = load i8*, i8** %67, align 8
  %1160 = load i64, i64* %68, align 8
  %1161 = mul i64 %1160, %1158
  %1162 = getelementptr inbounds i8, i8* %1159, i64 %1161
  %1163 = ptrtoint i8* %1162 to i64
  %1164 = and i64 %1163, 63
  %1165 = icmp eq i64 %1164, 0
  tail call void @llvm.assume(i1 %1165) #7
  br i1 %69, label %1168, label %1166

1166:                                             ; preds = %1157
  %1167 = getelementptr inbounds i8, i8* %1162, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1167, i8 4, i64 %62, i1 false) #7
  br label %1168

1168:                                             ; preds = %1154, %1157, %1166, %56, %914
  ret void

1169:                                             ; preds = %87
  %1170 = getelementptr inbounds i8, i8* %93, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1170, i8 4, i64 %62, i1 false) #7
  br label %1171

1171:                                             ; preds = %1169, %87
  %1172 = add nuw i64 %75, 2
  %1173 = add i64 %76, -2
  %1174 = icmp eq i64 %1173, 0
  br i1 %1174, label %1154, label %74
}

; Function Attrs: nounwind ssp uwtable
define internal void @_ZN3jxl6N_AVX212_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE(%"class.jxl::Image3"* dereferenceable(96), %"struct.jxl::PassesEncoderState"* nocapture readonly, %"class.jxl::Rect"* nocapture readonly dereferenceable(32), %"struct.jxl::ArControlFieldHeuristics::TempImages"*) #2 {
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca float*, align 8
  %8 = alloca [3 x float*], align 16
  %9 = alloca [3 x float*], align 16
  %10 = alloca [3 x float*], align 16
  %11 = alloca [4 x float*], align 16
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca float, align 4
  %15 = alloca float, align 4
  %16 = alloca float, align 4
  %17 = alloca float, align 4
  %18 = alloca i32, align 4
  %19 = alloca float, align 4
  %20 = alloca float, align 4
  %21 = alloca float, align 4
  %22 = alloca float, align 4
  %23 = alloca float, align 4
  %24 = alloca float, align 4
  %25 = alloca float, align 4
  %26 = alloca float, align 4
  %27 = alloca float, align 4
  %28 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 0
  %29 = load i32, i32* %28, align 8
  %30 = zext i32 %29 to i64
  %31 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 8
  %32 = load i64, i64* %31, align 8
  %33 = icmp eq i64 %32, %30
  br i1 %33, label %34, label %41

34:                                               ; preds = %4
  %35 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 1
  %36 = load i32, i32* %35, align 4
  %37 = zext i32 %36 to i64
  %38 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 9
  %39 = load i64, i64* %38, align 8
  %40 = icmp eq i64 %39, %37
  br i1 %40, label %44, label %41

41:                                               ; preds = %4, %34
  %42 = tail call zeroext i1 (i8*, ...) @_ZN3jxl5DebugEPKcz(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.1, i64 0, i64 0), i32 54, i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.str.2, i64 0, i64 0)) #7
  %43 = tail call zeroext i1 @_ZN3jxl5AbortEv() #10
  unreachable

44:                                               ; preds = %34
  %45 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 0
  %46 = load float, float* %45, align 8
  %47 = fcmp olt float %46, 5.000000e-01
  br i1 %47, label %56, label %48

48:                                               ; preds = %44
  %49 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 7
  %50 = load i32, i32* %49, align 4
  %51 = icmp sgt i32 %50, 4
  br i1 %51, label %56, label %52

52:                                               ; preds = %48
  %53 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 1, i32 26, i32 11
  %54 = load i32, i32* %53, align 4
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %97

56:                                               ; preds = %52, %48, %44
  %57 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %58 = load i64, i64* %57, align 8
  %59 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %60 = load i64, i64* %59, align 8
  %61 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %62 = load i64, i64* %61, align 8
  %63 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %64 = load i64, i64* %63, align 8
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %1168, label %66

66:                                               ; preds = %56
  %67 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %68 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %69 = icmp eq i64 %62, 0
  %70 = and i64 %64, 1
  %71 = icmp eq i64 %64, 1
  br i1 %71, label %1154, label %72

72:                                               ; preds = %66
  %73 = sub i64 %64, %70
  br label %74

74:                                               ; preds = %1171, %72
  %75 = phi i64 [ 0, %72 ], [ %1172, %1171 ]
  %76 = phi i64 [ %73, %72 ], [ %1173, %1171 ]
  %77 = add i64 %75, %60
  %78 = load i8*, i8** %67, align 8
  %79 = load i64, i64* %68, align 8
  %80 = mul i64 %79, %77
  %81 = getelementptr inbounds i8, i8* %78, i64 %80
  %82 = ptrtoint i8* %81 to i64
  %83 = and i64 %82, 63
  %84 = icmp eq i64 %83, 0
  tail call void @llvm.assume(i1 %84) #7
  br i1 %69, label %87, label %85

85:                                               ; preds = %74
  %86 = getelementptr inbounds i8, i8* %81, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %86, i8 4, i64 %62, i1 false) #7
  br label %87

87:                                               ; preds = %85, %74
  %88 = or i64 %75, 1
  %89 = add i64 %88, %60
  %90 = load i8*, i8** %67, align 8
  %91 = load i64, i64* %68, align 8
  %92 = mul i64 %91, %89
  %93 = getelementptr inbounds i8, i8* %90, i64 %92
  %94 = ptrtoint i8* %93 to i64
  %95 = and i64 %94, 63
  %96 = icmp eq i64 %95, 0
  tail call void @llvm.assume(i1 %96) #7
  br i1 %69, label %1171, label %1169

97:                                               ; preds = %52
  %98 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %99 = load i64, i64* %98, align 8
  %100 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %100) #7
  %101 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %102 = load i64, i64* %101, align 8
  store i64 %102, i64* %5, align 8
  %103 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %104 = load i64, i64* %103, align 8
  %105 = add i64 %104, %102
  %106 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %106) #7
  %107 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %108 = load i64, i64* %107, align 8
  store i64 %108, i64* %6, align 8
  %109 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %110 = load i64, i64* %109, align 8
  %111 = add i64 %110, %108
  tail call void @_ZN3jxl24ArControlFieldHeuristics10TempImages8InitOnceEv(%"struct.jxl::ArControlFieldHeuristics::TempImages"* %3)
  %112 = icmp eq i64 %102, 0
  %113 = select i1 %112, i64 2, i64 0
  %114 = shl i64 %105, 3
  %115 = or i64 %114, 4
  %116 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 1
  %117 = load i32, i32* %116, align 4
  %118 = zext i32 %117 to i64
  %119 = add nuw nsw i64 %118, 2
  %120 = icmp ugt i64 %115, %119
  %121 = shl i64 %104, 3
  %122 = or i64 %121, 4
  %123 = shl i64 %102, 3
  %124 = sub i64 %119, %123
  %125 = select i1 %120, i64 %124, i64 %122
  %126 = icmp eq i64 %108, 0
  %127 = select i1 %126, i64 2, i64 0
  %128 = shl i64 %111, 3
  %129 = or i64 %128, 4
  %130 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 0
  %131 = load i32, i32* %130, align 8
  %132 = zext i32 %131 to i64
  %133 = add nuw nsw i64 %132, 2
  %134 = icmp ugt i64 %129, %133
  %135 = shl i64 %110, 3
  %136 = or i64 %135, 4
  %137 = shl i64 %108, 3
  %138 = sub i64 %133, %137
  %139 = select i1 %134, i64 %138, i64 %136
  %140 = icmp ult i64 %113, %125
  br i1 %140, label %141, label %179

141:                                              ; preds = %97
  %142 = bitcast float** %7 to i8*
  %143 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %144 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %145 = bitcast float** %7 to i8**
  %146 = shl i64 %102, 3
  %147 = bitcast [3 x float*]* %8 to i8*
  %148 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 0
  %149 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 1
  %150 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 2
  %151 = bitcast [3 x float*]* %9 to i8*
  %152 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 0
  %153 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 1
  %154 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 2
  %155 = bitcast [3 x float*]* %10 to i8*
  %156 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 0
  %157 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 1
  %158 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 2
  %159 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 4
  %160 = shl i64 %108, 3
  %161 = or i64 %160, %127
  %162 = icmp ult i64 %161, 3
  %163 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %164 = bitcast [3 x float*]* %8 to i8**
  %165 = bitcast [3 x float*]* %9 to i8**
  %166 = bitcast [3 x float*]* %10 to i8**
  %167 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %168 = bitcast float** %149 to i8**
  %169 = bitcast float** %153 to i8**
  %170 = bitcast float** %157 to i8**
  %171 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %172 = bitcast float** %150 to i8**
  %173 = bitcast float** %154 to i8**
  %174 = bitcast float** %158 to i8**
  %175 = add i64 %160, -1
  %176 = add i64 %160, -2
  br label %207

177:                                              ; preds = %653
  %178 = load i64, i64* %5, align 8
  br label %179

179:                                              ; preds = %177, %97
  %180 = phi i64 [ %178, %177 ], [ %102, %97 ]
  %181 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 4
  %182 = load i64, i64* %181, align 8
  %183 = lshr i64 %182, 2
  %184 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %185 = load i8*, i8** %184, align 8
  %186 = ptrtoint i8* %185 to i64
  %187 = and i64 %186, 63
  %188 = icmp eq i64 %187, 0
  tail call void @llvm.assume(i1 %188) #7
  %189 = sub i64 %105, %180
  %190 = and i64 %189, 9223372036854775807
  %191 = icmp eq i64 %190, 0
  %192 = bitcast i8* %185 to float*
  br i1 %191, label %193, label %198

193:                                              ; preds = %179
  %194 = load i64, i64* %6, align 8
  %195 = sub i64 %111, %194
  %196 = shl i64 %195, 1
  %197 = shl i64 %189, 1
  br label %658

198:                                              ; preds = %179
  %199 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %200 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %201 = load i64, i64* %6, align 8
  %202 = sub i64 %111, %201
  %203 = and i64 %202, 9223372036854775807
  %204 = icmp eq i64 %203, 0
  %205 = shl i64 %202, 1
  %206 = shl i64 %189, 1
  br label %686

207:                                              ; preds = %656, %141
  %208 = phi i32 [ %117, %141 ], [ %657, %656 ]
  %209 = phi i64 [ %113, %141 ], [ %654, %656 ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %142) #7
  %210 = load i8*, i8** %143, align 8
  %211 = load i64, i64* %144, align 8
  %212 = mul i64 %211, %209
  %213 = getelementptr inbounds i8, i8* %210, i64 %212
  %214 = ptrtoint i8* %213 to i64
  %215 = and i64 %214, 63
  %216 = icmp eq i64 %215, 0
  tail call void @llvm.assume(i1 %216) #7
  store i8* %213, i8** %145, align 8
  %217 = add i64 %146, %209
  %218 = add i64 %217, -2
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %155) #7
  %219 = icmp eq i64 %218, 0
  %220 = add i64 %217, -3
  %221 = select i1 %219, i64 0, i64 %220
  %222 = load i64, i64* %159, align 8
  %223 = mul i64 %222, %221
  %224 = mul i64 %222, %218
  %225 = add i64 %217, -1
  %226 = zext i32 %208 to i64
  %227 = icmp ult i64 %225, %226
  %228 = select i1 %227, i64 %225, i64 %218
  %229 = mul i64 %228, %222
  %230 = load i8*, i8** %163, align 8
  %231 = ptrtoint i8* %230 to i64
  %232 = and i64 %231, 63
  %233 = icmp eq i64 %232, 0
  tail call void @llvm.assume(i1 %233) #7
  %234 = getelementptr inbounds i8, i8* %230, i64 %223
  %235 = ptrtoint i8* %234 to i64
  %236 = and i64 %235, 63
  %237 = icmp eq i64 %236, 0
  tail call void @llvm.assume(i1 %237) #7
  store i8* %234, i8** %164, align 16
  %238 = getelementptr inbounds i8, i8* %230, i64 %224
  %239 = ptrtoint i8* %238 to i64
  %240 = and i64 %239, 63
  %241 = icmp eq i64 %240, 0
  tail call void @llvm.assume(i1 %241) #7
  store i8* %238, i8** %165, align 16
  %242 = getelementptr inbounds i8, i8* %230, i64 %229
  %243 = ptrtoint i8* %242 to i64
  %244 = and i64 %243, 63
  %245 = icmp eq i64 %244, 0
  tail call void @llvm.assume(i1 %245) #7
  store i8* %242, i8** %166, align 16
  %246 = load i8*, i8** %167, align 8
  %247 = ptrtoint i8* %246 to i64
  %248 = and i64 %247, 63
  %249 = icmp eq i64 %248, 0
  tail call void @llvm.assume(i1 %249) #7
  %250 = getelementptr inbounds i8, i8* %246, i64 %223
  %251 = ptrtoint i8* %250 to i64
  %252 = and i64 %251, 63
  %253 = icmp eq i64 %252, 0
  tail call void @llvm.assume(i1 %253) #7
  store i8* %250, i8** %168, align 8
  %254 = getelementptr inbounds i8, i8* %246, i64 %224
  %255 = ptrtoint i8* %254 to i64
  %256 = and i64 %255, 63
  %257 = icmp eq i64 %256, 0
  tail call void @llvm.assume(i1 %257) #7
  store i8* %254, i8** %169, align 8
  %258 = getelementptr inbounds i8, i8* %246, i64 %229
  %259 = ptrtoint i8* %258 to i64
  %260 = and i64 %259, 63
  %261 = icmp eq i64 %260, 0
  tail call void @llvm.assume(i1 %261) #7
  store i8* %258, i8** %170, align 8
  %262 = load i8*, i8** %171, align 8
  %263 = ptrtoint i8* %262 to i64
  %264 = and i64 %263, 63
  %265 = icmp eq i64 %264, 0
  tail call void @llvm.assume(i1 %265) #7
  %266 = getelementptr inbounds i8, i8* %262, i64 %223
  %267 = ptrtoint i8* %266 to i64
  %268 = and i64 %267, 63
  %269 = icmp eq i64 %268, 0
  tail call void @llvm.assume(i1 %269) #7
  store i8* %266, i8** %172, align 16
  %270 = getelementptr inbounds i8, i8* %262, i64 %224
  %271 = ptrtoint i8* %270 to i64
  %272 = and i64 %271, 63
  %273 = icmp eq i64 %272, 0
  tail call void @llvm.assume(i1 %273) #7
  store i8* %270, i8** %173, align 16
  %274 = getelementptr inbounds i8, i8* %262, i64 %229
  %275 = ptrtoint i8* %274 to i64
  %276 = and i64 %275, 63
  %277 = icmp eq i64 %276, 0
  tail call void @llvm.assume(i1 %277) #7
  store i8* %274, i8** %174, align 16
  %278 = bitcast i8* %238 to float*
  %279 = bitcast i8* %242 to float*
  %280 = bitcast i8* %234 to float*
  %281 = bitcast i8* %254 to float*
  %282 = bitcast i8* %258 to float*
  %283 = bitcast i8* %250 to float*
  %284 = bitcast i8* %270 to float*
  %285 = bitcast i8* %274 to float*
  %286 = bitcast i8* %266 to float*
  br i1 %162, label %287, label %289

287:                                              ; preds = %207
  %288 = load float*, float** %7, align 8
  br label %304

289:                                              ; preds = %304, %207
  %290 = phi i64 [ %127, %207 ], [ %407, %304 ]
  %291 = add i64 %290, 8
  %292 = icmp ugt i64 %291, %139
  br i1 %292, label %534, label %293

293:                                              ; preds = %289
  %294 = load float*, float** %7, align 8
  %295 = load float*, float** %152, align 16
  %296 = load float*, float** %148, align 16
  %297 = load float*, float** %156, align 16
  %298 = load float*, float** %153, align 8
  %299 = load float*, float** %149, align 8
  %300 = load float*, float** %157, align 8
  %301 = load float*, float** %154, align 16
  %302 = load float*, float** %150, align 16
  %303 = load float*, float** %158, align 16
  br label %410

304:                                              ; preds = %287, %304
  %305 = phi i64 [ %161, %287 ], [ %408, %304 ]
  %306 = phi i64 [ %127, %287 ], [ %407, %304 ]
  %307 = add nsw i64 %305, -2
  %308 = icmp eq i64 %307, 0
  %309 = add nuw nsw i64 %305, -3
  %310 = select i1 %308, i64 0, i64 %309
  %311 = add nsw i64 %305, -1
  %312 = load i32, i32* %130, align 8
  %313 = zext i32 %312 to i64
  %314 = icmp ult i64 %311, %313
  %315 = select i1 %314, i64 %311, i64 %307
  %316 = getelementptr inbounds float, float* %278, i64 %307
  %317 = load float, float* %316, align 4
  %318 = fmul float %317, 0x4011666660000000
  %319 = getelementptr inbounds float, float* %278, i64 %310
  %320 = load float, float* %319, align 4
  %321 = getelementptr inbounds float, float* %278, i64 %315
  %322 = load float, float* %321, align 4
  %323 = fadd float %320, %322
  %324 = getelementptr inbounds float, float* %279, i64 %310
  %325 = load float, float* %324, align 4
  %326 = fadd float %323, %325
  %327 = getelementptr inbounds float, float* %279, i64 %307
  %328 = load float, float* %327, align 4
  %329 = fadd float %326, %328
  %330 = getelementptr inbounds float, float* %279, i64 %315
  %331 = load float, float* %330, align 4
  %332 = fadd float %329, %331
  %333 = getelementptr inbounds float, float* %280, i64 %310
  %334 = load float, float* %333, align 4
  %335 = fadd float %332, %334
  %336 = getelementptr inbounds float, float* %280, i64 %307
  %337 = load float, float* %336, align 4
  %338 = fadd float %335, %337
  %339 = getelementptr inbounds float, float* %280, i64 %315
  %340 = load float, float* %339, align 4
  %341 = fadd float %338, %340
  %342 = fmul float %341, 0x3FE1666660000000
  %343 = fsub float %318, %342
  %344 = fmul float %343, %343
  %345 = fadd float %344, 0.000000e+00
  %346 = getelementptr inbounds float, float* %281, i64 %307
  %347 = load float, float* %346, align 4
  %348 = fmul float %347, 0x4011666660000000
  %349 = getelementptr inbounds float, float* %281, i64 %310
  %350 = load float, float* %349, align 4
  %351 = getelementptr inbounds float, float* %281, i64 %315
  %352 = load float, float* %351, align 4
  %353 = fadd float %350, %352
  %354 = getelementptr inbounds float, float* %282, i64 %310
  %355 = load float, float* %354, align 4
  %356 = fadd float %353, %355
  %357 = getelementptr inbounds float, float* %282, i64 %307
  %358 = load float, float* %357, align 4
  %359 = fadd float %356, %358
  %360 = getelementptr inbounds float, float* %282, i64 %315
  %361 = load float, float* %360, align 4
  %362 = fadd float %359, %361
  %363 = getelementptr inbounds float, float* %283, i64 %310
  %364 = load float, float* %363, align 4
  %365 = fadd float %362, %364
  %366 = getelementptr inbounds float, float* %283, i64 %307
  %367 = load float, float* %366, align 4
  %368 = fadd float %365, %367
  %369 = getelementptr inbounds float, float* %283, i64 %315
  %370 = load float, float* %369, align 4
  %371 = fadd float %368, %370
  %372 = fmul float %371, 0x3FE1666660000000
  %373 = fsub float %348, %372
  %374 = fmul float %373, %373
  %375 = fadd float %345, %374
  %376 = getelementptr inbounds float, float* %284, i64 %307
  %377 = load float, float* %376, align 4
  %378 = fmul float %377, 0x3FD25E3540000000
  %379 = getelementptr inbounds float, float* %284, i64 %310
  %380 = load float, float* %379, align 4
  %381 = getelementptr inbounds float, float* %284, i64 %315
  %382 = load float, float* %381, align 4
  %383 = fadd float %380, %382
  %384 = getelementptr inbounds float, float* %285, i64 %310
  %385 = load float, float* %384, align 4
  %386 = fadd float %383, %385
  %387 = getelementptr inbounds float, float* %285, i64 %307
  %388 = load float, float* %387, align 4
  %389 = fadd float %386, %388
  %390 = getelementptr inbounds float, float* %285, i64 %315
  %391 = load float, float* %390, align 4
  %392 = fadd float %389, %391
  %393 = getelementptr inbounds float, float* %286, i64 %310
  %394 = load float, float* %393, align 4
  %395 = fadd float %392, %394
  %396 = getelementptr inbounds float, float* %286, i64 %307
  %397 = load float, float* %396, align 4
  %398 = fadd float %395, %397
  %399 = getelementptr inbounds float, float* %286, i64 %315
  %400 = load float, float* %399, align 4
  %401 = fadd float %398, %400
  %402 = fmul float %401, 0x3FA25E3540000000
  %403 = fsub float %378, %402
  %404 = fmul float %403, %403
  %405 = fadd float %375, %404
  %406 = getelementptr inbounds float, float* %288, i64 %306
  store float %405, float* %406, align 4
  %407 = add nuw nsw i64 %306, 1
  %408 = add i64 %160, %407
  %409 = icmp ult i64 %408, 3
  br i1 %409, label %304, label %289

410:                                              ; preds = %293, %417
  %411 = phi i64 [ %291, %293 ], [ %532, %417 ]
  %412 = phi i64 [ %290, %293 ], [ %411, %417 ]
  %413 = add i64 %175, %411
  %414 = load i32, i32* %130, align 8
  %415 = zext i32 %414 to i64
  %416 = icmp ugt i64 %413, %415
  br i1 %416, label %534, label %417

417:                                              ; preds = %410
  %418 = add i64 %176, %412
  %419 = getelementptr inbounds float, float* %295, i64 %418
  %420 = bitcast float* %419 to <8 x float>*
  %421 = load <8 x float>, <8 x float>* %420, align 1, !alias.scope !57, !noalias !60
  %422 = fmul <8 x float> %421, <float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000>
  %423 = getelementptr inbounds float, float* %419, i64 -1
  %424 = bitcast float* %423 to <8 x float>*
  %425 = load <8 x float>, <8 x float>* %424, align 1, !alias.scope !62, !noalias !65
  %426 = getelementptr inbounds float, float* %419, i64 1
  %427 = bitcast float* %426 to <8 x float>*
  %428 = load <8 x float>, <8 x float>* %427, align 1, !alias.scope !67, !noalias !70
  %429 = getelementptr inbounds float, float* %296, i64 %418
  %430 = getelementptr inbounds float, float* %429, i64 -1
  %431 = bitcast float* %430 to <8 x float>*
  %432 = load <8 x float>, <8 x float>* %431, align 1, !alias.scope !72, !noalias !75
  %433 = bitcast float* %429 to <8 x float>*
  %434 = load <8 x float>, <8 x float>* %433, align 1, !alias.scope !77, !noalias !80
  %435 = getelementptr inbounds float, float* %429, i64 1
  %436 = bitcast float* %435 to <8 x float>*
  %437 = load <8 x float>, <8 x float>* %436, align 1, !alias.scope !82, !noalias !85
  %438 = fadd <8 x float> %425, %437
  %439 = getelementptr inbounds float, float* %297, i64 %418
  %440 = getelementptr inbounds float, float* %439, i64 -1
  %441 = bitcast float* %440 to <8 x float>*
  %442 = load <8 x float>, <8 x float>* %441, align 1, !alias.scope !87, !noalias !90
  %443 = fadd <8 x float> %428, %442
  %444 = bitcast float* %439 to <8 x float>*
  %445 = load <8 x float>, <8 x float>* %444, align 1, !alias.scope !92, !noalias !95
  %446 = fadd <8 x float> %432, %445
  %447 = getelementptr inbounds float, float* %439, i64 1
  %448 = bitcast float* %447 to <8 x float>*
  %449 = load <8 x float>, <8 x float>* %448, align 1, !alias.scope !97, !noalias !100
  %450 = fadd <8 x float> %434, %449
  %451 = fadd <8 x float> %438, %443
  %452 = fadd <8 x float> %446, %450
  %453 = fadd <8 x float> %451, %452
  %454 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %453, <8 x float> <float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000>, <8 x float> %422) #7
  %455 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %454, <8 x float> %454, <8 x float> zeroinitializer) #7
  %456 = getelementptr inbounds float, float* %298, i64 %418
  %457 = bitcast float* %456 to <8 x float>*
  %458 = load <8 x float>, <8 x float>* %457, align 1, !alias.scope !57, !noalias !60
  %459 = fmul <8 x float> %458, <float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000>
  %460 = getelementptr inbounds float, float* %456, i64 -1
  %461 = bitcast float* %460 to <8 x float>*
  %462 = load <8 x float>, <8 x float>* %461, align 1, !alias.scope !62, !noalias !65
  %463 = getelementptr inbounds float, float* %456, i64 1
  %464 = bitcast float* %463 to <8 x float>*
  %465 = load <8 x float>, <8 x float>* %464, align 1, !alias.scope !67, !noalias !70
  %466 = getelementptr inbounds float, float* %299, i64 %418
  %467 = getelementptr inbounds float, float* %466, i64 -1
  %468 = bitcast float* %467 to <8 x float>*
  %469 = load <8 x float>, <8 x float>* %468, align 1, !alias.scope !72, !noalias !75
  %470 = bitcast float* %466 to <8 x float>*
  %471 = load <8 x float>, <8 x float>* %470, align 1, !alias.scope !77, !noalias !80
  %472 = getelementptr inbounds float, float* %466, i64 1
  %473 = bitcast float* %472 to <8 x float>*
  %474 = load <8 x float>, <8 x float>* %473, align 1, !alias.scope !82, !noalias !85
  %475 = fadd <8 x float> %462, %474
  %476 = getelementptr inbounds float, float* %300, i64 %418
  %477 = getelementptr inbounds float, float* %476, i64 -1
  %478 = bitcast float* %477 to <8 x float>*
  %479 = load <8 x float>, <8 x float>* %478, align 1, !alias.scope !87, !noalias !90
  %480 = fadd <8 x float> %465, %479
  %481 = bitcast float* %476 to <8 x float>*
  %482 = load <8 x float>, <8 x float>* %481, align 1, !alias.scope !92, !noalias !95
  %483 = fadd <8 x float> %469, %482
  %484 = getelementptr inbounds float, float* %476, i64 1
  %485 = bitcast float* %484 to <8 x float>*
  %486 = load <8 x float>, <8 x float>* %485, align 1, !alias.scope !97, !noalias !100
  %487 = fadd <8 x float> %471, %486
  %488 = fadd <8 x float> %475, %480
  %489 = fadd <8 x float> %483, %487
  %490 = fadd <8 x float> %488, %489
  %491 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %490, <8 x float> <float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000>, <8 x float> %459) #7
  %492 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %491, <8 x float> %491, <8 x float> %455) #7
  %493 = getelementptr inbounds float, float* %301, i64 %418
  %494 = bitcast float* %493 to <8 x float>*
  %495 = load <8 x float>, <8 x float>* %494, align 1, !alias.scope !57, !noalias !60
  %496 = fmul <8 x float> %495, <float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000>
  %497 = getelementptr inbounds float, float* %493, i64 -1
  %498 = bitcast float* %497 to <8 x float>*
  %499 = load <8 x float>, <8 x float>* %498, align 1, !alias.scope !62, !noalias !65
  %500 = getelementptr inbounds float, float* %493, i64 1
  %501 = bitcast float* %500 to <8 x float>*
  %502 = load <8 x float>, <8 x float>* %501, align 1, !alias.scope !67, !noalias !70
  %503 = getelementptr inbounds float, float* %302, i64 %418
  %504 = getelementptr inbounds float, float* %503, i64 -1
  %505 = bitcast float* %504 to <8 x float>*
  %506 = load <8 x float>, <8 x float>* %505, align 1, !alias.scope !72, !noalias !75
  %507 = bitcast float* %503 to <8 x float>*
  %508 = load <8 x float>, <8 x float>* %507, align 1, !alias.scope !77, !noalias !80
  %509 = getelementptr inbounds float, float* %503, i64 1
  %510 = bitcast float* %509 to <8 x float>*
  %511 = load <8 x float>, <8 x float>* %510, align 1, !alias.scope !82, !noalias !85
  %512 = fadd <8 x float> %499, %511
  %513 = getelementptr inbounds float, float* %303, i64 %418
  %514 = getelementptr inbounds float, float* %513, i64 -1
  %515 = bitcast float* %514 to <8 x float>*
  %516 = load <8 x float>, <8 x float>* %515, align 1, !alias.scope !87, !noalias !90
  %517 = fadd <8 x float> %502, %516
  %518 = bitcast float* %513 to <8 x float>*
  %519 = load <8 x float>, <8 x float>* %518, align 1, !alias.scope !92, !noalias !95
  %520 = fadd <8 x float> %506, %519
  %521 = getelementptr inbounds float, float* %513, i64 1
  %522 = bitcast float* %521 to <8 x float>*
  %523 = load <8 x float>, <8 x float>* %522, align 1, !alias.scope !97, !noalias !100
  %524 = fadd <8 x float> %508, %523
  %525 = fadd <8 x float> %512, %517
  %526 = fadd <8 x float> %520, %524
  %527 = fadd <8 x float> %525, %526
  %528 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %527, <8 x float> <float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000>, <8 x float> %496) #7
  %529 = tail call <8 x float> @llvm.fma.v8f32(<8 x float> %528, <8 x float> %528, <8 x float> %492) #7
  %530 = getelementptr inbounds float, float* %294, i64 %412
  %531 = bitcast float* %530 to <8 x float>*
  store <8 x float> %529, <8 x float>* %531, align 1, !alias.scope !102
  %532 = add i64 %411, 8
  %533 = icmp ugt i64 %532, %139
  br i1 %533, label %534, label %410

534:                                              ; preds = %417, %410, %289
  %535 = phi i64 [ %290, %289 ], [ %412, %410 ], [ %411, %417 ]
  %536 = icmp ult i64 %535, %139
  br i1 %536, label %537, label %653

537:                                              ; preds = %534
  %538 = load float*, float** %152, align 16
  %539 = load float*, float** %156, align 16
  %540 = load float*, float** %148, align 16
  %541 = load float*, float** %153, align 8
  %542 = load float*, float** %157, align 8
  %543 = load float*, float** %149, align 8
  %544 = load float*, float** %154, align 16
  %545 = load float*, float** %158, align 16
  %546 = load float*, float** %150, align 16
  %547 = load float*, float** %7, align 8
  br label %548

548:                                              ; preds = %537, %548
  %549 = phi i64 [ %535, %537 ], [ %651, %548 ]
  %550 = add i64 %160, %549
  %551 = add i64 %550, -2
  %552 = icmp eq i64 %551, 0
  %553 = add i64 %550, -3
  %554 = select i1 %552, i64 0, i64 %553
  %555 = add i64 %550, -1
  %556 = load i32, i32* %130, align 8
  %557 = zext i32 %556 to i64
  %558 = icmp ult i64 %555, %557
  %559 = select i1 %558, i64 %555, i64 %551
  %560 = getelementptr inbounds float, float* %538, i64 %551
  %561 = load float, float* %560, align 4
  %562 = fmul float %561, 0x4011666660000000
  %563 = getelementptr inbounds float, float* %538, i64 %554
  %564 = load float, float* %563, align 4
  %565 = getelementptr inbounds float, float* %538, i64 %559
  %566 = load float, float* %565, align 4
  %567 = fadd float %564, %566
  %568 = getelementptr inbounds float, float* %539, i64 %554
  %569 = load float, float* %568, align 4
  %570 = fadd float %567, %569
  %571 = getelementptr inbounds float, float* %539, i64 %551
  %572 = load float, float* %571, align 4
  %573 = fadd float %570, %572
  %574 = getelementptr inbounds float, float* %539, i64 %559
  %575 = load float, float* %574, align 4
  %576 = fadd float %573, %575
  %577 = getelementptr inbounds float, float* %540, i64 %554
  %578 = load float, float* %577, align 4
  %579 = fadd float %576, %578
  %580 = getelementptr inbounds float, float* %540, i64 %551
  %581 = load float, float* %580, align 4
  %582 = fadd float %579, %581
  %583 = getelementptr inbounds float, float* %540, i64 %559
  %584 = load float, float* %583, align 4
  %585 = fadd float %582, %584
  %586 = fmul float %585, 0x3FE1666660000000
  %587 = fsub float %562, %586
  %588 = fmul float %587, %587
  %589 = fadd float %588, 0.000000e+00
  %590 = getelementptr inbounds float, float* %541, i64 %551
  %591 = load float, float* %590, align 4
  %592 = fmul float %591, 0x4011666660000000
  %593 = getelementptr inbounds float, float* %541, i64 %554
  %594 = load float, float* %593, align 4
  %595 = getelementptr inbounds float, float* %541, i64 %559
  %596 = load float, float* %595, align 4
  %597 = fadd float %594, %596
  %598 = getelementptr inbounds float, float* %542, i64 %554
  %599 = load float, float* %598, align 4
  %600 = fadd float %597, %599
  %601 = getelementptr inbounds float, float* %542, i64 %551
  %602 = load float, float* %601, align 4
  %603 = fadd float %600, %602
  %604 = getelementptr inbounds float, float* %542, i64 %559
  %605 = load float, float* %604, align 4
  %606 = fadd float %603, %605
  %607 = getelementptr inbounds float, float* %543, i64 %554
  %608 = load float, float* %607, align 4
  %609 = fadd float %606, %608
  %610 = getelementptr inbounds float, float* %543, i64 %551
  %611 = load float, float* %610, align 4
  %612 = fadd float %609, %611
  %613 = getelementptr inbounds float, float* %543, i64 %559
  %614 = load float, float* %613, align 4
  %615 = fadd float %612, %614
  %616 = fmul float %615, 0x3FE1666660000000
  %617 = fsub float %592, %616
  %618 = fmul float %617, %617
  %619 = fadd float %589, %618
  %620 = getelementptr inbounds float, float* %544, i64 %551
  %621 = load float, float* %620, align 4
  %622 = fmul float %621, 0x3FD25E3540000000
  %623 = getelementptr inbounds float, float* %544, i64 %554
  %624 = load float, float* %623, align 4
  %625 = getelementptr inbounds float, float* %544, i64 %559
  %626 = load float, float* %625, align 4
  %627 = fadd float %624, %626
  %628 = getelementptr inbounds float, float* %545, i64 %554
  %629 = load float, float* %628, align 4
  %630 = fadd float %627, %629
  %631 = getelementptr inbounds float, float* %545, i64 %551
  %632 = load float, float* %631, align 4
  %633 = fadd float %630, %632
  %634 = getelementptr inbounds float, float* %545, i64 %559
  %635 = load float, float* %634, align 4
  %636 = fadd float %633, %635
  %637 = getelementptr inbounds float, float* %546, i64 %554
  %638 = load float, float* %637, align 4
  %639 = fadd float %636, %638
  %640 = getelementptr inbounds float, float* %546, i64 %551
  %641 = load float, float* %640, align 4
  %642 = fadd float %639, %641
  %643 = getelementptr inbounds float, float* %546, i64 %559
  %644 = load float, float* %643, align 4
  %645 = fadd float %642, %644
  %646 = fmul float %645, 0x3FA25E3540000000
  %647 = fsub float %622, %646
  %648 = fmul float %647, %647
  %649 = fadd float %619, %648
  %650 = getelementptr inbounds float, float* %547, i64 %549
  store float %649, float* %650, align 4
  %651 = add nuw i64 %549, 1
  %652 = icmp ult i64 %651, %139
  br i1 %652, label %548, label %653

653:                                              ; preds = %548, %534
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %155) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %142) #7
  %654 = add nuw i64 %209, 1
  %655 = icmp ult i64 %654, %125
  br i1 %655, label %656, label %177

656:                                              ; preds = %653
  %657 = load i32, i32* %116, align 4
  br label %207

658:                                              ; preds = %755, %193
  %659 = phi i64 [ %197, %193 ], [ %206, %755 ]
  %660 = phi i64 [ %196, %193 ], [ %205, %755 ]
  %661 = phi i64 [ %194, %193 ], [ %201, %755 ]
  %662 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 4
  %663 = load i64, i64* %662, align 8
  %664 = lshr i64 %663, 2
  %665 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %666 = load i8*, i8** %665, align 8
  %667 = ptrtoint i8* %666 to i64
  %668 = and i64 %667, 63
  %669 = icmp eq i64 %668, 0
  tail call void @llvm.assume(i1 %669) #7
  %670 = bitcast [4 x float*]* %11 to i8*
  %671 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 1
  %672 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 2
  %673 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 3
  %674 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %675 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %676 = bitcast i8* %666 to float*
  %677 = or i64 %660, 1
  %678 = or i64 %659, 1
  %679 = bitcast [4 x float*]* %11 to i8**
  %680 = bitcast float** %671 to i8**
  %681 = bitcast float** %672 to i8**
  %682 = bitcast float** %673 to i8**
  %683 = shl i64 %180, 3
  %684 = shl i64 %661, 3
  %685 = sub i64 2, %684
  br label %785

686:                                              ; preds = %198, %755
  %687 = phi i64 [ 0, %198 ], [ %756, %755 ]
  %688 = shl i64 %687, 2
  %689 = or i64 %688, 2
  %690 = load i8*, i8** %199, align 8
  %691 = load i64, i64* %200, align 8
  %692 = mul i64 %691, %689
  %693 = getelementptr inbounds i8, i8* %690, i64 %692
  %694 = ptrtoint i8* %693 to i64
  %695 = and i64 %694, 63
  %696 = icmp eq i64 %695, 0
  tail call void @llvm.assume(i1 %696) #7
  %697 = or i64 %688, 3
  %698 = mul i64 %691, %697
  %699 = getelementptr inbounds i8, i8* %690, i64 %698
  %700 = ptrtoint i8* %699 to i64
  %701 = and i64 %700, 63
  %702 = icmp eq i64 %701, 0
  tail call void @llvm.assume(i1 %702) #7
  %703 = add i64 %689, 2
  %704 = mul i64 %691, %703
  %705 = getelementptr inbounds i8, i8* %690, i64 %704
  %706 = ptrtoint i8* %705 to i64
  %707 = and i64 %706, 63
  %708 = icmp eq i64 %707, 0
  tail call void @llvm.assume(i1 %708) #7
  %709 = add i64 %689, 3
  %710 = mul i64 %691, %709
  %711 = getelementptr inbounds i8, i8* %690, i64 %710
  %712 = ptrtoint i8* %711 to i64
  %713 = and i64 %712, 63
  %714 = icmp eq i64 %713, 0
  tail call void @llvm.assume(i1 %714) #7
  %715 = mul i64 %183, %687
  %716 = getelementptr inbounds float, float* %192, i64 %715
  br i1 %204, label %755, label %717

717:                                              ; preds = %686
  %718 = getelementptr inbounds i8, i8* %693, i64 8
  %719 = bitcast i8* %718 to float*
  %720 = getelementptr inbounds i8, i8* %699, i64 8
  %721 = bitcast i8* %720 to float*
  %722 = getelementptr inbounds i8, i8* %705, i64 8
  %723 = bitcast i8* %722 to float*
  %724 = getelementptr inbounds i8, i8* %711, i64 8
  %725 = bitcast i8* %724 to float*
  br label %726

726:                                              ; preds = %717, %726
  %727 = phi i64 [ %753, %726 ], [ 0, %717 ]
  %728 = shl i64 %727, 2
  %729 = getelementptr inbounds float, float* %719, i64 %728
  %730 = bitcast float* %729 to <4 x float>*
  %731 = load <4 x float>, <4 x float>* %730, align 8, !alias.scope !105
  %732 = fadd <4 x float> %731, zeroinitializer
  %733 = getelementptr inbounds float, float* %721, i64 %728
  %734 = bitcast float* %733 to <4 x float>*
  %735 = load <4 x float>, <4 x float>* %734, align 8, !alias.scope !105
  %736 = fadd <4 x float> %732, %735
  %737 = getelementptr inbounds float, float* %723, i64 %728
  %738 = bitcast float* %737 to <4 x float>*
  %739 = load <4 x float>, <4 x float>* %738, align 8, !alias.scope !105
  %740 = fadd <4 x float> %736, %739
  %741 = getelementptr inbounds float, float* %725, i64 %728
  %742 = bitcast float* %741 to <4 x float>*
  %743 = load <4 x float>, <4 x float>* %742, align 8, !alias.scope !105
  %744 = fadd <4 x float> %740, %743
  %745 = shufflevector <4 x float> %744, <4 x float> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %746 = fadd <4 x float> %744, %745
  %747 = shufflevector <4 x float> %746, <4 x float> undef, <4 x i32> <i32 1, i32 2, i32 3, i32 0>
  %748 = fadd <4 x float> %746, %747
  %749 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %748) #7
  %750 = extractelement <4 x float> %749, i32 0
  %751 = fmul float %750, 2.500000e-01
  %752 = getelementptr inbounds float, float* %716, i64 %727
  store float %751, float* %752, align 4
  %753 = add nuw i64 %727, 1
  %754 = icmp ult i64 %753, %205
  br i1 %754, label %726, label %755

755:                                              ; preds = %726, %686
  %756 = add nuw i64 %687, 1
  %757 = icmp ult i64 %756, %206
  br i1 %757, label %686, label %658

758:                                              ; preds = %836
  %759 = bitcast i64* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %759) #7
  store i64 %180, i64* %12, align 8
  %760 = icmp ugt i64 %105, %180
  br i1 %760, label %761, label %914

761:                                              ; preds = %758
  %762 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %763 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 4
  %764 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %765 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %766 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 4
  %767 = bitcast i64* %13 to i8*
  %768 = icmp ult i64 %661, %111
  %769 = bitcast float* %14 to i8*
  %770 = bitcast float* %15 to i8*
  %771 = bitcast float* %16 to i8*
  %772 = bitcast float* %17 to i8*
  %773 = bitcast i32* %18 to i8*
  %774 = bitcast float* %19 to i8*
  %775 = bitcast i32* %18 to float*
  %776 = bitcast float* %20 to i8*
  %777 = bitcast float* %21 to i8*
  %778 = bitcast float* %22 to i8*
  %779 = bitcast float* %23 to i8*
  %780 = bitcast float* %24 to i8*
  %781 = bitcast float* %25 to i8*
  %782 = bitcast float* %26 to i8*
  %783 = bitcast float* %27 to i8*
  %784 = load i64, i64* %12, align 8
  br label %915

785:                                              ; preds = %836, %658
  %786 = phi i64 [ 0, %658 ], [ %837, %836 ]
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %670) #7
  %787 = shl i64 %786, 2
  %788 = load i8*, i8** %674, align 8
  %789 = load i64, i64* %675, align 8
  %790 = mul i64 %789, %787
  %791 = getelementptr inbounds i8, i8* %788, i64 %790
  %792 = ptrtoint i8* %791 to i64
  %793 = and i64 %792, 63
  %794 = icmp eq i64 %793, 0
  tail call void @llvm.assume(i1 %794) #7
  store i8* %791, i8** %679, align 16
  %795 = or i64 %787, 1
  %796 = mul i64 %789, %795
  %797 = getelementptr inbounds i8, i8* %788, i64 %796
  %798 = ptrtoint i8* %797 to i64
  %799 = and i64 %798, 63
  %800 = icmp eq i64 %799, 0
  tail call void @llvm.assume(i1 %800) #7
  store i8* %797, i8** %680, align 8
  %801 = or i64 %787, 2
  %802 = mul i64 %789, %801
  %803 = getelementptr inbounds i8, i8* %788, i64 %802
  %804 = ptrtoint i8* %803 to i64
  %805 = and i64 %804, 63
  %806 = icmp eq i64 %805, 0
  tail call void @llvm.assume(i1 %806) #7
  store i8* %803, i8** %681, align 16
  %807 = or i64 %787, 3
  %808 = mul i64 %789, %807
  %809 = getelementptr inbounds i8, i8* %788, i64 %808
  %810 = ptrtoint i8* %809 to i64
  %811 = and i64 %810, 63
  %812 = icmp eq i64 %811, 0
  tail call void @llvm.assume(i1 %812) #7
  store i8* %809, i8** %682, align 8
  %813 = mul i64 %664, %786
  %814 = getelementptr inbounds float, float* %676, i64 %813
  %815 = add i64 %683, %787
  %816 = icmp eq i64 %815, 0
  %817 = select i1 %816, i64 2, i64 0
  %818 = add i64 %815, 4
  %819 = load i32, i32* %116, align 4
  %820 = zext i32 %819 to i64
  %821 = add nuw nsw i64 %820, 2
  %822 = icmp ugt i64 %818, %821
  %823 = bitcast i8* %791 to float*
  %824 = bitcast i8* %797 to float*
  %825 = bitcast i8* %803 to float*
  %826 = bitcast i8* %809 to float*
  br i1 %822, label %827, label %831

827:                                              ; preds = %785
  %828 = sub i64 2, %787
  %829 = sub i64 %828, %683
  %830 = add i64 %829, %820
  br label %831

831:                                              ; preds = %785, %827
  %832 = phi i64 [ %830, %827 ], [ 4, %785 ]
  %833 = sub i64 %832, %817
  %834 = icmp eq i64 %833, 4
  %835 = icmp ugt i64 %832, %817
  br label %839

836:                                              ; preds = %908
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %670) #7
  %837 = add nuw i64 %786, 1
  %838 = icmp eq i64 %837, %678
  br i1 %838, label %758, label %785

839:                                              ; preds = %908, %831
  %840 = phi i64 [ 0, %831 ], [ %911, %908 ]
  %841 = shl i64 %840, 2
  %842 = add i64 %684, %841
  %843 = icmp eq i64 %842, 0
  %844 = or i64 %841, 2
  %845 = select i1 %843, i64 %844, i64 %841
  %846 = add i64 %842, 4
  %847 = load i32, i32* %130, align 8
  %848 = zext i32 %847 to i64
  %849 = add nuw nsw i64 %848, 2
  %850 = icmp ugt i64 %846, %849
  %851 = add i64 %841, 4
  %852 = add i64 %685, %848
  %853 = select i1 %850, i64 %852, i64 %851
  %854 = sub i64 %853, %845
  %855 = icmp eq i64 %854, 4
  %856 = and i1 %834, %855
  br i1 %856, label %857, label %881

857:                                              ; preds = %839
  %858 = getelementptr inbounds float, float* %823, i64 %845
  %859 = bitcast float* %858 to <4 x float>*
  %860 = load <4 x float>, <4 x float>* %859, align 16, !alias.scope !108
  %861 = fadd <4 x float> %860, zeroinitializer
  %862 = getelementptr inbounds float, float* %824, i64 %845
  %863 = bitcast float* %862 to <4 x float>*
  %864 = load <4 x float>, <4 x float>* %863, align 16, !alias.scope !108
  %865 = fadd <4 x float> %861, %864
  %866 = getelementptr inbounds float, float* %825, i64 %845
  %867 = bitcast float* %866 to <4 x float>*
  %868 = load <4 x float>, <4 x float>* %867, align 16, !alias.scope !108
  %869 = fadd <4 x float> %865, %868
  %870 = getelementptr inbounds float, float* %826, i64 %845
  %871 = bitcast float* %870 to <4 x float>*
  %872 = load <4 x float>, <4 x float>* %871, align 16, !alias.scope !108
  %873 = fadd <4 x float> %869, %872
  %874 = shufflevector <4 x float> %873, <4 x float> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %875 = fadd <4 x float> %873, %874
  %876 = shufflevector <4 x float> %875, <4 x float> undef, <4 x i32> <i32 1, i32 2, i32 3, i32 0>
  %877 = fadd <4 x float> %875, %876
  %878 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %877) #7
  %879 = extractelement <4 x float> %878, i32 0
  %880 = fmul float %879, 2.500000e-01
  br label %908

881:                                              ; preds = %839
  br i1 %835, label %882, label %890

882:                                              ; preds = %881
  %883 = icmp ugt i64 %853, %845
  br label %884

884:                                              ; preds = %882, %896
  %885 = phi i64 [ %817, %882 ], [ %898, %896 ]
  %886 = phi float [ 0.000000e+00, %882 ], [ %897, %896 ]
  br i1 %883, label %887, label %896

887:                                              ; preds = %884
  %888 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 %885
  %889 = load float*, float** %888, align 8
  br label %900

890:                                              ; preds = %896, %881
  %891 = phi float [ 0.000000e+00, %881 ], [ %897, %896 ]
  %892 = mul i64 %854, %833
  %893 = uitofp i64 %892 to float
  %894 = fdiv float %891, %893
  %895 = tail call float @sqrtf(float %894) #7
  br label %908

896:                                              ; preds = %900, %884
  %897 = phi float [ %886, %884 ], [ %905, %900 ]
  %898 = add nuw i64 %885, 1
  %899 = icmp ult i64 %898, %832
  br i1 %899, label %884, label %890

900:                                              ; preds = %887, %900
  %901 = phi i64 [ %845, %887 ], [ %906, %900 ]
  %902 = phi float [ %886, %887 ], [ %905, %900 ]
  %903 = getelementptr inbounds float, float* %889, i64 %901
  %904 = load float, float* %903, align 4
  %905 = fadd float %902, %904
  %906 = add nuw i64 %901, 1
  %907 = icmp ult i64 %906, %853
  br i1 %907, label %900, label %896

908:                                              ; preds = %890, %857
  %909 = phi float [ %895, %890 ], [ %880, %857 ]
  %910 = getelementptr inbounds float, float* %814, i64 %840
  store float %909, float* %910, align 4
  %911 = add nuw i64 %840, 1
  %912 = icmp eq i64 %911, %677
  br i1 %912, label %836, label %839

913:                                              ; preds = %945
  store i64 %946, i64* %12, align 8
  br label %914

914:                                              ; preds = %913, %758
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %759) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %106) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %100) #7
  br label %1168

915:                                              ; preds = %761, %945
  %916 = phi i64 [ %784, %761 ], [ %946, %945 ]
  %917 = phi i64 [ %180, %761 ], [ %946, %945 ]
  %918 = load i8*, i8** %762, align 8
  %919 = load i64, i64* %763, align 8
  %920 = mul i64 %919, %917
  %921 = getelementptr inbounds i8, i8* %918, i64 %920
  %922 = ptrtoint i8* %921 to i64
  %923 = and i64 %922, 63
  %924 = icmp eq i64 %923, 0
  tail call void @llvm.assume(i1 %924) #7
  %925 = load i8*, i8** %764, align 8
  %926 = load i64, i64* %98, align 8
  %927 = mul i64 %926, %917
  %928 = getelementptr inbounds i8, i8* %925, i64 %927
  %929 = ptrtoint i8* %928 to i64
  %930 = and i64 %929, 63
  %931 = icmp eq i64 %930, 0
  tail call void @llvm.assume(i1 %931) #7
  %932 = load i8*, i8** %765, align 8
  %933 = load i64, i64* %766, align 8
  %934 = mul i64 %933, %917
  %935 = getelementptr inbounds i8, i8* %932, i64 %934
  %936 = ptrtoint i8* %935 to i64
  %937 = and i64 %936, 63
  %938 = icmp eq i64 %937, 0
  tail call void @llvm.assume(i1 %938) #7
  %939 = bitcast i8* %935 to float*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %767) #7
  store i64 %661, i64* %13, align 8
  br i1 %768, label %940, label %945

940:                                              ; preds = %915
  %941 = sub i64 %917, %180
  %942 = shl i64 %941, 1
  %943 = load i64, i64* %13, align 8
  br label %948

944:                                              ; preds = %1151
  store i64 %1152, i64* %13, align 8
  br label %945

945:                                              ; preds = %944, %915
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %767) #7
  %946 = add i64 %916, 1
  %947 = icmp ult i64 %946, %105
  br i1 %947, label %915, label %913

948:                                              ; preds = %940, %1151
  %949 = phi i64 [ %943, %940 ], [ %1152, %1151 ]
  %950 = phi i64 [ %661, %940 ], [ %1152, %1151 ]
  %951 = getelementptr inbounds i8, i8* %921, i64 %950
  %952 = load i8, i8* %951, align 1
  %953 = and i8 %952, 1
  %954 = icmp eq i8 %953, 0
  br i1 %954, label %1151, label %955

955:                                              ; preds = %948
  %956 = lshr i8 %952, 1
  %957 = getelementptr inbounds float, float* %939, i64 %950
  %958 = load float, float* %957, align 4
  %959 = fdiv float 1.000000e+00, %958
  %960 = zext i8 %956 to i64
  %961 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut, i64 0, i64 %960
  %962 = load i8, i8* %961, align 1
  %963 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %960
  %964 = sub i64 %950, %661
  %965 = shl i64 %964, 1
  %966 = zext i8 %962 to i64
  %967 = shl nuw nsw i64 %966, 1
  %968 = load i8, i8* %963, align 1
  %969 = zext i8 %968 to i64
  %970 = shl nuw nsw i64 %969, 1
  br label %971

971:                                              ; preds = %993, %955
  %972 = phi i64 [ 0, %955 ], [ %994, %993 ]
  %973 = phi float [ 0.000000e+00, %955 ], [ %1004, %993 ]
  %974 = add i64 %942, %972
  %975 = mul i64 %974, %183
  br label %996

976:                                              ; preds = %993
  %977 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %960
  %978 = load i8, i8* %977, align 1
  %979 = zext i8 %978 to i64
  %980 = shl nuw nsw i64 %966, 2
  %981 = mul nuw nsw i64 %980, %979
  %982 = uitofp i64 %981 to float
  %983 = fdiv float %1004, %982
  %984 = tail call float @sqrtf(float %983) #7
  %985 = sub i64 %950, %661
  %986 = shl i64 %985, 1
  %987 = fmul float %959, 6.250000e-02
  %988 = fpext float %984 to double
  %989 = fpext float %987 to double
  %990 = fmul double %989, 0x400A000006666666
  %991 = fadd double %990, %988
  %992 = fmul float %987, 0x3FB5C28F60000000
  br label %1007

993:                                              ; preds = %996
  %994 = add nuw nsw i64 %972, 1
  %995 = icmp ult i64 %994, %967
  br i1 %995, label %971, label %976

996:                                              ; preds = %971, %996
  %997 = phi i64 [ 0, %971 ], [ %1005, %996 ]
  %998 = phi float [ %973, %971 ], [ %1004, %996 ]
  %999 = add i64 %975, %997
  %1000 = add i64 %999, %965
  %1001 = getelementptr inbounds float, float* %192, i64 %1000
  %1002 = load float, float* %1001, align 4
  %1003 = fmul float %1002, %1002
  %1004 = fadd float %998, %1003
  %1005 = add nuw nsw i64 %997, 1
  %1006 = icmp ult i64 %1005, %970
  br i1 %1006, label %996, label %993

1007:                                             ; preds = %976, %1020
  %1008 = phi i64 [ 0, %976 ], [ %1021, %1020 ]
  %1009 = shl nuw i64 %1008, 1
  %1010 = add i64 %942, %1009
  %1011 = mul i64 %1010, %183
  %1012 = or i64 %1009, 1
  %1013 = add i64 %942, %1012
  %1014 = mul i64 %1013, %183
  %1015 = mul i64 %664, %1013
  %1016 = mul i64 %664, %1010
  %1017 = add i64 %1010, 2
  %1018 = mul i64 %664, %1017
  %1019 = mul i64 %1008, %99
  br label %1023

1020:                                             ; preds = %1023
  %1021 = add nuw nsw i64 %1008, 1
  %1022 = icmp eq i64 %1021, %966
  br i1 %1022, label %1151, label %1007

1023:                                             ; preds = %1007, %1023
  %1024 = phi i64 [ 0, %1007 ], [ %1149, %1023 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %769)
  %1025 = shl nuw i64 %1024, 1
  %1026 = add i64 %986, %1025
  %1027 = add i64 %1026, %1011
  %1028 = getelementptr inbounds float, float* %192, i64 %1027
  %1029 = load float, float* %1028, align 8
  store float %1029, float* %14, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %770)
  %1030 = or i64 %1025, 1
  %1031 = add i64 %986, %1030
  %1032 = add i64 %1031, %1011
  %1033 = getelementptr inbounds float, float* %192, i64 %1032
  %1034 = load float, float* %1033, align 4
  store float %1034, float* %15, align 4
  %1035 = fcmp olt float %1034, %1029
  %1036 = select i1 %1035, float* %15, float* %14
  %1037 = bitcast float* %1036 to i32*
  %1038 = load i32, i32* %1037, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %770)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %769)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %771)
  %1039 = add i64 %1026, %1014
  %1040 = getelementptr inbounds float, float* %192, i64 %1039
  %1041 = load float, float* %1040, align 4
  store float %1041, float* %16, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %772)
  %1042 = add i64 %1031, %1014
  %1043 = getelementptr inbounds float, float* %192, i64 %1042
  %1044 = load float, float* %1043, align 4
  store float %1044, float* %17, align 4
  %1045 = fcmp olt float %1044, %1041
  %1046 = select i1 %1045, float* %17, float* %16
  %1047 = bitcast float* %1046 to i32*
  %1048 = load i32, i32* %1047, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %772)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %771)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %773)
  %1049 = bitcast i32 %1048 to float
  %1050 = bitcast i32 %1038 to float
  %1051 = fcmp olt float %1049, %1050
  %1052 = select i1 %1051, i32 %1048, i32 %1038
  store i32 %1052, i32* %18, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %774)
  %1053 = add i64 %1031, %1015
  %1054 = getelementptr inbounds float, float* %676, i64 %1053
  %1055 = load float, float* %1054, align 4
  store float %1055, float* %19, align 4
  %1056 = bitcast i32 %1052 to float
  %1057 = fcmp olt float %1055, %1056
  %1058 = select i1 %1057, float* %19, float* %775
  %1059 = bitcast float* %1058 to i32*
  %1060 = load i32, i32* %1059, align 4
  store i32 %1060, i32* %18, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %774)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %776)
  %1061 = add i64 %1026, %1016
  %1062 = getelementptr inbounds float, float* %676, i64 %1061
  %1063 = load float, float* %1062, align 8
  store float %1063, float* %20, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %777)
  %1064 = add i64 %1031, %1016
  %1065 = getelementptr inbounds float, float* %676, i64 %1064
  %1066 = load float, float* %1065, align 4
  store float %1066, float* %21, align 4
  %1067 = fcmp olt float %1066, %1063
  %1068 = select i1 %1067, float* %21, float* %20
  %1069 = bitcast float* %1068 to i32*
  %1070 = load i32, i32* %1069, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %777)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %776)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %778)
  %1071 = add nuw nsw i64 %1025, 2
  %1072 = add i64 %986, %1071
  %1073 = add i64 %1072, %1016
  %1074 = getelementptr inbounds float, float* %676, i64 %1073
  %1075 = load float, float* %1074, align 8
  store float %1075, float* %22, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %779)
  %1076 = add i64 %1026, %1015
  %1077 = getelementptr inbounds float, float* %676, i64 %1076
  %1078 = load float, float* %1077, align 4
  store float %1078, float* %23, align 4
  %1079 = fcmp olt float %1078, %1075
  %1080 = select i1 %1079, float* %23, float* %22
  %1081 = bitcast float* %1080 to i32*
  %1082 = load i32, i32* %1081, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %779)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %778)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %780)
  store float %1055, float* %24, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %781)
  %1083 = add i64 %1072, %1015
  %1084 = getelementptr inbounds float, float* %676, i64 %1083
  %1085 = load float, float* %1084, align 4
  store float %1085, float* %25, align 4
  %1086 = fcmp olt float %1085, %1055
  %1087 = select i1 %1086, float* %25, float* %24
  %1088 = bitcast float* %1087 to i32*
  %1089 = load i32, i32* %1088, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %781)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %780)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %782)
  %1090 = add i64 %1026, %1018
  %1091 = getelementptr inbounds float, float* %676, i64 %1090
  %1092 = load float, float* %1091, align 8
  store float %1092, float* %26, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %783)
  %1093 = add i64 %1031, %1018
  %1094 = getelementptr inbounds float, float* %676, i64 %1093
  %1095 = load float, float* %1094, align 4
  store float %1095, float* %27, align 4
  %1096 = fcmp olt float %1095, %1092
  %1097 = select i1 %1096, float* %27, float* %26
  %1098 = bitcast float* %1097 to i32*
  %1099 = load i32, i32* %1098, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %783)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %782)
  %1100 = bitcast i32 %1082 to float
  %1101 = bitcast i32 %1070 to float
  %1102 = fcmp olt float %1100, %1101
  %1103 = select i1 %1102, i32 %1082, i32 %1070
  %1104 = bitcast i32 %1099 to float
  %1105 = bitcast i32 %1089 to float
  %1106 = fcmp olt float %1104, %1105
  %1107 = select i1 %1106, i32 %1099, i32 %1089
  %1108 = bitcast i32 %1107 to float
  %1109 = bitcast i32 %1103 to float
  %1110 = fcmp olt float %1108, %1109
  %1111 = select i1 %1110, i32 %1107, i32 %1103
  %1112 = add i64 %1072, %1018
  %1113 = getelementptr inbounds float, float* %676, i64 %1112
  %1114 = load float, float* %1113, align 8
  %1115 = bitcast i32 %1111 to float
  %1116 = fcmp olt float %1114, %1115
  %1117 = bitcast i32 %1111 to float
  %1118 = select i1 %1116, float %1114, float %1117
  %1119 = bitcast i32 %1060 to float
  %1120 = fcmp olt float %1118, %1119
  %1121 = load float, float* %775, align 4
  %1122 = select i1 %1120, float %1118, float %1121
  %1123 = fmul float %1119, 1.250000e-01
  %1124 = fmul float %1122, 6.250000e-01
  %1125 = fadd float %1123, %1124
  %1126 = fmul float %1122, 1.500000e+00
  %1127 = fcmp olt float %1055, %1126
  %1128 = select i1 %1127, float %1055, float %1126
  %1129 = fmul float %1128, 1.250000e-01
  %1130 = fadd float %1125, %1129
  %1131 = fmul float %1118, 1.250000e-01
  %1132 = fadd float %1131, %1130
  %1133 = fadd float %987, %1132
  %1134 = fpext float %1133 to double
  %1135 = fdiv double %991, %1134
  %1136 = fptrunc double %1135 to float
  %1137 = fcmp ogt float %1136, 0x40099999A0000000
  %1138 = fadd float %1029, %1034
  %1139 = fadd float %1138, %1041
  %1140 = fadd float %1139, %1044
  %1141 = fadd float %1140, %1132
  %1142 = fmul float %1141, 0x3FC99999A0000000
  %1143 = fcmp olt float %1142, %992
  %1144 = or i1 %1143, %1137
  %1145 = select i1 %1144, i8 4, i8 0
  %1146 = add i64 %1024, %1019
  %1147 = add i64 %1146, %950
  %1148 = getelementptr inbounds i8, i8* %928, i64 %1147
  store i8 %1145, i8* %1148, align 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %773)
  %1149 = add nuw nsw i64 %1024, 1
  %1150 = icmp ult i64 %1149, %979
  br i1 %1150, label %1023, label %1020

1151:                                             ; preds = %1020, %948
  %1152 = add i64 %949, 1
  %1153 = icmp ult i64 %1152, %111
  br i1 %1153, label %948, label %944

1154:                                             ; preds = %1171, %66
  %1155 = phi i64 [ 0, %66 ], [ %1172, %1171 ]
  %1156 = icmp eq i64 %70, 0
  br i1 %1156, label %1168, label %1157

1157:                                             ; preds = %1154
  %1158 = add i64 %1155, %60
  %1159 = load i8*, i8** %67, align 8
  %1160 = load i64, i64* %68, align 8
  %1161 = mul i64 %1160, %1158
  %1162 = getelementptr inbounds i8, i8* %1159, i64 %1161
  %1163 = ptrtoint i8* %1162 to i64
  %1164 = and i64 %1163, 63
  %1165 = icmp eq i64 %1164, 0
  tail call void @llvm.assume(i1 %1165) #7
  br i1 %69, label %1168, label %1166

1166:                                             ; preds = %1157
  %1167 = getelementptr inbounds i8, i8* %1162, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1167, i8 4, i64 %62, i1 false) #7
  br label %1168

1168:                                             ; preds = %1154, %1157, %1166, %56, %914
  ret void

1169:                                             ; preds = %87
  %1170 = getelementptr inbounds i8, i8* %93, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1170, i8 4, i64 %62, i1 false) #7
  br label %1171

1171:                                             ; preds = %1169, %87
  %1172 = add nuw i64 %75, 2
  %1173 = add i64 %76, -2
  %1174 = icmp eq i64 %1173, 0
  br i1 %1174, label %1154, label %74
}

; Function Attrs: nounwind ssp uwtable
define internal void @_ZN3jxl6N_SSE412_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE(%"class.jxl::Image3"* dereferenceable(96), %"struct.jxl::PassesEncoderState"* nocapture readonly, %"class.jxl::Rect"* nocapture readonly dereferenceable(32), %"struct.jxl::ArControlFieldHeuristics::TempImages"*) #3 {
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca float*, align 8
  %8 = alloca [3 x float*], align 16
  %9 = alloca [3 x float*], align 16
  %10 = alloca [3 x float*], align 16
  %11 = alloca [4 x float*], align 16
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca float, align 4
  %15 = alloca float, align 4
  %16 = alloca float, align 4
  %17 = alloca float, align 4
  %18 = alloca i32, align 4
  %19 = alloca float, align 4
  %20 = alloca float, align 4
  %21 = alloca float, align 4
  %22 = alloca float, align 4
  %23 = alloca float, align 4
  %24 = alloca float, align 4
  %25 = alloca float, align 4
  %26 = alloca float, align 4
  %27 = alloca float, align 4
  %28 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 0
  %29 = load i32, i32* %28, align 8
  %30 = zext i32 %29 to i64
  %31 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 8
  %32 = load i64, i64* %31, align 8
  %33 = icmp eq i64 %32, %30
  br i1 %33, label %34, label %41

34:                                               ; preds = %4
  %35 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 1
  %36 = load i32, i32* %35, align 4
  %37 = zext i32 %36 to i64
  %38 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 9
  %39 = load i64, i64* %38, align 8
  %40 = icmp eq i64 %39, %37
  br i1 %40, label %44, label %41

41:                                               ; preds = %4, %34
  %42 = tail call zeroext i1 (i8*, ...) @_ZN3jxl5DebugEPKcz(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.1, i64 0, i64 0), i32 54, i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.str.2, i64 0, i64 0)) #7
  %43 = tail call zeroext i1 @_ZN3jxl5AbortEv() #10
  unreachable

44:                                               ; preds = %34
  %45 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 0
  %46 = load float, float* %45, align 8
  %47 = fcmp olt float %46, 5.000000e-01
  br i1 %47, label %56, label %48

48:                                               ; preds = %44
  %49 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 7
  %50 = load i32, i32* %49, align 4
  %51 = icmp sgt i32 %50, 4
  br i1 %51, label %56, label %52

52:                                               ; preds = %48
  %53 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 1, i32 26, i32 11
  %54 = load i32, i32* %53, align 4
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %97

56:                                               ; preds = %52, %48, %44
  %57 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %58 = load i64, i64* %57, align 8
  %59 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %60 = load i64, i64* %59, align 8
  %61 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %62 = load i64, i64* %61, align 8
  %63 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %64 = load i64, i64* %63, align 8
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %1181, label %66

66:                                               ; preds = %56
  %67 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %68 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %69 = icmp eq i64 %62, 0
  %70 = and i64 %64, 1
  %71 = icmp eq i64 %64, 1
  br i1 %71, label %1167, label %72

72:                                               ; preds = %66
  %73 = sub i64 %64, %70
  br label %74

74:                                               ; preds = %1184, %72
  %75 = phi i64 [ 0, %72 ], [ %1185, %1184 ]
  %76 = phi i64 [ %73, %72 ], [ %1186, %1184 ]
  %77 = add i64 %75, %60
  %78 = load i8*, i8** %67, align 8
  %79 = load i64, i64* %68, align 8
  %80 = mul i64 %79, %77
  %81 = getelementptr inbounds i8, i8* %78, i64 %80
  %82 = ptrtoint i8* %81 to i64
  %83 = and i64 %82, 63
  %84 = icmp eq i64 %83, 0
  tail call void @llvm.assume(i1 %84) #7
  br i1 %69, label %87, label %85

85:                                               ; preds = %74
  %86 = getelementptr inbounds i8, i8* %81, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %86, i8 4, i64 %62, i1 false) #7
  br label %87

87:                                               ; preds = %85, %74
  %88 = or i64 %75, 1
  %89 = add i64 %88, %60
  %90 = load i8*, i8** %67, align 8
  %91 = load i64, i64* %68, align 8
  %92 = mul i64 %91, %89
  %93 = getelementptr inbounds i8, i8* %90, i64 %92
  %94 = ptrtoint i8* %93 to i64
  %95 = and i64 %94, 63
  %96 = icmp eq i64 %95, 0
  tail call void @llvm.assume(i1 %96) #7
  br i1 %69, label %1184, label %1182

97:                                               ; preds = %52
  %98 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %99 = load i64, i64* %98, align 8
  %100 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %100) #7
  %101 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %102 = load i64, i64* %101, align 8
  store i64 %102, i64* %5, align 8
  %103 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %104 = load i64, i64* %103, align 8
  %105 = add i64 %104, %102
  %106 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %106) #7
  %107 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %108 = load i64, i64* %107, align 8
  store i64 %108, i64* %6, align 8
  %109 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %110 = load i64, i64* %109, align 8
  %111 = add i64 %110, %108
  tail call void @_ZN3jxl24ArControlFieldHeuristics10TempImages8InitOnceEv(%"struct.jxl::ArControlFieldHeuristics::TempImages"* %3)
  %112 = icmp eq i64 %102, 0
  %113 = select i1 %112, i64 2, i64 0
  %114 = shl i64 %105, 3
  %115 = or i64 %114, 4
  %116 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 1
  %117 = load i32, i32* %116, align 4
  %118 = zext i32 %117 to i64
  %119 = add nuw nsw i64 %118, 2
  %120 = icmp ugt i64 %115, %119
  %121 = shl i64 %104, 3
  %122 = or i64 %121, 4
  %123 = shl i64 %102, 3
  %124 = sub i64 %119, %123
  %125 = select i1 %120, i64 %124, i64 %122
  %126 = icmp eq i64 %108, 0
  %127 = select i1 %126, i64 2, i64 0
  %128 = shl i64 %111, 3
  %129 = or i64 %128, 4
  %130 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 0
  %131 = load i32, i32* %130, align 8
  %132 = zext i32 %131 to i64
  %133 = add nuw nsw i64 %132, 2
  %134 = icmp ugt i64 %129, %133
  %135 = shl i64 %110, 3
  %136 = or i64 %135, 4
  %137 = shl i64 %108, 3
  %138 = sub i64 %133, %137
  %139 = select i1 %134, i64 %138, i64 %136
  %140 = icmp ult i64 %113, %125
  br i1 %140, label %141, label %179

141:                                              ; preds = %97
  %142 = bitcast float** %7 to i8*
  %143 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %144 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %145 = bitcast float** %7 to i8**
  %146 = shl i64 %102, 3
  %147 = bitcast [3 x float*]* %8 to i8*
  %148 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 0
  %149 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 1
  %150 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 2
  %151 = bitcast [3 x float*]* %9 to i8*
  %152 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 0
  %153 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 1
  %154 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 2
  %155 = bitcast [3 x float*]* %10 to i8*
  %156 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 0
  %157 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 1
  %158 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 2
  %159 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 4
  %160 = shl i64 %108, 3
  %161 = or i64 %160, %127
  %162 = icmp ult i64 %161, 3
  %163 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %164 = bitcast [3 x float*]* %8 to i8**
  %165 = bitcast [3 x float*]* %9 to i8**
  %166 = bitcast [3 x float*]* %10 to i8**
  %167 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %168 = bitcast float** %149 to i8**
  %169 = bitcast float** %153 to i8**
  %170 = bitcast float** %157 to i8**
  %171 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %172 = bitcast float** %150 to i8**
  %173 = bitcast float** %154 to i8**
  %174 = bitcast float** %158 to i8**
  %175 = add i64 %160, -1
  %176 = add i64 %160, -2
  br label %207

177:                                              ; preds = %659
  %178 = load i64, i64* %5, align 8
  br label %179

179:                                              ; preds = %177, %97
  %180 = phi i64 [ %178, %177 ], [ %102, %97 ]
  %181 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 4
  %182 = load i64, i64* %181, align 8
  %183 = lshr i64 %182, 2
  %184 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %185 = load i8*, i8** %184, align 8
  %186 = ptrtoint i8* %185 to i64
  %187 = and i64 %186, 63
  %188 = icmp eq i64 %187, 0
  tail call void @llvm.assume(i1 %188) #7
  %189 = sub i64 %105, %180
  %190 = and i64 %189, 9223372036854775807
  %191 = icmp eq i64 %190, 0
  %192 = bitcast i8* %185 to float*
  br i1 %191, label %193, label %198

193:                                              ; preds = %179
  %194 = load i64, i64* %6, align 8
  %195 = sub i64 %111, %194
  %196 = shl i64 %195, 1
  %197 = shl i64 %189, 1
  br label %664

198:                                              ; preds = %179
  %199 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %200 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %201 = load i64, i64* %6, align 8
  %202 = sub i64 %111, %201
  %203 = and i64 %202, 9223372036854775807
  %204 = icmp eq i64 %203, 0
  %205 = shl i64 %202, 1
  %206 = shl i64 %189, 1
  br label %692

207:                                              ; preds = %662, %141
  %208 = phi i32 [ %117, %141 ], [ %663, %662 ]
  %209 = phi i64 [ %113, %141 ], [ %660, %662 ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %142) #7
  %210 = load i8*, i8** %143, align 8
  %211 = load i64, i64* %144, align 8
  %212 = mul i64 %211, %209
  %213 = getelementptr inbounds i8, i8* %210, i64 %212
  %214 = ptrtoint i8* %213 to i64
  %215 = and i64 %214, 63
  %216 = icmp eq i64 %215, 0
  tail call void @llvm.assume(i1 %216) #7
  store i8* %213, i8** %145, align 8
  %217 = add i64 %146, %209
  %218 = add i64 %217, -2
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %155) #7
  %219 = icmp eq i64 %218, 0
  %220 = add i64 %217, -3
  %221 = select i1 %219, i64 0, i64 %220
  %222 = load i64, i64* %159, align 8
  %223 = mul i64 %222, %221
  %224 = mul i64 %222, %218
  %225 = add i64 %217, -1
  %226 = zext i32 %208 to i64
  %227 = icmp ult i64 %225, %226
  %228 = select i1 %227, i64 %225, i64 %218
  %229 = mul i64 %228, %222
  %230 = load i8*, i8** %163, align 8
  %231 = ptrtoint i8* %230 to i64
  %232 = and i64 %231, 63
  %233 = icmp eq i64 %232, 0
  tail call void @llvm.assume(i1 %233) #7
  %234 = getelementptr inbounds i8, i8* %230, i64 %223
  %235 = ptrtoint i8* %234 to i64
  %236 = and i64 %235, 63
  %237 = icmp eq i64 %236, 0
  tail call void @llvm.assume(i1 %237) #7
  store i8* %234, i8** %164, align 16
  %238 = getelementptr inbounds i8, i8* %230, i64 %224
  %239 = ptrtoint i8* %238 to i64
  %240 = and i64 %239, 63
  %241 = icmp eq i64 %240, 0
  tail call void @llvm.assume(i1 %241) #7
  store i8* %238, i8** %165, align 16
  %242 = getelementptr inbounds i8, i8* %230, i64 %229
  %243 = ptrtoint i8* %242 to i64
  %244 = and i64 %243, 63
  %245 = icmp eq i64 %244, 0
  tail call void @llvm.assume(i1 %245) #7
  store i8* %242, i8** %166, align 16
  %246 = load i8*, i8** %167, align 8
  %247 = ptrtoint i8* %246 to i64
  %248 = and i64 %247, 63
  %249 = icmp eq i64 %248, 0
  tail call void @llvm.assume(i1 %249) #7
  %250 = getelementptr inbounds i8, i8* %246, i64 %223
  %251 = ptrtoint i8* %250 to i64
  %252 = and i64 %251, 63
  %253 = icmp eq i64 %252, 0
  tail call void @llvm.assume(i1 %253) #7
  store i8* %250, i8** %168, align 8
  %254 = getelementptr inbounds i8, i8* %246, i64 %224
  %255 = ptrtoint i8* %254 to i64
  %256 = and i64 %255, 63
  %257 = icmp eq i64 %256, 0
  tail call void @llvm.assume(i1 %257) #7
  store i8* %254, i8** %169, align 8
  %258 = getelementptr inbounds i8, i8* %246, i64 %229
  %259 = ptrtoint i8* %258 to i64
  %260 = and i64 %259, 63
  %261 = icmp eq i64 %260, 0
  tail call void @llvm.assume(i1 %261) #7
  store i8* %258, i8** %170, align 8
  %262 = load i8*, i8** %171, align 8
  %263 = ptrtoint i8* %262 to i64
  %264 = and i64 %263, 63
  %265 = icmp eq i64 %264, 0
  tail call void @llvm.assume(i1 %265) #7
  %266 = getelementptr inbounds i8, i8* %262, i64 %223
  %267 = ptrtoint i8* %266 to i64
  %268 = and i64 %267, 63
  %269 = icmp eq i64 %268, 0
  tail call void @llvm.assume(i1 %269) #7
  store i8* %266, i8** %172, align 16
  %270 = getelementptr inbounds i8, i8* %262, i64 %224
  %271 = ptrtoint i8* %270 to i64
  %272 = and i64 %271, 63
  %273 = icmp eq i64 %272, 0
  tail call void @llvm.assume(i1 %273) #7
  store i8* %270, i8** %173, align 16
  %274 = getelementptr inbounds i8, i8* %262, i64 %229
  %275 = ptrtoint i8* %274 to i64
  %276 = and i64 %275, 63
  %277 = icmp eq i64 %276, 0
  tail call void @llvm.assume(i1 %277) #7
  store i8* %274, i8** %174, align 16
  %278 = bitcast i8* %238 to float*
  %279 = bitcast i8* %242 to float*
  %280 = bitcast i8* %234 to float*
  %281 = bitcast i8* %254 to float*
  %282 = bitcast i8* %258 to float*
  %283 = bitcast i8* %250 to float*
  %284 = bitcast i8* %270 to float*
  %285 = bitcast i8* %274 to float*
  %286 = bitcast i8* %266 to float*
  br i1 %162, label %287, label %289

287:                                              ; preds = %207
  %288 = load float*, float** %7, align 8
  br label %304

289:                                              ; preds = %304, %207
  %290 = phi i64 [ %127, %207 ], [ %407, %304 ]
  %291 = add i64 %290, 4
  %292 = icmp ugt i64 %291, %139
  br i1 %292, label %540, label %293

293:                                              ; preds = %289
  %294 = load float*, float** %7, align 8
  %295 = load float*, float** %152, align 16
  %296 = load float*, float** %148, align 16
  %297 = load float*, float** %156, align 16
  %298 = load float*, float** %153, align 8
  %299 = load float*, float** %149, align 8
  %300 = load float*, float** %157, align 8
  %301 = load float*, float** %154, align 16
  %302 = load float*, float** %150, align 16
  %303 = load float*, float** %158, align 16
  br label %410

304:                                              ; preds = %287, %304
  %305 = phi i64 [ %161, %287 ], [ %408, %304 ]
  %306 = phi i64 [ %127, %287 ], [ %407, %304 ]
  %307 = add nsw i64 %305, -2
  %308 = icmp eq i64 %307, 0
  %309 = add nuw nsw i64 %305, -3
  %310 = select i1 %308, i64 0, i64 %309
  %311 = add nsw i64 %305, -1
  %312 = load i32, i32* %130, align 8
  %313 = zext i32 %312 to i64
  %314 = icmp ult i64 %311, %313
  %315 = select i1 %314, i64 %311, i64 %307
  %316 = getelementptr inbounds float, float* %278, i64 %307
  %317 = load float, float* %316, align 4
  %318 = fmul float %317, 0x4011666660000000
  %319 = getelementptr inbounds float, float* %278, i64 %310
  %320 = load float, float* %319, align 4
  %321 = getelementptr inbounds float, float* %278, i64 %315
  %322 = load float, float* %321, align 4
  %323 = fadd float %320, %322
  %324 = getelementptr inbounds float, float* %279, i64 %310
  %325 = load float, float* %324, align 4
  %326 = fadd float %323, %325
  %327 = getelementptr inbounds float, float* %279, i64 %307
  %328 = load float, float* %327, align 4
  %329 = fadd float %326, %328
  %330 = getelementptr inbounds float, float* %279, i64 %315
  %331 = load float, float* %330, align 4
  %332 = fadd float %329, %331
  %333 = getelementptr inbounds float, float* %280, i64 %310
  %334 = load float, float* %333, align 4
  %335 = fadd float %332, %334
  %336 = getelementptr inbounds float, float* %280, i64 %307
  %337 = load float, float* %336, align 4
  %338 = fadd float %335, %337
  %339 = getelementptr inbounds float, float* %280, i64 %315
  %340 = load float, float* %339, align 4
  %341 = fadd float %338, %340
  %342 = fmul float %341, 0x3FE1666660000000
  %343 = fsub float %318, %342
  %344 = fmul float %343, %343
  %345 = fadd float %344, 0.000000e+00
  %346 = getelementptr inbounds float, float* %281, i64 %307
  %347 = load float, float* %346, align 4
  %348 = fmul float %347, 0x4011666660000000
  %349 = getelementptr inbounds float, float* %281, i64 %310
  %350 = load float, float* %349, align 4
  %351 = getelementptr inbounds float, float* %281, i64 %315
  %352 = load float, float* %351, align 4
  %353 = fadd float %350, %352
  %354 = getelementptr inbounds float, float* %282, i64 %310
  %355 = load float, float* %354, align 4
  %356 = fadd float %353, %355
  %357 = getelementptr inbounds float, float* %282, i64 %307
  %358 = load float, float* %357, align 4
  %359 = fadd float %356, %358
  %360 = getelementptr inbounds float, float* %282, i64 %315
  %361 = load float, float* %360, align 4
  %362 = fadd float %359, %361
  %363 = getelementptr inbounds float, float* %283, i64 %310
  %364 = load float, float* %363, align 4
  %365 = fadd float %362, %364
  %366 = getelementptr inbounds float, float* %283, i64 %307
  %367 = load float, float* %366, align 4
  %368 = fadd float %365, %367
  %369 = getelementptr inbounds float, float* %283, i64 %315
  %370 = load float, float* %369, align 4
  %371 = fadd float %368, %370
  %372 = fmul float %371, 0x3FE1666660000000
  %373 = fsub float %348, %372
  %374 = fmul float %373, %373
  %375 = fadd float %345, %374
  %376 = getelementptr inbounds float, float* %284, i64 %307
  %377 = load float, float* %376, align 4
  %378 = fmul float %377, 0x3FD25E3540000000
  %379 = getelementptr inbounds float, float* %284, i64 %310
  %380 = load float, float* %379, align 4
  %381 = getelementptr inbounds float, float* %284, i64 %315
  %382 = load float, float* %381, align 4
  %383 = fadd float %380, %382
  %384 = getelementptr inbounds float, float* %285, i64 %310
  %385 = load float, float* %384, align 4
  %386 = fadd float %383, %385
  %387 = getelementptr inbounds float, float* %285, i64 %307
  %388 = load float, float* %387, align 4
  %389 = fadd float %386, %388
  %390 = getelementptr inbounds float, float* %285, i64 %315
  %391 = load float, float* %390, align 4
  %392 = fadd float %389, %391
  %393 = getelementptr inbounds float, float* %286, i64 %310
  %394 = load float, float* %393, align 4
  %395 = fadd float %392, %394
  %396 = getelementptr inbounds float, float* %286, i64 %307
  %397 = load float, float* %396, align 4
  %398 = fadd float %395, %397
  %399 = getelementptr inbounds float, float* %286, i64 %315
  %400 = load float, float* %399, align 4
  %401 = fadd float %398, %400
  %402 = fmul float %401, 0x3FA25E3540000000
  %403 = fsub float %378, %402
  %404 = fmul float %403, %403
  %405 = fadd float %375, %404
  %406 = getelementptr inbounds float, float* %288, i64 %306
  store float %405, float* %406, align 4
  %407 = add nuw nsw i64 %306, 1
  %408 = add i64 %160, %407
  %409 = icmp ult i64 %408, 3
  br i1 %409, label %304, label %289

410:                                              ; preds = %293, %417
  %411 = phi i64 [ %291, %293 ], [ %538, %417 ]
  %412 = phi i64 [ %290, %293 ], [ %411, %417 ]
  %413 = add i64 %175, %411
  %414 = load i32, i32* %130, align 8
  %415 = zext i32 %414 to i64
  %416 = icmp ugt i64 %413, %415
  br i1 %416, label %540, label %417

417:                                              ; preds = %410
  %418 = add i64 %176, %412
  %419 = getelementptr inbounds float, float* %295, i64 %418
  %420 = bitcast float* %419 to <4 x float>*
  %421 = load <4 x float>, <4 x float>* %420, align 1, !alias.scope !111
  %422 = fmul <4 x float> %421, <float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000>
  %423 = getelementptr inbounds float, float* %419, i64 -1
  %424 = bitcast float* %423 to <4 x float>*
  %425 = load <4 x float>, <4 x float>* %424, align 1, !alias.scope !114
  %426 = getelementptr inbounds float, float* %419, i64 1
  %427 = bitcast float* %426 to <4 x float>*
  %428 = load <4 x float>, <4 x float>* %427, align 1, !alias.scope !117
  %429 = getelementptr inbounds float, float* %296, i64 %418
  %430 = getelementptr inbounds float, float* %429, i64 -1
  %431 = bitcast float* %430 to <4 x float>*
  %432 = load <4 x float>, <4 x float>* %431, align 1, !alias.scope !120
  %433 = bitcast float* %429 to <4 x float>*
  %434 = load <4 x float>, <4 x float>* %433, align 1, !alias.scope !123
  %435 = getelementptr inbounds float, float* %429, i64 1
  %436 = bitcast float* %435 to <4 x float>*
  %437 = load <4 x float>, <4 x float>* %436, align 1, !alias.scope !126
  %438 = fadd <4 x float> %425, %437
  %439 = getelementptr inbounds float, float* %297, i64 %418
  %440 = getelementptr inbounds float, float* %439, i64 -1
  %441 = bitcast float* %440 to <4 x float>*
  %442 = load <4 x float>, <4 x float>* %441, align 1, !alias.scope !129
  %443 = fadd <4 x float> %428, %442
  %444 = bitcast float* %439 to <4 x float>*
  %445 = load <4 x float>, <4 x float>* %444, align 1, !alias.scope !132
  %446 = fadd <4 x float> %432, %445
  %447 = getelementptr inbounds float, float* %439, i64 1
  %448 = bitcast float* %447 to <4 x float>*
  %449 = load <4 x float>, <4 x float>* %448, align 1, !alias.scope !135
  %450 = fadd <4 x float> %434, %449
  %451 = fadd <4 x float> %438, %443
  %452 = fadd <4 x float> %446, %450
  %453 = fadd <4 x float> %451, %452
  %454 = fmul <4 x float> %453, <float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000>
  %455 = fadd <4 x float> %422, %454
  %456 = fmul <4 x float> %455, %455
  %457 = fadd <4 x float> %456, zeroinitializer
  %458 = getelementptr inbounds float, float* %298, i64 %418
  %459 = bitcast float* %458 to <4 x float>*
  %460 = load <4 x float>, <4 x float>* %459, align 1, !alias.scope !111
  %461 = fmul <4 x float> %460, <float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000, float 0x4011666660000000>
  %462 = getelementptr inbounds float, float* %458, i64 -1
  %463 = bitcast float* %462 to <4 x float>*
  %464 = load <4 x float>, <4 x float>* %463, align 1, !alias.scope !114
  %465 = getelementptr inbounds float, float* %458, i64 1
  %466 = bitcast float* %465 to <4 x float>*
  %467 = load <4 x float>, <4 x float>* %466, align 1, !alias.scope !117
  %468 = getelementptr inbounds float, float* %299, i64 %418
  %469 = getelementptr inbounds float, float* %468, i64 -1
  %470 = bitcast float* %469 to <4 x float>*
  %471 = load <4 x float>, <4 x float>* %470, align 1, !alias.scope !120
  %472 = bitcast float* %468 to <4 x float>*
  %473 = load <4 x float>, <4 x float>* %472, align 1, !alias.scope !123
  %474 = getelementptr inbounds float, float* %468, i64 1
  %475 = bitcast float* %474 to <4 x float>*
  %476 = load <4 x float>, <4 x float>* %475, align 1, !alias.scope !126
  %477 = fadd <4 x float> %464, %476
  %478 = getelementptr inbounds float, float* %300, i64 %418
  %479 = getelementptr inbounds float, float* %478, i64 -1
  %480 = bitcast float* %479 to <4 x float>*
  %481 = load <4 x float>, <4 x float>* %480, align 1, !alias.scope !129
  %482 = fadd <4 x float> %467, %481
  %483 = bitcast float* %478 to <4 x float>*
  %484 = load <4 x float>, <4 x float>* %483, align 1, !alias.scope !132
  %485 = fadd <4 x float> %471, %484
  %486 = getelementptr inbounds float, float* %478, i64 1
  %487 = bitcast float* %486 to <4 x float>*
  %488 = load <4 x float>, <4 x float>* %487, align 1, !alias.scope !135
  %489 = fadd <4 x float> %473, %488
  %490 = fadd <4 x float> %477, %482
  %491 = fadd <4 x float> %485, %489
  %492 = fadd <4 x float> %490, %491
  %493 = fmul <4 x float> %492, <float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000, float 0xBFE1666660000000>
  %494 = fadd <4 x float> %461, %493
  %495 = fmul <4 x float> %494, %494
  %496 = fadd <4 x float> %457, %495
  %497 = getelementptr inbounds float, float* %301, i64 %418
  %498 = bitcast float* %497 to <4 x float>*
  %499 = load <4 x float>, <4 x float>* %498, align 1, !alias.scope !111
  %500 = fmul <4 x float> %499, <float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000, float 0x3FD25E3540000000>
  %501 = getelementptr inbounds float, float* %497, i64 -1
  %502 = bitcast float* %501 to <4 x float>*
  %503 = load <4 x float>, <4 x float>* %502, align 1, !alias.scope !114
  %504 = getelementptr inbounds float, float* %497, i64 1
  %505 = bitcast float* %504 to <4 x float>*
  %506 = load <4 x float>, <4 x float>* %505, align 1, !alias.scope !117
  %507 = getelementptr inbounds float, float* %302, i64 %418
  %508 = getelementptr inbounds float, float* %507, i64 -1
  %509 = bitcast float* %508 to <4 x float>*
  %510 = load <4 x float>, <4 x float>* %509, align 1, !alias.scope !120
  %511 = bitcast float* %507 to <4 x float>*
  %512 = load <4 x float>, <4 x float>* %511, align 1, !alias.scope !123
  %513 = getelementptr inbounds float, float* %507, i64 1
  %514 = bitcast float* %513 to <4 x float>*
  %515 = load <4 x float>, <4 x float>* %514, align 1, !alias.scope !126
  %516 = fadd <4 x float> %503, %515
  %517 = getelementptr inbounds float, float* %303, i64 %418
  %518 = getelementptr inbounds float, float* %517, i64 -1
  %519 = bitcast float* %518 to <4 x float>*
  %520 = load <4 x float>, <4 x float>* %519, align 1, !alias.scope !129
  %521 = fadd <4 x float> %506, %520
  %522 = bitcast float* %517 to <4 x float>*
  %523 = load <4 x float>, <4 x float>* %522, align 1, !alias.scope !132
  %524 = fadd <4 x float> %510, %523
  %525 = getelementptr inbounds float, float* %517, i64 1
  %526 = bitcast float* %525 to <4 x float>*
  %527 = load <4 x float>, <4 x float>* %526, align 1, !alias.scope !135
  %528 = fadd <4 x float> %512, %527
  %529 = fadd <4 x float> %516, %521
  %530 = fadd <4 x float> %524, %528
  %531 = fadd <4 x float> %529, %530
  %532 = fmul <4 x float> %531, <float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000, float 0xBFA25E3540000000>
  %533 = fadd <4 x float> %500, %532
  %534 = fmul <4 x float> %533, %533
  %535 = fadd <4 x float> %496, %534
  %536 = getelementptr inbounds float, float* %294, i64 %412
  %537 = bitcast float* %536 to <4 x float>*
  store <4 x float> %535, <4 x float>* %537, align 1, !alias.scope !138
  %538 = add i64 %411, 4
  %539 = icmp ugt i64 %538, %139
  br i1 %539, label %540, label %410

540:                                              ; preds = %417, %410, %289
  %541 = phi i64 [ %290, %289 ], [ %412, %410 ], [ %411, %417 ]
  %542 = icmp ult i64 %541, %139
  br i1 %542, label %543, label %659

543:                                              ; preds = %540
  %544 = load float*, float** %152, align 16
  %545 = load float*, float** %156, align 16
  %546 = load float*, float** %148, align 16
  %547 = load float*, float** %153, align 8
  %548 = load float*, float** %157, align 8
  %549 = load float*, float** %149, align 8
  %550 = load float*, float** %154, align 16
  %551 = load float*, float** %158, align 16
  %552 = load float*, float** %150, align 16
  %553 = load float*, float** %7, align 8
  br label %554

554:                                              ; preds = %543, %554
  %555 = phi i64 [ %541, %543 ], [ %657, %554 ]
  %556 = add i64 %160, %555
  %557 = add i64 %556, -2
  %558 = icmp eq i64 %557, 0
  %559 = add i64 %556, -3
  %560 = select i1 %558, i64 0, i64 %559
  %561 = add i64 %556, -1
  %562 = load i32, i32* %130, align 8
  %563 = zext i32 %562 to i64
  %564 = icmp ult i64 %561, %563
  %565 = select i1 %564, i64 %561, i64 %557
  %566 = getelementptr inbounds float, float* %544, i64 %557
  %567 = load float, float* %566, align 4
  %568 = fmul float %567, 0x4011666660000000
  %569 = getelementptr inbounds float, float* %544, i64 %560
  %570 = load float, float* %569, align 4
  %571 = getelementptr inbounds float, float* %544, i64 %565
  %572 = load float, float* %571, align 4
  %573 = fadd float %570, %572
  %574 = getelementptr inbounds float, float* %545, i64 %560
  %575 = load float, float* %574, align 4
  %576 = fadd float %573, %575
  %577 = getelementptr inbounds float, float* %545, i64 %557
  %578 = load float, float* %577, align 4
  %579 = fadd float %576, %578
  %580 = getelementptr inbounds float, float* %545, i64 %565
  %581 = load float, float* %580, align 4
  %582 = fadd float %579, %581
  %583 = getelementptr inbounds float, float* %546, i64 %560
  %584 = load float, float* %583, align 4
  %585 = fadd float %582, %584
  %586 = getelementptr inbounds float, float* %546, i64 %557
  %587 = load float, float* %586, align 4
  %588 = fadd float %585, %587
  %589 = getelementptr inbounds float, float* %546, i64 %565
  %590 = load float, float* %589, align 4
  %591 = fadd float %588, %590
  %592 = fmul float %591, 0x3FE1666660000000
  %593 = fsub float %568, %592
  %594 = fmul float %593, %593
  %595 = fadd float %594, 0.000000e+00
  %596 = getelementptr inbounds float, float* %547, i64 %557
  %597 = load float, float* %596, align 4
  %598 = fmul float %597, 0x4011666660000000
  %599 = getelementptr inbounds float, float* %547, i64 %560
  %600 = load float, float* %599, align 4
  %601 = getelementptr inbounds float, float* %547, i64 %565
  %602 = load float, float* %601, align 4
  %603 = fadd float %600, %602
  %604 = getelementptr inbounds float, float* %548, i64 %560
  %605 = load float, float* %604, align 4
  %606 = fadd float %603, %605
  %607 = getelementptr inbounds float, float* %548, i64 %557
  %608 = load float, float* %607, align 4
  %609 = fadd float %606, %608
  %610 = getelementptr inbounds float, float* %548, i64 %565
  %611 = load float, float* %610, align 4
  %612 = fadd float %609, %611
  %613 = getelementptr inbounds float, float* %549, i64 %560
  %614 = load float, float* %613, align 4
  %615 = fadd float %612, %614
  %616 = getelementptr inbounds float, float* %549, i64 %557
  %617 = load float, float* %616, align 4
  %618 = fadd float %615, %617
  %619 = getelementptr inbounds float, float* %549, i64 %565
  %620 = load float, float* %619, align 4
  %621 = fadd float %618, %620
  %622 = fmul float %621, 0x3FE1666660000000
  %623 = fsub float %598, %622
  %624 = fmul float %623, %623
  %625 = fadd float %595, %624
  %626 = getelementptr inbounds float, float* %550, i64 %557
  %627 = load float, float* %626, align 4
  %628 = fmul float %627, 0x3FD25E3540000000
  %629 = getelementptr inbounds float, float* %550, i64 %560
  %630 = load float, float* %629, align 4
  %631 = getelementptr inbounds float, float* %550, i64 %565
  %632 = load float, float* %631, align 4
  %633 = fadd float %630, %632
  %634 = getelementptr inbounds float, float* %551, i64 %560
  %635 = load float, float* %634, align 4
  %636 = fadd float %633, %635
  %637 = getelementptr inbounds float, float* %551, i64 %557
  %638 = load float, float* %637, align 4
  %639 = fadd float %636, %638
  %640 = getelementptr inbounds float, float* %551, i64 %565
  %641 = load float, float* %640, align 4
  %642 = fadd float %639, %641
  %643 = getelementptr inbounds float, float* %552, i64 %560
  %644 = load float, float* %643, align 4
  %645 = fadd float %642, %644
  %646 = getelementptr inbounds float, float* %552, i64 %557
  %647 = load float, float* %646, align 4
  %648 = fadd float %645, %647
  %649 = getelementptr inbounds float, float* %552, i64 %565
  %650 = load float, float* %649, align 4
  %651 = fadd float %648, %650
  %652 = fmul float %651, 0x3FA25E3540000000
  %653 = fsub float %628, %652
  %654 = fmul float %653, %653
  %655 = fadd float %625, %654
  %656 = getelementptr inbounds float, float* %553, i64 %555
  store float %655, float* %656, align 4
  %657 = add nuw i64 %555, 1
  %658 = icmp ult i64 %657, %139
  br i1 %658, label %554, label %659

659:                                              ; preds = %554, %540
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %155) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %142) #7
  %660 = add nuw i64 %209, 1
  %661 = icmp ult i64 %660, %125
  br i1 %661, label %662, label %177

662:                                              ; preds = %659
  %663 = load i32, i32* %116, align 4
  br label %207

664:                                              ; preds = %761, %193
  %665 = phi i64 [ %197, %193 ], [ %206, %761 ]
  %666 = phi i64 [ %196, %193 ], [ %205, %761 ]
  %667 = phi i64 [ %194, %193 ], [ %201, %761 ]
  %668 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 4
  %669 = load i64, i64* %668, align 8
  %670 = lshr i64 %669, 2
  %671 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %672 = load i8*, i8** %671, align 8
  %673 = ptrtoint i8* %672 to i64
  %674 = and i64 %673, 63
  %675 = icmp eq i64 %674, 0
  tail call void @llvm.assume(i1 %675) #7
  %676 = bitcast [4 x float*]* %11 to i8*
  %677 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 1
  %678 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 2
  %679 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 3
  %680 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %681 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %682 = bitcast i8* %672 to float*
  %683 = or i64 %666, 1
  %684 = or i64 %665, 1
  %685 = bitcast [4 x float*]* %11 to i8**
  %686 = bitcast float** %677 to i8**
  %687 = bitcast float** %678 to i8**
  %688 = bitcast float** %679 to i8**
  %689 = shl i64 %180, 3
  %690 = shl i64 %667, 3
  %691 = sub i64 2, %690
  br label %791

692:                                              ; preds = %198, %761
  %693 = phi i64 [ 0, %198 ], [ %762, %761 ]
  %694 = shl i64 %693, 2
  %695 = or i64 %694, 2
  %696 = load i8*, i8** %199, align 8
  %697 = load i64, i64* %200, align 8
  %698 = mul i64 %697, %695
  %699 = getelementptr inbounds i8, i8* %696, i64 %698
  %700 = ptrtoint i8* %699 to i64
  %701 = and i64 %700, 63
  %702 = icmp eq i64 %701, 0
  tail call void @llvm.assume(i1 %702) #7
  %703 = or i64 %694, 3
  %704 = mul i64 %697, %703
  %705 = getelementptr inbounds i8, i8* %696, i64 %704
  %706 = ptrtoint i8* %705 to i64
  %707 = and i64 %706, 63
  %708 = icmp eq i64 %707, 0
  tail call void @llvm.assume(i1 %708) #7
  %709 = add i64 %695, 2
  %710 = mul i64 %697, %709
  %711 = getelementptr inbounds i8, i8* %696, i64 %710
  %712 = ptrtoint i8* %711 to i64
  %713 = and i64 %712, 63
  %714 = icmp eq i64 %713, 0
  tail call void @llvm.assume(i1 %714) #7
  %715 = add i64 %695, 3
  %716 = mul i64 %697, %715
  %717 = getelementptr inbounds i8, i8* %696, i64 %716
  %718 = ptrtoint i8* %717 to i64
  %719 = and i64 %718, 63
  %720 = icmp eq i64 %719, 0
  tail call void @llvm.assume(i1 %720) #7
  %721 = mul i64 %183, %693
  %722 = getelementptr inbounds float, float* %192, i64 %721
  br i1 %204, label %761, label %723

723:                                              ; preds = %692
  %724 = getelementptr inbounds i8, i8* %699, i64 8
  %725 = bitcast i8* %724 to float*
  %726 = getelementptr inbounds i8, i8* %705, i64 8
  %727 = bitcast i8* %726 to float*
  %728 = getelementptr inbounds i8, i8* %711, i64 8
  %729 = bitcast i8* %728 to float*
  %730 = getelementptr inbounds i8, i8* %717, i64 8
  %731 = bitcast i8* %730 to float*
  br label %732

732:                                              ; preds = %723, %732
  %733 = phi i64 [ %759, %732 ], [ 0, %723 ]
  %734 = shl i64 %733, 2
  %735 = getelementptr inbounds float, float* %725, i64 %734
  %736 = bitcast float* %735 to <4 x float>*
  %737 = load <4 x float>, <4 x float>* %736, align 8, !alias.scope !141
  %738 = fadd <4 x float> %737, zeroinitializer
  %739 = getelementptr inbounds float, float* %727, i64 %734
  %740 = bitcast float* %739 to <4 x float>*
  %741 = load <4 x float>, <4 x float>* %740, align 8, !alias.scope !141
  %742 = fadd <4 x float> %738, %741
  %743 = getelementptr inbounds float, float* %729, i64 %734
  %744 = bitcast float* %743 to <4 x float>*
  %745 = load <4 x float>, <4 x float>* %744, align 8, !alias.scope !141
  %746 = fadd <4 x float> %742, %745
  %747 = getelementptr inbounds float, float* %731, i64 %734
  %748 = bitcast float* %747 to <4 x float>*
  %749 = load <4 x float>, <4 x float>* %748, align 8, !alias.scope !141
  %750 = fadd <4 x float> %746, %749
  %751 = shufflevector <4 x float> %750, <4 x float> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %752 = fadd <4 x float> %750, %751
  %753 = shufflevector <4 x float> %752, <4 x float> undef, <4 x i32> <i32 1, i32 2, i32 3, i32 0>
  %754 = fadd <4 x float> %752, %753
  %755 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %754) #7
  %756 = extractelement <4 x float> %755, i32 0
  %757 = fmul float %756, 2.500000e-01
  %758 = getelementptr inbounds float, float* %722, i64 %733
  store float %757, float* %758, align 4
  %759 = add nuw i64 %733, 1
  %760 = icmp ult i64 %759, %205
  br i1 %760, label %732, label %761

761:                                              ; preds = %732, %692
  %762 = add nuw i64 %693, 1
  %763 = icmp ult i64 %762, %206
  br i1 %763, label %692, label %664

764:                                              ; preds = %842
  %765 = bitcast i64* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %765) #7
  store i64 %180, i64* %12, align 8
  %766 = icmp ugt i64 %105, %180
  br i1 %766, label %767, label %920

767:                                              ; preds = %764
  %768 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %769 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 4
  %770 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %771 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %772 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 4
  %773 = bitcast i64* %13 to i8*
  %774 = icmp ult i64 %667, %111
  %775 = bitcast float* %14 to i8*
  %776 = bitcast float* %15 to i8*
  %777 = bitcast float* %16 to i8*
  %778 = bitcast float* %17 to i8*
  %779 = bitcast i32* %18 to i8*
  %780 = bitcast float* %19 to i8*
  %781 = bitcast i32* %18 to float*
  %782 = bitcast float* %20 to i8*
  %783 = bitcast float* %21 to i8*
  %784 = bitcast float* %22 to i8*
  %785 = bitcast float* %23 to i8*
  %786 = bitcast float* %24 to i8*
  %787 = bitcast float* %25 to i8*
  %788 = bitcast float* %26 to i8*
  %789 = bitcast float* %27 to i8*
  %790 = load i64, i64* %12, align 8
  br label %921

791:                                              ; preds = %842, %664
  %792 = phi i64 [ 0, %664 ], [ %843, %842 ]
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %676) #7
  %793 = shl i64 %792, 2
  %794 = load i8*, i8** %680, align 8
  %795 = load i64, i64* %681, align 8
  %796 = mul i64 %795, %793
  %797 = getelementptr inbounds i8, i8* %794, i64 %796
  %798 = ptrtoint i8* %797 to i64
  %799 = and i64 %798, 63
  %800 = icmp eq i64 %799, 0
  tail call void @llvm.assume(i1 %800) #7
  store i8* %797, i8** %685, align 16
  %801 = or i64 %793, 1
  %802 = mul i64 %795, %801
  %803 = getelementptr inbounds i8, i8* %794, i64 %802
  %804 = ptrtoint i8* %803 to i64
  %805 = and i64 %804, 63
  %806 = icmp eq i64 %805, 0
  tail call void @llvm.assume(i1 %806) #7
  store i8* %803, i8** %686, align 8
  %807 = or i64 %793, 2
  %808 = mul i64 %795, %807
  %809 = getelementptr inbounds i8, i8* %794, i64 %808
  %810 = ptrtoint i8* %809 to i64
  %811 = and i64 %810, 63
  %812 = icmp eq i64 %811, 0
  tail call void @llvm.assume(i1 %812) #7
  store i8* %809, i8** %687, align 16
  %813 = or i64 %793, 3
  %814 = mul i64 %795, %813
  %815 = getelementptr inbounds i8, i8* %794, i64 %814
  %816 = ptrtoint i8* %815 to i64
  %817 = and i64 %816, 63
  %818 = icmp eq i64 %817, 0
  tail call void @llvm.assume(i1 %818) #7
  store i8* %815, i8** %688, align 8
  %819 = mul i64 %670, %792
  %820 = getelementptr inbounds float, float* %682, i64 %819
  %821 = add i64 %689, %793
  %822 = icmp eq i64 %821, 0
  %823 = select i1 %822, i64 2, i64 0
  %824 = add i64 %821, 4
  %825 = load i32, i32* %116, align 4
  %826 = zext i32 %825 to i64
  %827 = add nuw nsw i64 %826, 2
  %828 = icmp ugt i64 %824, %827
  %829 = bitcast i8* %797 to float*
  %830 = bitcast i8* %803 to float*
  %831 = bitcast i8* %809 to float*
  %832 = bitcast i8* %815 to float*
  br i1 %828, label %833, label %837

833:                                              ; preds = %791
  %834 = sub i64 2, %793
  %835 = sub i64 %834, %689
  %836 = add i64 %835, %826
  br label %837

837:                                              ; preds = %791, %833
  %838 = phi i64 [ %836, %833 ], [ 4, %791 ]
  %839 = sub i64 %838, %823
  %840 = icmp eq i64 %839, 4
  %841 = icmp ugt i64 %838, %823
  br label %845

842:                                              ; preds = %914
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %676) #7
  %843 = add nuw i64 %792, 1
  %844 = icmp eq i64 %843, %684
  br i1 %844, label %764, label %791

845:                                              ; preds = %914, %837
  %846 = phi i64 [ 0, %837 ], [ %917, %914 ]
  %847 = shl i64 %846, 2
  %848 = add i64 %690, %847
  %849 = icmp eq i64 %848, 0
  %850 = or i64 %847, 2
  %851 = select i1 %849, i64 %850, i64 %847
  %852 = add i64 %848, 4
  %853 = load i32, i32* %130, align 8
  %854 = zext i32 %853 to i64
  %855 = add nuw nsw i64 %854, 2
  %856 = icmp ugt i64 %852, %855
  %857 = add i64 %847, 4
  %858 = add i64 %691, %854
  %859 = select i1 %856, i64 %858, i64 %857
  %860 = sub i64 %859, %851
  %861 = icmp eq i64 %860, 4
  %862 = and i1 %840, %861
  br i1 %862, label %863, label %887

863:                                              ; preds = %845
  %864 = getelementptr inbounds float, float* %829, i64 %851
  %865 = bitcast float* %864 to <4 x float>*
  %866 = load <4 x float>, <4 x float>* %865, align 16, !alias.scope !144
  %867 = fadd <4 x float> %866, zeroinitializer
  %868 = getelementptr inbounds float, float* %830, i64 %851
  %869 = bitcast float* %868 to <4 x float>*
  %870 = load <4 x float>, <4 x float>* %869, align 16, !alias.scope !144
  %871 = fadd <4 x float> %867, %870
  %872 = getelementptr inbounds float, float* %831, i64 %851
  %873 = bitcast float* %872 to <4 x float>*
  %874 = load <4 x float>, <4 x float>* %873, align 16, !alias.scope !144
  %875 = fadd <4 x float> %871, %874
  %876 = getelementptr inbounds float, float* %832, i64 %851
  %877 = bitcast float* %876 to <4 x float>*
  %878 = load <4 x float>, <4 x float>* %877, align 16, !alias.scope !144
  %879 = fadd <4 x float> %875, %878
  %880 = shufflevector <4 x float> %879, <4 x float> undef, <4 x i32> <i32 2, i32 3, i32 0, i32 1>
  %881 = fadd <4 x float> %879, %880
  %882 = shufflevector <4 x float> %881, <4 x float> undef, <4 x i32> <i32 1, i32 2, i32 3, i32 0>
  %883 = fadd <4 x float> %881, %882
  %884 = tail call <4 x float> @llvm.sqrt.v4f32(<4 x float> %883) #7
  %885 = extractelement <4 x float> %884, i32 0
  %886 = fmul float %885, 2.500000e-01
  br label %914

887:                                              ; preds = %845
  br i1 %841, label %888, label %896

888:                                              ; preds = %887
  %889 = icmp ugt i64 %859, %851
  br label %890

890:                                              ; preds = %888, %902
  %891 = phi i64 [ %823, %888 ], [ %904, %902 ]
  %892 = phi float [ 0.000000e+00, %888 ], [ %903, %902 ]
  br i1 %889, label %893, label %902

893:                                              ; preds = %890
  %894 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 %891
  %895 = load float*, float** %894, align 8
  br label %906

896:                                              ; preds = %902, %887
  %897 = phi float [ 0.000000e+00, %887 ], [ %903, %902 ]
  %898 = mul i64 %860, %839
  %899 = uitofp i64 %898 to float
  %900 = fdiv float %897, %899
  %901 = tail call float @sqrtf(float %900) #7
  br label %914

902:                                              ; preds = %906, %890
  %903 = phi float [ %892, %890 ], [ %911, %906 ]
  %904 = add nuw i64 %891, 1
  %905 = icmp ult i64 %904, %838
  br i1 %905, label %890, label %896

906:                                              ; preds = %893, %906
  %907 = phi i64 [ %851, %893 ], [ %912, %906 ]
  %908 = phi float [ %892, %893 ], [ %911, %906 ]
  %909 = getelementptr inbounds float, float* %895, i64 %907
  %910 = load float, float* %909, align 4
  %911 = fadd float %908, %910
  %912 = add nuw i64 %907, 1
  %913 = icmp ult i64 %912, %859
  br i1 %913, label %906, label %902

914:                                              ; preds = %896, %863
  %915 = phi float [ %901, %896 ], [ %886, %863 ]
  %916 = getelementptr inbounds float, float* %820, i64 %846
  store float %915, float* %916, align 4
  %917 = add nuw i64 %846, 1
  %918 = icmp eq i64 %917, %683
  br i1 %918, label %842, label %845

919:                                              ; preds = %951
  store i64 %952, i64* %12, align 8
  br label %920

920:                                              ; preds = %919, %764
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %765) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %106) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %100) #7
  br label %1181

921:                                              ; preds = %767, %951
  %922 = phi i64 [ %790, %767 ], [ %952, %951 ]
  %923 = phi i64 [ %180, %767 ], [ %952, %951 ]
  %924 = load i8*, i8** %768, align 8
  %925 = load i64, i64* %769, align 8
  %926 = mul i64 %925, %923
  %927 = getelementptr inbounds i8, i8* %924, i64 %926
  %928 = ptrtoint i8* %927 to i64
  %929 = and i64 %928, 63
  %930 = icmp eq i64 %929, 0
  tail call void @llvm.assume(i1 %930) #7
  %931 = load i8*, i8** %770, align 8
  %932 = load i64, i64* %98, align 8
  %933 = mul i64 %932, %923
  %934 = getelementptr inbounds i8, i8* %931, i64 %933
  %935 = ptrtoint i8* %934 to i64
  %936 = and i64 %935, 63
  %937 = icmp eq i64 %936, 0
  tail call void @llvm.assume(i1 %937) #7
  %938 = load i8*, i8** %771, align 8
  %939 = load i64, i64* %772, align 8
  %940 = mul i64 %939, %923
  %941 = getelementptr inbounds i8, i8* %938, i64 %940
  %942 = ptrtoint i8* %941 to i64
  %943 = and i64 %942, 63
  %944 = icmp eq i64 %943, 0
  tail call void @llvm.assume(i1 %944) #7
  %945 = bitcast i8* %941 to float*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %773) #7
  store i64 %667, i64* %13, align 8
  br i1 %774, label %946, label %951

946:                                              ; preds = %921
  %947 = sub i64 %923, %180
  %948 = shl i64 %947, 1
  %949 = load i64, i64* %13, align 8
  br label %954

950:                                              ; preds = %1164
  store i64 %1165, i64* %13, align 8
  br label %951

951:                                              ; preds = %950, %921
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %773) #7
  %952 = add i64 %922, 1
  %953 = icmp ult i64 %952, %105
  br i1 %953, label %921, label %919

954:                                              ; preds = %946, %1164
  %955 = phi i64 [ %949, %946 ], [ %1165, %1164 ]
  %956 = phi i64 [ %667, %946 ], [ %1165, %1164 ]
  %957 = getelementptr inbounds i8, i8* %927, i64 %956
  %958 = load i8, i8* %957, align 1
  %959 = and i8 %958, 1
  %960 = icmp eq i8 %959, 0
  br i1 %960, label %1164, label %961

961:                                              ; preds = %954
  %962 = lshr i8 %958, 1
  %963 = getelementptr inbounds float, float* %945, i64 %956
  %964 = load float, float* %963, align 4
  %965 = fdiv float 1.000000e+00, %964
  %966 = zext i8 %962 to i64
  %967 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut, i64 0, i64 %966
  %968 = load i8, i8* %967, align 1
  %969 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %966
  %970 = sub i64 %956, %667
  %971 = shl i64 %970, 1
  %972 = zext i8 %968 to i64
  %973 = shl nuw nsw i64 %972, 1
  %974 = load i8, i8* %969, align 1
  %975 = zext i8 %974 to i64
  %976 = shl nuw nsw i64 %975, 1
  br label %977

977:                                              ; preds = %999, %961
  %978 = phi i64 [ 0, %961 ], [ %1000, %999 ]
  %979 = phi float [ 0.000000e+00, %961 ], [ %1010, %999 ]
  %980 = add i64 %948, %978
  %981 = mul i64 %980, %183
  br label %1002

982:                                              ; preds = %999
  %983 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %966
  %984 = load i8, i8* %983, align 1
  %985 = zext i8 %984 to i64
  %986 = shl nuw nsw i64 %972, 2
  %987 = mul nuw nsw i64 %986, %985
  %988 = uitofp i64 %987 to float
  %989 = fdiv float %1010, %988
  %990 = tail call float @sqrtf(float %989) #7
  %991 = sub i64 %956, %667
  %992 = shl i64 %991, 1
  %993 = fmul float %965, 6.250000e-02
  %994 = fpext float %990 to double
  %995 = fpext float %993 to double
  %996 = fmul double %995, 0x400A000006666666
  %997 = fadd double %996, %994
  %998 = fmul float %993, 0x3FB5C28F60000000
  br label %1013

999:                                              ; preds = %1002
  %1000 = add nuw nsw i64 %978, 1
  %1001 = icmp ult i64 %1000, %973
  br i1 %1001, label %977, label %982

1002:                                             ; preds = %977, %1002
  %1003 = phi i64 [ 0, %977 ], [ %1011, %1002 ]
  %1004 = phi float [ %979, %977 ], [ %1010, %1002 ]
  %1005 = add i64 %981, %1003
  %1006 = add i64 %1005, %971
  %1007 = getelementptr inbounds float, float* %192, i64 %1006
  %1008 = load float, float* %1007, align 4
  %1009 = fmul float %1008, %1008
  %1010 = fadd float %1004, %1009
  %1011 = add nuw nsw i64 %1003, 1
  %1012 = icmp ult i64 %1011, %976
  br i1 %1012, label %1002, label %999

1013:                                             ; preds = %982, %1026
  %1014 = phi i64 [ 0, %982 ], [ %1027, %1026 ]
  %1015 = shl nuw i64 %1014, 1
  %1016 = add i64 %948, %1015
  %1017 = mul i64 %1016, %183
  %1018 = or i64 %1015, 1
  %1019 = add i64 %948, %1018
  %1020 = mul i64 %1019, %183
  %1021 = mul i64 %670, %1019
  %1022 = mul i64 %670, %1016
  %1023 = add i64 %1016, 2
  %1024 = mul i64 %670, %1023
  %1025 = mul i64 %1014, %99
  br label %1029

1026:                                             ; preds = %1029
  %1027 = add nuw nsw i64 %1014, 1
  %1028 = icmp eq i64 %1027, %972
  br i1 %1028, label %1164, label %1013

1029:                                             ; preds = %1013, %1029
  %1030 = phi i64 [ 0, %1013 ], [ %1162, %1029 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %775)
  %1031 = shl nuw i64 %1030, 1
  %1032 = add i64 %992, %1031
  %1033 = add i64 %1032, %1017
  %1034 = getelementptr inbounds float, float* %192, i64 %1033
  %1035 = load float, float* %1034, align 8
  store float %1035, float* %14, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %776)
  %1036 = or i64 %1031, 1
  %1037 = add i64 %992, %1036
  %1038 = add i64 %1037, %1017
  %1039 = getelementptr inbounds float, float* %192, i64 %1038
  %1040 = load float, float* %1039, align 4
  store float %1040, float* %15, align 4
  %1041 = fcmp olt float %1040, %1035
  %1042 = select i1 %1041, float* %15, float* %14
  %1043 = bitcast float* %1042 to i32*
  %1044 = load i32, i32* %1043, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %776)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %775)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %777)
  %1045 = add i64 %1032, %1020
  %1046 = getelementptr inbounds float, float* %192, i64 %1045
  %1047 = load float, float* %1046, align 4
  store float %1047, float* %16, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %778)
  %1048 = add i64 %1037, %1020
  %1049 = getelementptr inbounds float, float* %192, i64 %1048
  %1050 = load float, float* %1049, align 4
  store float %1050, float* %17, align 4
  %1051 = fcmp olt float %1050, %1047
  %1052 = select i1 %1051, float* %17, float* %16
  %1053 = bitcast float* %1052 to i32*
  %1054 = load i32, i32* %1053, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %778)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %777)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %779)
  %1055 = bitcast i32 %1054 to float
  %1056 = bitcast i32 %1044 to float
  %1057 = fcmp olt float %1055, %1056
  %1058 = select i1 %1057, i32 %1054, i32 %1044
  store i32 %1058, i32* %18, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %780)
  %1059 = add i64 %1037, %1021
  %1060 = getelementptr inbounds float, float* %682, i64 %1059
  %1061 = load float, float* %1060, align 4
  store float %1061, float* %19, align 4
  %1062 = bitcast i32 %1058 to float
  %1063 = fcmp olt float %1061, %1062
  %1064 = select i1 %1063, float* %19, float* %781
  %1065 = bitcast float* %1064 to i32*
  %1066 = load i32, i32* %1065, align 4
  store i32 %1066, i32* %18, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %780)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %782)
  %1067 = add i64 %1032, %1022
  %1068 = getelementptr inbounds float, float* %682, i64 %1067
  %1069 = load float, float* %1068, align 8
  store float %1069, float* %20, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %783)
  %1070 = add i64 %1037, %1022
  %1071 = getelementptr inbounds float, float* %682, i64 %1070
  %1072 = load float, float* %1071, align 4
  store float %1072, float* %21, align 4
  %1073 = fcmp olt float %1072, %1069
  %1074 = select i1 %1073, float* %21, float* %20
  %1075 = bitcast float* %1074 to i32*
  %1076 = load i32, i32* %1075, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %783)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %782)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %784)
  %1077 = add nuw nsw i64 %1031, 2
  %1078 = add i64 %992, %1077
  %1079 = add i64 %1078, %1022
  %1080 = getelementptr inbounds float, float* %682, i64 %1079
  %1081 = load float, float* %1080, align 8
  store float %1081, float* %22, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %785)
  %1082 = add i64 %1032, %1021
  %1083 = getelementptr inbounds float, float* %682, i64 %1082
  %1084 = load float, float* %1083, align 4
  store float %1084, float* %23, align 4
  %1085 = fcmp olt float %1084, %1081
  %1086 = select i1 %1085, float* %23, float* %22
  %1087 = bitcast float* %1086 to i32*
  %1088 = load i32, i32* %1087, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %785)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %784)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %786)
  store float %1061, float* %24, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %787)
  %1089 = add i64 %1078, %1021
  %1090 = getelementptr inbounds float, float* %682, i64 %1089
  %1091 = load float, float* %1090, align 4
  store float %1091, float* %25, align 4
  %1092 = fcmp olt float %1091, %1061
  %1093 = select i1 %1092, float* %25, float* %24
  %1094 = bitcast float* %1093 to i32*
  %1095 = load i32, i32* %1094, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %787)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %786)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %788)
  %1096 = add i64 %1032, %1024
  %1097 = getelementptr inbounds float, float* %682, i64 %1096
  %1098 = load float, float* %1097, align 8
  store float %1098, float* %26, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %789)
  %1099 = add i64 %1037, %1024
  %1100 = getelementptr inbounds float, float* %682, i64 %1099
  %1101 = load float, float* %1100, align 4
  store float %1101, float* %27, align 4
  %1102 = fcmp olt float %1101, %1098
  %1103 = select i1 %1102, float* %27, float* %26
  %1104 = bitcast float* %1103 to i32*
  %1105 = load i32, i32* %1104, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %789)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %788)
  %1106 = bitcast i32 %1088 to float
  %1107 = bitcast i32 %1076 to float
  %1108 = fcmp olt float %1106, %1107
  %1109 = select i1 %1108, i32 %1088, i32 %1076
  %1110 = bitcast i32 %1105 to float
  %1111 = bitcast i32 %1095 to float
  %1112 = fcmp olt float %1110, %1111
  %1113 = select i1 %1112, i32 %1105, i32 %1095
  %1114 = bitcast i32 %1113 to float
  %1115 = bitcast i32 %1109 to float
  %1116 = fcmp olt float %1114, %1115
  %1117 = select i1 %1116, i32 %1113, i32 %1109
  %1118 = add i64 %1078, %1024
  %1119 = getelementptr inbounds float, float* %682, i64 %1118
  %1120 = load float, float* %1119, align 8
  %1121 = bitcast i32 %1117 to float
  %1122 = fcmp olt float %1120, %1121
  %1123 = bitcast i32 %1117 to float
  %1124 = select i1 %1122, float %1120, float %1123
  %1125 = bitcast i32 %1066 to float
  %1126 = fcmp olt float %1124, %1125
  %1127 = load float, float* %781, align 4
  %1128 = select i1 %1126, float %1124, float %1127
  %1129 = fmul float %1125, 1.250000e-01
  %1130 = fmul float %1128, 6.250000e-01
  %1131 = fmul float %1128, 1.500000e+00
  %1132 = fcmp olt float %1061, %1131
  %1133 = select i1 %1132, float %1061, float %1131
  %1134 = fmul float %1133, 1.250000e-01
  %1135 = fmul float %1124, 1.250000e-01
  %1136 = insertelement <2 x float> undef, float %1035, i32 0
  %1137 = insertelement <2 x float> %1136, float %1129, i32 1
  %1138 = insertelement <2 x float> undef, float %1040, i32 0
  %1139 = insertelement <2 x float> %1138, float %1130, i32 1
  %1140 = fadd <2 x float> %1137, %1139
  %1141 = insertelement <2 x float> undef, float %1047, i32 0
  %1142 = insertelement <2 x float> %1141, float %1134, i32 1
  %1143 = fadd <2 x float> %1140, %1142
  %1144 = insertelement <2 x float> undef, float %1050, i32 0
  %1145 = insertelement <2 x float> %1144, float %1135, i32 1
  %1146 = fadd <2 x float> %1143, %1145
  %1147 = extractelement <2 x float> %1146, i32 1
  %1148 = fadd float %993, %1147
  %1149 = fpext float %1148 to double
  %1150 = fdiv double %997, %1149
  %1151 = fptrunc double %1150 to float
  %1152 = fcmp ogt float %1151, 0x40099999A0000000
  %1153 = extractelement <2 x float> %1146, i32 0
  %1154 = fadd float %1153, %1147
  %1155 = fmul float %1154, 0x3FC99999A0000000
  %1156 = fcmp olt float %1155, %998
  %1157 = or i1 %1156, %1152
  %1158 = select i1 %1157, i8 4, i8 0
  %1159 = add i64 %1030, %1025
  %1160 = add i64 %1159, %956
  %1161 = getelementptr inbounds i8, i8* %934, i64 %1160
  store i8 %1158, i8* %1161, align 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %779)
  %1162 = add nuw nsw i64 %1030, 1
  %1163 = icmp ult i64 %1162, %985
  br i1 %1163, label %1029, label %1026

1164:                                             ; preds = %1026, %954
  %1165 = add i64 %955, 1
  %1166 = icmp ult i64 %1165, %111
  br i1 %1166, label %954, label %950

1167:                                             ; preds = %1184, %66
  %1168 = phi i64 [ 0, %66 ], [ %1185, %1184 ]
  %1169 = icmp eq i64 %70, 0
  br i1 %1169, label %1181, label %1170

1170:                                             ; preds = %1167
  %1171 = add i64 %1168, %60
  %1172 = load i8*, i8** %67, align 8
  %1173 = load i64, i64* %68, align 8
  %1174 = mul i64 %1173, %1171
  %1175 = getelementptr inbounds i8, i8* %1172, i64 %1174
  %1176 = ptrtoint i8* %1175 to i64
  %1177 = and i64 %1176, 63
  %1178 = icmp eq i64 %1177, 0
  tail call void @llvm.assume(i1 %1178) #7
  br i1 %69, label %1181, label %1179

1179:                                             ; preds = %1170
  %1180 = getelementptr inbounds i8, i8* %1175, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1180, i8 4, i64 %62, i1 false) #7
  br label %1181

1181:                                             ; preds = %1167, %1170, %1179, %56, %920
  ret void

1182:                                             ; preds = %87
  %1183 = getelementptr inbounds i8, i8* %93, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1183, i8 4, i64 %62, i1 false) #7
  br label %1184

1184:                                             ; preds = %1182, %87
  %1185 = add nuw i64 %75, 2
  %1186 = add i64 %76, -2
  %1187 = icmp eq i64 %1186, 0
  br i1 %1187, label %1167, label %74
}

; Function Attrs: nounwind ssp uwtable
define internal void @_ZN3jxl8N_SCALAR12_GLOBAL__N_111ProcessTileERKNS_6Image3IfEEPNS_18PassesEncoderStateERKNS_4RectEPNS_24ArControlFieldHeuristics10TempImagesE(%"class.jxl::Image3"* dereferenceable(96), %"struct.jxl::PassesEncoderState"* nocapture readonly, %"class.jxl::Rect"* nocapture readonly dereferenceable(32), %"struct.jxl::ArControlFieldHeuristics::TempImages"*) #0 {
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca float*, align 8
  %8 = alloca [3 x float*], align 16
  %9 = alloca [3 x float*], align 16
  %10 = alloca [3 x float*], align 16
  %11 = alloca [4 x float*], align 16
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca float, align 4
  %15 = alloca float, align 4
  %16 = alloca float, align 4
  %17 = alloca float, align 4
  %18 = alloca i32, align 4
  %19 = alloca float, align 4
  %20 = alloca float, align 4
  %21 = alloca float, align 4
  %22 = alloca float, align 4
  %23 = alloca float, align 4
  %24 = alloca float, align 4
  %25 = alloca float, align 4
  %26 = alloca float, align 4
  %27 = alloca float, align 4
  %28 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 0
  %29 = load i32, i32* %28, align 8
  %30 = zext i32 %29 to i64
  %31 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 8
  %32 = load i64, i64* %31, align 8
  %33 = icmp eq i64 %32, %30
  br i1 %33, label %34, label %41

34:                                               ; preds = %4
  %35 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 1
  %36 = load i32, i32* %35, align 4
  %37 = zext i32 %36 to i64
  %38 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 2, i32 9
  %39 = load i64, i64* %38, align 8
  %40 = icmp eq i64 %39, %37
  br i1 %40, label %44, label %41

41:                                               ; preds = %4, %34
  %42 = tail call zeroext i1 (i8*, ...) @_ZN3jxl5DebugEPKcz(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.1, i64 0, i64 0), i32 54, i8* getelementptr inbounds ([137 x i8], [137 x i8]* @.str.2, i64 0, i64 0)) #7
  %43 = tail call zeroext i1 @_ZN3jxl5AbortEv() #10
  unreachable

44:                                               ; preds = %34
  %45 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 0
  %46 = load float, float* %45, align 8
  %47 = fcmp olt float %46, 5.000000e-01
  br i1 %47, label %56, label %48

48:                                               ; preds = %44
  %49 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 6, i32 7
  %50 = load i32, i32* %49, align 4
  %51 = icmp sgt i32 %50, 4
  br i1 %51, label %56, label %52

52:                                               ; preds = %48
  %53 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 1, i32 26, i32 11
  %54 = load i32, i32* %53, align 4
  %55 = icmp eq i32 %54, 0
  br i1 %55, label %56, label %97

56:                                               ; preds = %52, %48, %44
  %57 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %58 = load i64, i64* %57, align 8
  %59 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %60 = load i64, i64* %59, align 8
  %61 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %62 = load i64, i64* %61, align 8
  %63 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %64 = load i64, i64* %63, align 8
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %1205, label %66

66:                                               ; preds = %56
  %67 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %68 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %69 = icmp eq i64 %62, 0
  %70 = and i64 %64, 1
  %71 = icmp eq i64 %64, 1
  br i1 %71, label %1191, label %72

72:                                               ; preds = %66
  %73 = sub i64 %64, %70
  br label %74

74:                                               ; preds = %1208, %72
  %75 = phi i64 [ 0, %72 ], [ %1209, %1208 ]
  %76 = phi i64 [ %73, %72 ], [ %1210, %1208 ]
  %77 = add i64 %75, %60
  %78 = load i8*, i8** %67, align 8
  %79 = load i64, i64* %68, align 8
  %80 = mul i64 %79, %77
  %81 = getelementptr inbounds i8, i8* %78, i64 %80
  %82 = ptrtoint i8* %81 to i64
  %83 = and i64 %82, 63
  %84 = icmp eq i64 %83, 0
  tail call void @llvm.assume(i1 %84) #7
  br i1 %69, label %87, label %85

85:                                               ; preds = %74
  %86 = getelementptr inbounds i8, i8* %81, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %86, i8 4, i64 %62, i1 false) #7
  br label %87

87:                                               ; preds = %85, %74
  %88 = or i64 %75, 1
  %89 = add i64 %88, %60
  %90 = load i8*, i8** %67, align 8
  %91 = load i64, i64* %68, align 8
  %92 = mul i64 %91, %89
  %93 = getelementptr inbounds i8, i8* %90, i64 %92
  %94 = ptrtoint i8* %93 to i64
  %95 = and i64 %94, 63
  %96 = icmp eq i64 %95, 0
  tail call void @llvm.assume(i1 %96) #7
  br i1 %69, label %1208, label %1206

97:                                               ; preds = %52
  %98 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 4
  %99 = load i64, i64* %98, align 8
  %100 = bitcast i64* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %100) #7
  %101 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 1
  %102 = load i64, i64* %101, align 8
  store i64 %102, i64* %5, align 8
  %103 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 3
  %104 = load i64, i64* %103, align 8
  %105 = add i64 %104, %102
  %106 = bitcast i64* %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %106) #7
  %107 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 0
  %108 = load i64, i64* %107, align 8
  store i64 %108, i64* %6, align 8
  %109 = getelementptr inbounds %"class.jxl::Rect", %"class.jxl::Rect"* %2, i64 0, i32 2
  %110 = load i64, i64* %109, align 8
  %111 = add i64 %110, %108
  tail call void @_ZN3jxl24ArControlFieldHeuristics10TempImages8InitOnceEv(%"struct.jxl::ArControlFieldHeuristics::TempImages"* %3)
  %112 = icmp eq i64 %102, 0
  %113 = select i1 %112, i64 2, i64 0
  %114 = shl i64 %105, 3
  %115 = or i64 %114, 4
  %116 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 1
  %117 = load i32, i32* %116, align 4
  %118 = zext i32 %117 to i64
  %119 = add nuw nsw i64 %118, 2
  %120 = icmp ugt i64 %115, %119
  %121 = shl i64 %104, 3
  %122 = or i64 %121, 4
  %123 = shl i64 %102, 3
  %124 = sub i64 %119, %123
  %125 = select i1 %120, i64 %124, i64 %122
  %126 = icmp eq i64 %108, 0
  %127 = select i1 %126, i64 2, i64 0
  %128 = shl i64 %111, 3
  %129 = or i64 %128, 4
  %130 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 0
  %131 = load i32, i32* %130, align 8
  %132 = zext i32 %131 to i64
  %133 = add nuw nsw i64 %132, 2
  %134 = icmp ugt i64 %129, %133
  %135 = shl i64 %110, 3
  %136 = or i64 %135, 4
  %137 = shl i64 %108, 3
  %138 = sub i64 %133, %137
  %139 = select i1 %134, i64 %138, i64 %136
  %140 = icmp ult i64 %113, %125
  br i1 %140, label %141, label %177

141:                                              ; preds = %97
  %142 = bitcast float** %7 to i8*
  %143 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %144 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %145 = bitcast float** %7 to i8**
  %146 = shl i64 %102, 3
  %147 = bitcast [3 x float*]* %8 to i8*
  %148 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 0
  %149 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 1
  %150 = getelementptr inbounds [3 x float*], [3 x float*]* %8, i64 0, i64 2
  %151 = bitcast [3 x float*]* %9 to i8*
  %152 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 0
  %153 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 1
  %154 = getelementptr inbounds [3 x float*], [3 x float*]* %9, i64 0, i64 2
  %155 = bitcast [3 x float*]* %10 to i8*
  %156 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 0
  %157 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 1
  %158 = getelementptr inbounds [3 x float*], [3 x float*]* %10, i64 0, i64 2
  %159 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 4
  %160 = shl i64 %108, 3
  %161 = or i64 %160, %127
  %162 = icmp ult i64 %161, 3
  %163 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %164 = bitcast [3 x float*]* %8 to i8**
  %165 = bitcast [3 x float*]* %9 to i8**
  %166 = bitcast [3 x float*]* %10 to i8**
  %167 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %168 = bitcast float** %149 to i8**
  %169 = bitcast float** %153 to i8**
  %170 = bitcast float** %157 to i8**
  %171 = getelementptr inbounds %"class.jxl::Image3", %"class.jxl::Image3"* %0, i64 0, i32 0, i64 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %172 = bitcast float** %150 to i8**
  %173 = bitcast float** %154 to i8**
  %174 = bitcast float** %158 to i8**
  br label %205

175:                                              ; preds = %629
  %176 = load i64, i64* %5, align 8
  br label %177

177:                                              ; preds = %175, %97
  %178 = phi i64 [ %176, %175 ], [ %102, %97 ]
  %179 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 4
  %180 = load i64, i64* %179, align 8
  %181 = lshr i64 %180, 2
  %182 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %183 = load i8*, i8** %182, align 8
  %184 = ptrtoint i8* %183 to i64
  %185 = and i64 %184, 63
  %186 = icmp eq i64 %185, 0
  tail call void @llvm.assume(i1 %186) #7
  %187 = sub i64 %105, %178
  %188 = and i64 %187, 9223372036854775807
  %189 = icmp eq i64 %188, 0
  %190 = bitcast i8* %183 to float*
  br i1 %189, label %191, label %196

191:                                              ; preds = %177
  %192 = load i64, i64* %6, align 8
  %193 = sub i64 %111, %192
  %194 = shl i64 %193, 1
  %195 = shl i64 %187, 1
  br label %634

196:                                              ; preds = %177
  %197 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %198 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %199 = load i64, i64* %6, align 8
  %200 = sub i64 %111, %199
  %201 = and i64 %200, 9223372036854775807
  %202 = icmp eq i64 %201, 0
  %203 = shl i64 %200, 1
  %204 = shl i64 %187, 1
  br label %662

205:                                              ; preds = %632, %141
  %206 = phi i32 [ %117, %141 ], [ %633, %632 ]
  %207 = phi i64 [ %113, %141 ], [ %630, %632 ]
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %142) #7
  %208 = load i8*, i8** %143, align 8
  %209 = load i64, i64* %144, align 8
  %210 = mul i64 %209, %207
  %211 = getelementptr inbounds i8, i8* %208, i64 %210
  %212 = ptrtoint i8* %211 to i64
  %213 = and i64 %212, 63
  %214 = icmp eq i64 %213, 0
  tail call void @llvm.assume(i1 %214) #7
  store i8* %211, i8** %145, align 8
  %215 = add i64 %146, %207
  %216 = add i64 %215, -2
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.start.p0i8(i64 24, i8* nonnull %155) #7
  %217 = icmp eq i64 %216, 0
  %218 = add i64 %215, -3
  %219 = select i1 %217, i64 0, i64 %218
  %220 = load i64, i64* %159, align 8
  %221 = mul i64 %220, %219
  %222 = mul i64 %220, %216
  %223 = add i64 %215, -1
  %224 = zext i32 %206 to i64
  %225 = icmp ult i64 %223, %224
  %226 = select i1 %225, i64 %223, i64 %216
  %227 = mul i64 %226, %220
  %228 = load i8*, i8** %163, align 8
  %229 = ptrtoint i8* %228 to i64
  %230 = and i64 %229, 63
  %231 = icmp eq i64 %230, 0
  tail call void @llvm.assume(i1 %231) #7
  %232 = getelementptr inbounds i8, i8* %228, i64 %221
  %233 = ptrtoint i8* %232 to i64
  %234 = and i64 %233, 63
  %235 = icmp eq i64 %234, 0
  tail call void @llvm.assume(i1 %235) #7
  store i8* %232, i8** %164, align 16
  %236 = getelementptr inbounds i8, i8* %228, i64 %222
  %237 = ptrtoint i8* %236 to i64
  %238 = and i64 %237, 63
  %239 = icmp eq i64 %238, 0
  tail call void @llvm.assume(i1 %239) #7
  store i8* %236, i8** %165, align 16
  %240 = getelementptr inbounds i8, i8* %228, i64 %227
  %241 = ptrtoint i8* %240 to i64
  %242 = and i64 %241, 63
  %243 = icmp eq i64 %242, 0
  tail call void @llvm.assume(i1 %243) #7
  store i8* %240, i8** %166, align 16
  %244 = load i8*, i8** %167, align 8
  %245 = ptrtoint i8* %244 to i64
  %246 = and i64 %245, 63
  %247 = icmp eq i64 %246, 0
  tail call void @llvm.assume(i1 %247) #7
  %248 = getelementptr inbounds i8, i8* %244, i64 %221
  %249 = ptrtoint i8* %248 to i64
  %250 = and i64 %249, 63
  %251 = icmp eq i64 %250, 0
  tail call void @llvm.assume(i1 %251) #7
  store i8* %248, i8** %168, align 8
  %252 = getelementptr inbounds i8, i8* %244, i64 %222
  %253 = ptrtoint i8* %252 to i64
  %254 = and i64 %253, 63
  %255 = icmp eq i64 %254, 0
  tail call void @llvm.assume(i1 %255) #7
  store i8* %252, i8** %169, align 8
  %256 = getelementptr inbounds i8, i8* %244, i64 %227
  %257 = ptrtoint i8* %256 to i64
  %258 = and i64 %257, 63
  %259 = icmp eq i64 %258, 0
  tail call void @llvm.assume(i1 %259) #7
  store i8* %256, i8** %170, align 8
  %260 = load i8*, i8** %171, align 8
  %261 = ptrtoint i8* %260 to i64
  %262 = and i64 %261, 63
  %263 = icmp eq i64 %262, 0
  tail call void @llvm.assume(i1 %263) #7
  %264 = getelementptr inbounds i8, i8* %260, i64 %221
  %265 = ptrtoint i8* %264 to i64
  %266 = and i64 %265, 63
  %267 = icmp eq i64 %266, 0
  tail call void @llvm.assume(i1 %267) #7
  store i8* %264, i8** %172, align 16
  %268 = getelementptr inbounds i8, i8* %260, i64 %222
  %269 = ptrtoint i8* %268 to i64
  %270 = and i64 %269, 63
  %271 = icmp eq i64 %270, 0
  tail call void @llvm.assume(i1 %271) #7
  store i8* %268, i8** %173, align 16
  %272 = getelementptr inbounds i8, i8* %260, i64 %227
  %273 = ptrtoint i8* %272 to i64
  %274 = and i64 %273, 63
  %275 = icmp eq i64 %274, 0
  tail call void @llvm.assume(i1 %275) #7
  store i8* %272, i8** %174, align 16
  %276 = bitcast i8* %236 to float*
  %277 = bitcast i8* %240 to float*
  %278 = bitcast i8* %232 to float*
  %279 = bitcast i8* %252 to float*
  %280 = bitcast i8* %256 to float*
  %281 = bitcast i8* %248 to float*
  %282 = bitcast i8* %268 to float*
  %283 = bitcast i8* %272 to float*
  %284 = bitcast i8* %264 to float*
  br i1 %162, label %285, label %287

285:                                              ; preds = %205
  %286 = load float*, float** %7, align 8
  br label %302

287:                                              ; preds = %302, %205
  %288 = phi i64 [ %127, %205 ], [ %405, %302 ]
  %289 = add i64 %288, 1
  %290 = icmp ugt i64 %289, %139
  br i1 %290, label %510, label %291

291:                                              ; preds = %287
  %292 = load float*, float** %7, align 8
  %293 = load float*, float** %152, align 16
  %294 = load float*, float** %148, align 16
  %295 = load float*, float** %156, align 16
  %296 = load float*, float** %153, align 8
  %297 = load float*, float** %149, align 8
  %298 = load float*, float** %157, align 8
  %299 = load float*, float** %154, align 16
  %300 = load float*, float** %150, align 16
  %301 = load float*, float** %158, align 16
  br label %408

302:                                              ; preds = %285, %302
  %303 = phi i64 [ %161, %285 ], [ %406, %302 ]
  %304 = phi i64 [ %127, %285 ], [ %405, %302 ]
  %305 = add nsw i64 %303, -2
  %306 = icmp eq i64 %305, 0
  %307 = add nuw nsw i64 %303, -3
  %308 = select i1 %306, i64 0, i64 %307
  %309 = add nsw i64 %303, -1
  %310 = load i32, i32* %130, align 8
  %311 = zext i32 %310 to i64
  %312 = icmp ult i64 %309, %311
  %313 = select i1 %312, i64 %309, i64 %305
  %314 = getelementptr inbounds float, float* %276, i64 %305
  %315 = load float, float* %314, align 4
  %316 = fmul float %315, 0x4011666660000000
  %317 = getelementptr inbounds float, float* %276, i64 %308
  %318 = load float, float* %317, align 4
  %319 = getelementptr inbounds float, float* %276, i64 %313
  %320 = load float, float* %319, align 4
  %321 = fadd float %318, %320
  %322 = getelementptr inbounds float, float* %277, i64 %308
  %323 = load float, float* %322, align 4
  %324 = fadd float %321, %323
  %325 = getelementptr inbounds float, float* %277, i64 %305
  %326 = load float, float* %325, align 4
  %327 = fadd float %324, %326
  %328 = getelementptr inbounds float, float* %277, i64 %313
  %329 = load float, float* %328, align 4
  %330 = fadd float %327, %329
  %331 = getelementptr inbounds float, float* %278, i64 %308
  %332 = load float, float* %331, align 4
  %333 = fadd float %330, %332
  %334 = getelementptr inbounds float, float* %278, i64 %305
  %335 = load float, float* %334, align 4
  %336 = fadd float %333, %335
  %337 = getelementptr inbounds float, float* %278, i64 %313
  %338 = load float, float* %337, align 4
  %339 = fadd float %336, %338
  %340 = fmul float %339, 0x3FE1666660000000
  %341 = fsub float %316, %340
  %342 = fmul float %341, %341
  %343 = fadd float %342, 0.000000e+00
  %344 = getelementptr inbounds float, float* %279, i64 %305
  %345 = load float, float* %344, align 4
  %346 = fmul float %345, 0x4011666660000000
  %347 = getelementptr inbounds float, float* %279, i64 %308
  %348 = load float, float* %347, align 4
  %349 = getelementptr inbounds float, float* %279, i64 %313
  %350 = load float, float* %349, align 4
  %351 = fadd float %348, %350
  %352 = getelementptr inbounds float, float* %280, i64 %308
  %353 = load float, float* %352, align 4
  %354 = fadd float %351, %353
  %355 = getelementptr inbounds float, float* %280, i64 %305
  %356 = load float, float* %355, align 4
  %357 = fadd float %354, %356
  %358 = getelementptr inbounds float, float* %280, i64 %313
  %359 = load float, float* %358, align 4
  %360 = fadd float %357, %359
  %361 = getelementptr inbounds float, float* %281, i64 %308
  %362 = load float, float* %361, align 4
  %363 = fadd float %360, %362
  %364 = getelementptr inbounds float, float* %281, i64 %305
  %365 = load float, float* %364, align 4
  %366 = fadd float %363, %365
  %367 = getelementptr inbounds float, float* %281, i64 %313
  %368 = load float, float* %367, align 4
  %369 = fadd float %366, %368
  %370 = fmul float %369, 0x3FE1666660000000
  %371 = fsub float %346, %370
  %372 = fmul float %371, %371
  %373 = fadd float %343, %372
  %374 = getelementptr inbounds float, float* %282, i64 %305
  %375 = load float, float* %374, align 4
  %376 = fmul float %375, 0x3FD25E3540000000
  %377 = getelementptr inbounds float, float* %282, i64 %308
  %378 = load float, float* %377, align 4
  %379 = getelementptr inbounds float, float* %282, i64 %313
  %380 = load float, float* %379, align 4
  %381 = fadd float %378, %380
  %382 = getelementptr inbounds float, float* %283, i64 %308
  %383 = load float, float* %382, align 4
  %384 = fadd float %381, %383
  %385 = getelementptr inbounds float, float* %283, i64 %305
  %386 = load float, float* %385, align 4
  %387 = fadd float %384, %386
  %388 = getelementptr inbounds float, float* %283, i64 %313
  %389 = load float, float* %388, align 4
  %390 = fadd float %387, %389
  %391 = getelementptr inbounds float, float* %284, i64 %308
  %392 = load float, float* %391, align 4
  %393 = fadd float %390, %392
  %394 = getelementptr inbounds float, float* %284, i64 %305
  %395 = load float, float* %394, align 4
  %396 = fadd float %393, %395
  %397 = getelementptr inbounds float, float* %284, i64 %313
  %398 = load float, float* %397, align 4
  %399 = fadd float %396, %398
  %400 = fmul float %399, 0x3FA25E3540000000
  %401 = fsub float %376, %400
  %402 = fmul float %401, %401
  %403 = fadd float %373, %402
  %404 = getelementptr inbounds float, float* %286, i64 %304
  store float %403, float* %404, align 4
  %405 = add nuw nsw i64 %304, 1
  %406 = add i64 %160, %405
  %407 = icmp ult i64 %406, 3
  br i1 %407, label %302, label %287

408:                                              ; preds = %291, %415
  %409 = phi i64 [ %289, %291 ], [ %508, %415 ]
  %410 = phi i64 [ %288, %291 ], [ %409, %415 ]
  %411 = add i64 %160, %410
  %412 = load i32, i32* %130, align 8
  %413 = zext i32 %412 to i64
  %414 = icmp ugt i64 %411, %413
  br i1 %414, label %510, label %415

415:                                              ; preds = %408
  %416 = add i64 %411, -2
  %417 = getelementptr inbounds float, float* %293, i64 %416
  %418 = load float, float* %417, align 4, !alias.scope !147
  %419 = fmul float %418, 0x4011666660000000
  %420 = getelementptr inbounds float, float* %417, i64 -1
  %421 = load float, float* %420, align 4, !alias.scope !152
  %422 = getelementptr inbounds float, float* %417, i64 1
  %423 = load float, float* %422, align 4, !alias.scope !157
  %424 = getelementptr inbounds float, float* %294, i64 %416
  %425 = getelementptr inbounds float, float* %424, i64 -1
  %426 = load float, float* %425, align 4, !alias.scope !162
  %427 = load float, float* %424, align 4, !alias.scope !167
  %428 = getelementptr inbounds float, float* %424, i64 1
  %429 = load float, float* %428, align 4, !alias.scope !172
  %430 = fadd float %421, %429
  %431 = getelementptr inbounds float, float* %295, i64 %416
  %432 = getelementptr inbounds float, float* %431, i64 -1
  %433 = load float, float* %432, align 4, !alias.scope !177
  %434 = fadd float %423, %433
  %435 = load float, float* %431, align 4, !alias.scope !182
  %436 = fadd float %426, %435
  %437 = getelementptr inbounds float, float* %431, i64 1
  %438 = load float, float* %437, align 4, !alias.scope !187
  %439 = fadd float %427, %438
  %440 = fadd float %430, %434
  %441 = fadd float %436, %439
  %442 = fadd float %440, %441
  %443 = fmul float %442, 0xBFE1666660000000
  %444 = fadd float %419, %443
  %445 = fmul float %444, %444
  %446 = fadd float %445, 0.000000e+00
  %447 = getelementptr inbounds float, float* %296, i64 %416
  %448 = load float, float* %447, align 4, !alias.scope !147
  %449 = fmul float %448, 0x4011666660000000
  %450 = getelementptr inbounds float, float* %447, i64 -1
  %451 = load float, float* %450, align 4, !alias.scope !152
  %452 = getelementptr inbounds float, float* %447, i64 1
  %453 = load float, float* %452, align 4, !alias.scope !157
  %454 = getelementptr inbounds float, float* %297, i64 %416
  %455 = getelementptr inbounds float, float* %454, i64 -1
  %456 = load float, float* %455, align 4, !alias.scope !162
  %457 = load float, float* %454, align 4, !alias.scope !167
  %458 = getelementptr inbounds float, float* %454, i64 1
  %459 = load float, float* %458, align 4, !alias.scope !172
  %460 = fadd float %451, %459
  %461 = getelementptr inbounds float, float* %298, i64 %416
  %462 = getelementptr inbounds float, float* %461, i64 -1
  %463 = load float, float* %462, align 4, !alias.scope !177
  %464 = fadd float %453, %463
  %465 = load float, float* %461, align 4, !alias.scope !182
  %466 = fadd float %456, %465
  %467 = getelementptr inbounds float, float* %461, i64 1
  %468 = load float, float* %467, align 4, !alias.scope !187
  %469 = fadd float %457, %468
  %470 = fadd float %460, %464
  %471 = fadd float %466, %469
  %472 = fadd float %470, %471
  %473 = fmul float %472, 0xBFE1666660000000
  %474 = fadd float %449, %473
  %475 = fmul float %474, %474
  %476 = fadd float %446, %475
  %477 = getelementptr inbounds float, float* %299, i64 %416
  %478 = load float, float* %477, align 4, !alias.scope !147
  %479 = fmul float %478, 0x3FD25E3540000000
  %480 = getelementptr inbounds float, float* %477, i64 -1
  %481 = load float, float* %480, align 4, !alias.scope !152
  %482 = getelementptr inbounds float, float* %477, i64 1
  %483 = load float, float* %482, align 4, !alias.scope !157
  %484 = getelementptr inbounds float, float* %300, i64 %416
  %485 = getelementptr inbounds float, float* %484, i64 -1
  %486 = load float, float* %485, align 4, !alias.scope !162
  %487 = load float, float* %484, align 4, !alias.scope !167
  %488 = getelementptr inbounds float, float* %484, i64 1
  %489 = load float, float* %488, align 4, !alias.scope !172
  %490 = fadd float %481, %489
  %491 = getelementptr inbounds float, float* %301, i64 %416
  %492 = getelementptr inbounds float, float* %491, i64 -1
  %493 = load float, float* %492, align 4, !alias.scope !177
  %494 = fadd float %483, %493
  %495 = load float, float* %491, align 4, !alias.scope !182
  %496 = fadd float %486, %495
  %497 = getelementptr inbounds float, float* %491, i64 1
  %498 = load float, float* %497, align 4, !alias.scope !187
  %499 = fadd float %487, %498
  %500 = fadd float %490, %494
  %501 = fadd float %496, %499
  %502 = fadd float %500, %501
  %503 = fmul float %502, 0xBFA25E3540000000
  %504 = fadd float %479, %503
  %505 = fmul float %504, %504
  %506 = fadd float %476, %505
  %507 = getelementptr inbounds float, float* %292, i64 %410
  store float %506, float* %507, align 4, !alias.scope !192
  %508 = add i64 %409, 1
  %509 = icmp ugt i64 %508, %139
  br i1 %509, label %510, label %408

510:                                              ; preds = %415, %408, %287
  %511 = phi i64 [ %288, %287 ], [ %410, %408 ], [ %409, %415 ]
  %512 = icmp ult i64 %511, %139
  br i1 %512, label %513, label %629

513:                                              ; preds = %510
  %514 = load float*, float** %152, align 16
  %515 = load float*, float** %156, align 16
  %516 = load float*, float** %148, align 16
  %517 = load float*, float** %153, align 8
  %518 = load float*, float** %157, align 8
  %519 = load float*, float** %149, align 8
  %520 = load float*, float** %154, align 16
  %521 = load float*, float** %158, align 16
  %522 = load float*, float** %150, align 16
  %523 = load float*, float** %7, align 8
  br label %524

524:                                              ; preds = %513, %524
  %525 = phi i64 [ %511, %513 ], [ %627, %524 ]
  %526 = add i64 %160, %525
  %527 = add i64 %526, -2
  %528 = icmp eq i64 %527, 0
  %529 = add i64 %526, -3
  %530 = select i1 %528, i64 0, i64 %529
  %531 = add i64 %526, -1
  %532 = load i32, i32* %130, align 8
  %533 = zext i32 %532 to i64
  %534 = icmp ult i64 %531, %533
  %535 = select i1 %534, i64 %531, i64 %527
  %536 = getelementptr inbounds float, float* %514, i64 %527
  %537 = load float, float* %536, align 4
  %538 = fmul float %537, 0x4011666660000000
  %539 = getelementptr inbounds float, float* %514, i64 %530
  %540 = load float, float* %539, align 4
  %541 = getelementptr inbounds float, float* %514, i64 %535
  %542 = load float, float* %541, align 4
  %543 = fadd float %540, %542
  %544 = getelementptr inbounds float, float* %515, i64 %530
  %545 = load float, float* %544, align 4
  %546 = fadd float %543, %545
  %547 = getelementptr inbounds float, float* %515, i64 %527
  %548 = load float, float* %547, align 4
  %549 = fadd float %546, %548
  %550 = getelementptr inbounds float, float* %515, i64 %535
  %551 = load float, float* %550, align 4
  %552 = fadd float %549, %551
  %553 = getelementptr inbounds float, float* %516, i64 %530
  %554 = load float, float* %553, align 4
  %555 = fadd float %552, %554
  %556 = getelementptr inbounds float, float* %516, i64 %527
  %557 = load float, float* %556, align 4
  %558 = fadd float %555, %557
  %559 = getelementptr inbounds float, float* %516, i64 %535
  %560 = load float, float* %559, align 4
  %561 = fadd float %558, %560
  %562 = fmul float %561, 0x3FE1666660000000
  %563 = fsub float %538, %562
  %564 = fmul float %563, %563
  %565 = fadd float %564, 0.000000e+00
  %566 = getelementptr inbounds float, float* %517, i64 %527
  %567 = load float, float* %566, align 4
  %568 = fmul float %567, 0x4011666660000000
  %569 = getelementptr inbounds float, float* %517, i64 %530
  %570 = load float, float* %569, align 4
  %571 = getelementptr inbounds float, float* %517, i64 %535
  %572 = load float, float* %571, align 4
  %573 = fadd float %570, %572
  %574 = getelementptr inbounds float, float* %518, i64 %530
  %575 = load float, float* %574, align 4
  %576 = fadd float %573, %575
  %577 = getelementptr inbounds float, float* %518, i64 %527
  %578 = load float, float* %577, align 4
  %579 = fadd float %576, %578
  %580 = getelementptr inbounds float, float* %518, i64 %535
  %581 = load float, float* %580, align 4
  %582 = fadd float %579, %581
  %583 = getelementptr inbounds float, float* %519, i64 %530
  %584 = load float, float* %583, align 4
  %585 = fadd float %582, %584
  %586 = getelementptr inbounds float, float* %519, i64 %527
  %587 = load float, float* %586, align 4
  %588 = fadd float %585, %587
  %589 = getelementptr inbounds float, float* %519, i64 %535
  %590 = load float, float* %589, align 4
  %591 = fadd float %588, %590
  %592 = fmul float %591, 0x3FE1666660000000
  %593 = fsub float %568, %592
  %594 = fmul float %593, %593
  %595 = fadd float %565, %594
  %596 = getelementptr inbounds float, float* %520, i64 %527
  %597 = load float, float* %596, align 4
  %598 = fmul float %597, 0x3FD25E3540000000
  %599 = getelementptr inbounds float, float* %520, i64 %530
  %600 = load float, float* %599, align 4
  %601 = getelementptr inbounds float, float* %520, i64 %535
  %602 = load float, float* %601, align 4
  %603 = fadd float %600, %602
  %604 = getelementptr inbounds float, float* %521, i64 %530
  %605 = load float, float* %604, align 4
  %606 = fadd float %603, %605
  %607 = getelementptr inbounds float, float* %521, i64 %527
  %608 = load float, float* %607, align 4
  %609 = fadd float %606, %608
  %610 = getelementptr inbounds float, float* %521, i64 %535
  %611 = load float, float* %610, align 4
  %612 = fadd float %609, %611
  %613 = getelementptr inbounds float, float* %522, i64 %530
  %614 = load float, float* %613, align 4
  %615 = fadd float %612, %614
  %616 = getelementptr inbounds float, float* %522, i64 %527
  %617 = load float, float* %616, align 4
  %618 = fadd float %615, %617
  %619 = getelementptr inbounds float, float* %522, i64 %535
  %620 = load float, float* %619, align 4
  %621 = fadd float %618, %620
  %622 = fmul float %621, 0x3FA25E3540000000
  %623 = fsub float %598, %622
  %624 = fmul float %623, %623
  %625 = fadd float %595, %624
  %626 = getelementptr inbounds float, float* %523, i64 %525
  store float %625, float* %626, align 4
  %627 = add nuw i64 %525, 1
  %628 = icmp ult i64 %627, %139
  br i1 %628, label %524, label %629

629:                                              ; preds = %524, %510
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %155) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %151) #7
  call void @llvm.lifetime.end.p0i8(i64 24, i8* nonnull %147) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %142) #7
  %630 = add nuw i64 %207, 1
  %631 = icmp ult i64 %630, %125
  br i1 %631, label %632, label %175

632:                                              ; preds = %629
  %633 = load i32, i32* %116, align 4
  br label %205

634:                                              ; preds = %758, %191
  %635 = phi i64 [ %195, %191 ], [ %204, %758 ]
  %636 = phi i64 [ %194, %191 ], [ %203, %758 ]
  %637 = phi i64 [ %192, %191 ], [ %199, %758 ]
  %638 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 4
  %639 = load i64, i64* %638, align 8
  %640 = lshr i64 %639, 2
  %641 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 2, i32 0, i32 5, i32 0, i32 0, i32 0
  %642 = load i8*, i8** %641, align 8
  %643 = ptrtoint i8* %642 to i64
  %644 = and i64 %643, 63
  %645 = icmp eq i64 %644, 0
  tail call void @llvm.assume(i1 %645) #7
  %646 = bitcast [4 x float*]* %11 to i8*
  %647 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 1
  %648 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 2
  %649 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 3
  %650 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %651 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %3, i64 0, i32 0, i32 0, i32 4
  %652 = bitcast i8* %642 to float*
  %653 = or i64 %636, 1
  %654 = or i64 %635, 1
  %655 = bitcast [4 x float*]* %11 to i8**
  %656 = bitcast float** %647 to i8**
  %657 = bitcast float** %648 to i8**
  %658 = bitcast float** %649 to i8**
  %659 = shl i64 %178, 3
  %660 = shl i64 %637, 3
  %661 = sub i64 2, %660
  br label %788

662:                                              ; preds = %196, %758
  %663 = phi i64 [ 0, %196 ], [ %759, %758 ]
  %664 = shl i64 %663, 2
  %665 = or i64 %664, 2
  %666 = load i8*, i8** %197, align 8
  %667 = load i64, i64* %198, align 8
  %668 = mul i64 %667, %665
  %669 = getelementptr inbounds i8, i8* %666, i64 %668
  %670 = ptrtoint i8* %669 to i64
  %671 = and i64 %670, 63
  %672 = icmp eq i64 %671, 0
  tail call void @llvm.assume(i1 %672) #7
  %673 = or i64 %664, 3
  %674 = mul i64 %667, %673
  %675 = getelementptr inbounds i8, i8* %666, i64 %674
  %676 = ptrtoint i8* %675 to i64
  %677 = and i64 %676, 63
  %678 = icmp eq i64 %677, 0
  tail call void @llvm.assume(i1 %678) #7
  %679 = add i64 %665, 2
  %680 = mul i64 %667, %679
  %681 = getelementptr inbounds i8, i8* %666, i64 %680
  %682 = ptrtoint i8* %681 to i64
  %683 = and i64 %682, 63
  %684 = icmp eq i64 %683, 0
  tail call void @llvm.assume(i1 %684) #7
  %685 = add i64 %665, 3
  %686 = mul i64 %667, %685
  %687 = getelementptr inbounds i8, i8* %666, i64 %686
  %688 = ptrtoint i8* %687 to i64
  %689 = and i64 %688, 63
  %690 = icmp eq i64 %689, 0
  tail call void @llvm.assume(i1 %690) #7
  %691 = mul i64 %181, %663
  %692 = getelementptr inbounds float, float* %190, i64 %691
  br i1 %202, label %758, label %693

693:                                              ; preds = %662
  %694 = getelementptr inbounds i8, i8* %669, i64 8
  %695 = bitcast i8* %694 to float*
  %696 = getelementptr inbounds i8, i8* %675, i64 8
  %697 = bitcast i8* %696 to float*
  %698 = getelementptr inbounds i8, i8* %681, i64 8
  %699 = bitcast i8* %698 to float*
  %700 = getelementptr inbounds i8, i8* %687, i64 8
  %701 = bitcast i8* %700 to float*
  br label %702

702:                                              ; preds = %693, %702
  %703 = phi i64 [ %756, %702 ], [ 0, %693 ]
  %704 = shl i64 %703, 2
  %705 = getelementptr inbounds float, float* %695, i64 %704
  %706 = load float, float* %705, align 8, !alias.scope !197
  %707 = fadd float %706, 0.000000e+00
  %708 = getelementptr inbounds float, float* %705, i64 1
  %709 = load float, float* %708, align 4, !alias.scope !197
  %710 = fadd float %707, %709
  %711 = getelementptr inbounds float, float* %705, i64 2
  %712 = load float, float* %711, align 16, !alias.scope !197
  %713 = fadd float %710, %712
  %714 = getelementptr inbounds float, float* %705, i64 3
  %715 = load float, float* %714, align 4, !alias.scope !197
  %716 = fadd float %713, %715
  %717 = getelementptr inbounds float, float* %697, i64 %704
  %718 = load float, float* %717, align 8, !alias.scope !197
  %719 = fadd float %716, %718
  %720 = getelementptr inbounds float, float* %717, i64 1
  %721 = load float, float* %720, align 4, !alias.scope !197
  %722 = fadd float %719, %721
  %723 = getelementptr inbounds float, float* %717, i64 2
  %724 = load float, float* %723, align 16, !alias.scope !197
  %725 = fadd float %722, %724
  %726 = getelementptr inbounds float, float* %717, i64 3
  %727 = load float, float* %726, align 4, !alias.scope !197
  %728 = fadd float %725, %727
  %729 = getelementptr inbounds float, float* %699, i64 %704
  %730 = load float, float* %729, align 8, !alias.scope !197
  %731 = fadd float %728, %730
  %732 = getelementptr inbounds float, float* %729, i64 1
  %733 = load float, float* %732, align 4, !alias.scope !197
  %734 = fadd float %731, %733
  %735 = getelementptr inbounds float, float* %729, i64 2
  %736 = load float, float* %735, align 16, !alias.scope !197
  %737 = fadd float %734, %736
  %738 = getelementptr inbounds float, float* %729, i64 3
  %739 = load float, float* %738, align 4, !alias.scope !197
  %740 = fadd float %737, %739
  %741 = getelementptr inbounds float, float* %701, i64 %704
  %742 = load float, float* %741, align 8, !alias.scope !197
  %743 = fadd float %740, %742
  %744 = getelementptr inbounds float, float* %741, i64 1
  %745 = load float, float* %744, align 4, !alias.scope !197
  %746 = fadd float %743, %745
  %747 = getelementptr inbounds float, float* %741, i64 2
  %748 = load float, float* %747, align 16, !alias.scope !197
  %749 = fadd float %746, %748
  %750 = getelementptr inbounds float, float* %741, i64 3
  %751 = load float, float* %750, align 4, !alias.scope !197
  %752 = fadd float %749, %751
  %753 = tail call float @sqrtf(float %752) #7
  %754 = fmul float %753, 2.500000e-01
  %755 = getelementptr inbounds float, float* %692, i64 %703
  store float %754, float* %755, align 4
  %756 = add nuw i64 %703, 1
  %757 = icmp ult i64 %756, %203
  br i1 %757, label %702, label %758

758:                                              ; preds = %702, %662
  %759 = add nuw i64 %663, 1
  %760 = icmp ult i64 %759, %204
  br i1 %760, label %662, label %634

761:                                              ; preds = %839
  %762 = bitcast i64* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %762) #7
  store i64 %178, i64* %12, align 8
  %763 = icmp ugt i64 %105, %178
  br i1 %763, label %764, label %944

764:                                              ; preds = %761
  %765 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %766 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 3, i32 0, i32 0, i32 4
  %767 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 0, i32 7, i32 0, i32 5, i32 0, i32 0, i32 0
  %768 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 5, i32 0, i32 0, i32 0
  %769 = getelementptr inbounds %"struct.jxl::PassesEncoderState", %"struct.jxl::PassesEncoderState"* %1, i64 0, i32 1, i32 0, i32 4
  %770 = bitcast i64* %13 to i8*
  %771 = icmp ult i64 %637, %111
  %772 = bitcast float* %14 to i8*
  %773 = bitcast float* %15 to i8*
  %774 = bitcast float* %16 to i8*
  %775 = bitcast float* %17 to i8*
  %776 = bitcast i32* %18 to i8*
  %777 = bitcast float* %19 to i8*
  %778 = bitcast i32* %18 to float*
  %779 = bitcast float* %20 to i8*
  %780 = bitcast float* %21 to i8*
  %781 = bitcast float* %22 to i8*
  %782 = bitcast float* %23 to i8*
  %783 = bitcast float* %24 to i8*
  %784 = bitcast float* %25 to i8*
  %785 = bitcast float* %26 to i8*
  %786 = bitcast float* %27 to i8*
  %787 = load i64, i64* %12, align 8
  br label %945

788:                                              ; preds = %839, %634
  %789 = phi i64 [ 0, %634 ], [ %840, %839 ]
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %646) #7
  %790 = shl i64 %789, 2
  %791 = load i8*, i8** %650, align 8
  %792 = load i64, i64* %651, align 8
  %793 = mul i64 %792, %790
  %794 = getelementptr inbounds i8, i8* %791, i64 %793
  %795 = ptrtoint i8* %794 to i64
  %796 = and i64 %795, 63
  %797 = icmp eq i64 %796, 0
  tail call void @llvm.assume(i1 %797) #7
  store i8* %794, i8** %655, align 16
  %798 = or i64 %790, 1
  %799 = mul i64 %792, %798
  %800 = getelementptr inbounds i8, i8* %791, i64 %799
  %801 = ptrtoint i8* %800 to i64
  %802 = and i64 %801, 63
  %803 = icmp eq i64 %802, 0
  tail call void @llvm.assume(i1 %803) #7
  store i8* %800, i8** %656, align 8
  %804 = or i64 %790, 2
  %805 = mul i64 %792, %804
  %806 = getelementptr inbounds i8, i8* %791, i64 %805
  %807 = ptrtoint i8* %806 to i64
  %808 = and i64 %807, 63
  %809 = icmp eq i64 %808, 0
  tail call void @llvm.assume(i1 %809) #7
  store i8* %806, i8** %657, align 16
  %810 = or i64 %790, 3
  %811 = mul i64 %792, %810
  %812 = getelementptr inbounds i8, i8* %791, i64 %811
  %813 = ptrtoint i8* %812 to i64
  %814 = and i64 %813, 63
  %815 = icmp eq i64 %814, 0
  tail call void @llvm.assume(i1 %815) #7
  store i8* %812, i8** %658, align 8
  %816 = mul i64 %640, %789
  %817 = getelementptr inbounds float, float* %652, i64 %816
  %818 = add i64 %659, %790
  %819 = icmp eq i64 %818, 0
  %820 = select i1 %819, i64 2, i64 0
  %821 = add i64 %818, 4
  %822 = load i32, i32* %116, align 4
  %823 = zext i32 %822 to i64
  %824 = add nuw nsw i64 %823, 2
  %825 = icmp ugt i64 %821, %824
  %826 = bitcast i8* %794 to float*
  %827 = bitcast i8* %800 to float*
  %828 = bitcast i8* %806 to float*
  %829 = bitcast i8* %812 to float*
  br i1 %825, label %830, label %834

830:                                              ; preds = %788
  %831 = sub i64 2, %790
  %832 = sub i64 %831, %659
  %833 = add i64 %832, %823
  br label %834

834:                                              ; preds = %788, %830
  %835 = phi i64 [ %833, %830 ], [ 4, %788 ]
  %836 = sub i64 %835, %820
  %837 = icmp eq i64 %836, 4
  %838 = icmp ugt i64 %835, %820
  br label %842

839:                                              ; preds = %938
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %646) #7
  %840 = add nuw i64 %789, 1
  %841 = icmp eq i64 %840, %654
  br i1 %841, label %761, label %788

842:                                              ; preds = %938, %834
  %843 = phi i64 [ 0, %834 ], [ %941, %938 ]
  %844 = shl i64 %843, 2
  %845 = add i64 %660, %844
  %846 = icmp eq i64 %845, 0
  %847 = or i64 %844, 2
  %848 = select i1 %846, i64 %847, i64 %844
  %849 = add i64 %845, 4
  %850 = load i32, i32* %130, align 8
  %851 = zext i32 %850 to i64
  %852 = add nuw nsw i64 %851, 2
  %853 = icmp ugt i64 %849, %852
  %854 = add i64 %844, 4
  %855 = add i64 %661, %851
  %856 = select i1 %853, i64 %855, i64 %854
  %857 = sub i64 %856, %848
  %858 = icmp eq i64 %857, 4
  %859 = and i1 %837, %858
  br i1 %859, label %860, label %911

860:                                              ; preds = %842
  %861 = getelementptr inbounds float, float* %826, i64 %848
  %862 = load float, float* %861, align 8, !alias.scope !202
  %863 = fadd float %862, 0.000000e+00
  %864 = getelementptr inbounds float, float* %861, i64 1
  %865 = load float, float* %864, align 4, !alias.scope !202
  %866 = fadd float %863, %865
  %867 = getelementptr inbounds float, float* %861, i64 2
  %868 = load float, float* %867, align 8, !alias.scope !202
  %869 = fadd float %866, %868
  %870 = getelementptr inbounds float, float* %861, i64 3
  %871 = load float, float* %870, align 4, !alias.scope !202
  %872 = fadd float %869, %871
  %873 = getelementptr inbounds float, float* %827, i64 %848
  %874 = load float, float* %873, align 8, !alias.scope !202
  %875 = fadd float %872, %874
  %876 = getelementptr inbounds float, float* %873, i64 1
  %877 = load float, float* %876, align 4, !alias.scope !202
  %878 = fadd float %875, %877
  %879 = getelementptr inbounds float, float* %873, i64 2
  %880 = load float, float* %879, align 8, !alias.scope !202
  %881 = fadd float %878, %880
  %882 = getelementptr inbounds float, float* %873, i64 3
  %883 = load float, float* %882, align 4, !alias.scope !202
  %884 = fadd float %881, %883
  %885 = getelementptr inbounds float, float* %828, i64 %848
  %886 = load float, float* %885, align 8, !alias.scope !202
  %887 = fadd float %884, %886
  %888 = getelementptr inbounds float, float* %885, i64 1
  %889 = load float, float* %888, align 4, !alias.scope !202
  %890 = fadd float %887, %889
  %891 = getelementptr inbounds float, float* %885, i64 2
  %892 = load float, float* %891, align 8, !alias.scope !202
  %893 = fadd float %890, %892
  %894 = getelementptr inbounds float, float* %885, i64 3
  %895 = load float, float* %894, align 4, !alias.scope !202
  %896 = fadd float %893, %895
  %897 = getelementptr inbounds float, float* %829, i64 %848
  %898 = load float, float* %897, align 8, !alias.scope !202
  %899 = fadd float %896, %898
  %900 = getelementptr inbounds float, float* %897, i64 1
  %901 = load float, float* %900, align 4, !alias.scope !202
  %902 = fadd float %899, %901
  %903 = getelementptr inbounds float, float* %897, i64 2
  %904 = load float, float* %903, align 8, !alias.scope !202
  %905 = fadd float %902, %904
  %906 = getelementptr inbounds float, float* %897, i64 3
  %907 = load float, float* %906, align 4, !alias.scope !202
  %908 = fadd float %905, %907
  %909 = tail call float @sqrtf(float %908) #7
  %910 = fmul float %909, 2.500000e-01
  br label %938

911:                                              ; preds = %842
  br i1 %838, label %912, label %920

912:                                              ; preds = %911
  %913 = icmp ugt i64 %856, %848
  br label %914

914:                                              ; preds = %912, %926
  %915 = phi i64 [ %820, %912 ], [ %928, %926 ]
  %916 = phi float [ 0.000000e+00, %912 ], [ %927, %926 ]
  br i1 %913, label %917, label %926

917:                                              ; preds = %914
  %918 = getelementptr inbounds [4 x float*], [4 x float*]* %11, i64 0, i64 %915
  %919 = load float*, float** %918, align 8
  br label %930

920:                                              ; preds = %926, %911
  %921 = phi float [ 0.000000e+00, %911 ], [ %927, %926 ]
  %922 = mul i64 %857, %836
  %923 = uitofp i64 %922 to float
  %924 = fdiv float %921, %923
  %925 = tail call float @sqrtf(float %924) #7
  br label %938

926:                                              ; preds = %930, %914
  %927 = phi float [ %916, %914 ], [ %935, %930 ]
  %928 = add nuw i64 %915, 1
  %929 = icmp ult i64 %928, %835
  br i1 %929, label %914, label %920

930:                                              ; preds = %917, %930
  %931 = phi i64 [ %848, %917 ], [ %936, %930 ]
  %932 = phi float [ %916, %917 ], [ %935, %930 ]
  %933 = getelementptr inbounds float, float* %919, i64 %931
  %934 = load float, float* %933, align 4
  %935 = fadd float %932, %934
  %936 = add nuw i64 %931, 1
  %937 = icmp ult i64 %936, %856
  br i1 %937, label %930, label %926

938:                                              ; preds = %920, %860
  %939 = phi float [ %925, %920 ], [ %910, %860 ]
  %940 = getelementptr inbounds float, float* %817, i64 %843
  store float %939, float* %940, align 4
  %941 = add nuw i64 %843, 1
  %942 = icmp eq i64 %941, %653
  br i1 %942, label %839, label %842

943:                                              ; preds = %975
  store i64 %976, i64* %12, align 8
  br label %944

944:                                              ; preds = %943, %761
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %762) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %106) #7
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %100) #7
  br label %1205

945:                                              ; preds = %764, %975
  %946 = phi i64 [ %787, %764 ], [ %976, %975 ]
  %947 = phi i64 [ %178, %764 ], [ %976, %975 ]
  %948 = load i8*, i8** %765, align 8
  %949 = load i64, i64* %766, align 8
  %950 = mul i64 %949, %947
  %951 = getelementptr inbounds i8, i8* %948, i64 %950
  %952 = ptrtoint i8* %951 to i64
  %953 = and i64 %952, 63
  %954 = icmp eq i64 %953, 0
  tail call void @llvm.assume(i1 %954) #7
  %955 = load i8*, i8** %767, align 8
  %956 = load i64, i64* %98, align 8
  %957 = mul i64 %956, %947
  %958 = getelementptr inbounds i8, i8* %955, i64 %957
  %959 = ptrtoint i8* %958 to i64
  %960 = and i64 %959, 63
  %961 = icmp eq i64 %960, 0
  tail call void @llvm.assume(i1 %961) #7
  %962 = load i8*, i8** %768, align 8
  %963 = load i64, i64* %769, align 8
  %964 = mul i64 %963, %947
  %965 = getelementptr inbounds i8, i8* %962, i64 %964
  %966 = ptrtoint i8* %965 to i64
  %967 = and i64 %966, 63
  %968 = icmp eq i64 %967, 0
  tail call void @llvm.assume(i1 %968) #7
  %969 = bitcast i8* %965 to float*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %770) #7
  store i64 %637, i64* %13, align 8
  br i1 %771, label %970, label %975

970:                                              ; preds = %945
  %971 = sub i64 %947, %178
  %972 = shl i64 %971, 1
  %973 = load i64, i64* %13, align 8
  br label %978

974:                                              ; preds = %1188
  store i64 %1189, i64* %13, align 8
  br label %975

975:                                              ; preds = %974, %945
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %770) #7
  %976 = add i64 %946, 1
  %977 = icmp ult i64 %976, %105
  br i1 %977, label %945, label %943

978:                                              ; preds = %970, %1188
  %979 = phi i64 [ %973, %970 ], [ %1189, %1188 ]
  %980 = phi i64 [ %637, %970 ], [ %1189, %1188 ]
  %981 = getelementptr inbounds i8, i8* %951, i64 %980
  %982 = load i8, i8* %981, align 1
  %983 = and i8 %982, 1
  %984 = icmp eq i8 %983, 0
  br i1 %984, label %1188, label %985

985:                                              ; preds = %978
  %986 = lshr i8 %982, 1
  %987 = getelementptr inbounds float, float* %969, i64 %980
  %988 = load float, float* %987, align 4
  %989 = fdiv float 1.000000e+00, %988
  %990 = zext i8 %986 to i64
  %991 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_yEvE4kLut, i64 0, i64 %990
  %992 = load i8, i8* %991, align 1
  %993 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %990
  %994 = sub i64 %980, %637
  %995 = shl i64 %994, 1
  %996 = zext i8 %992 to i64
  %997 = shl nuw nsw i64 %996, 1
  %998 = load i8, i8* %993, align 1
  %999 = zext i8 %998 to i64
  %1000 = shl nuw nsw i64 %999, 1
  br label %1001

1001:                                             ; preds = %1023, %985
  %1002 = phi i64 [ 0, %985 ], [ %1024, %1023 ]
  %1003 = phi float [ 0.000000e+00, %985 ], [ %1034, %1023 ]
  %1004 = add i64 %972, %1002
  %1005 = mul i64 %1004, %181
  br label %1026

1006:                                             ; preds = %1023
  %1007 = getelementptr inbounds [27 x i8], [27 x i8]* @_ZZNK3jxl10AcStrategy16covered_blocks_xEvE4kLut, i64 0, i64 %990
  %1008 = load i8, i8* %1007, align 1
  %1009 = zext i8 %1008 to i64
  %1010 = shl nuw nsw i64 %996, 2
  %1011 = mul nuw nsw i64 %1010, %1009
  %1012 = uitofp i64 %1011 to float
  %1013 = fdiv float %1034, %1012
  %1014 = tail call float @sqrtf(float %1013) #7
  %1015 = sub i64 %980, %637
  %1016 = shl i64 %1015, 1
  %1017 = fmul float %989, 6.250000e-02
  %1018 = fpext float %1014 to double
  %1019 = fpext float %1017 to double
  %1020 = fmul double %1019, 0x400A000006666666
  %1021 = fadd double %1020, %1018
  %1022 = fmul float %1017, 0x3FB5C28F60000000
  br label %1037

1023:                                             ; preds = %1026
  %1024 = add nuw nsw i64 %1002, 1
  %1025 = icmp ult i64 %1024, %997
  br i1 %1025, label %1001, label %1006

1026:                                             ; preds = %1001, %1026
  %1027 = phi i64 [ 0, %1001 ], [ %1035, %1026 ]
  %1028 = phi float [ %1003, %1001 ], [ %1034, %1026 ]
  %1029 = add i64 %1005, %1027
  %1030 = add i64 %1029, %995
  %1031 = getelementptr inbounds float, float* %190, i64 %1030
  %1032 = load float, float* %1031, align 4
  %1033 = fmul float %1032, %1032
  %1034 = fadd float %1028, %1033
  %1035 = add nuw nsw i64 %1027, 1
  %1036 = icmp ult i64 %1035, %1000
  br i1 %1036, label %1026, label %1023

1037:                                             ; preds = %1006, %1050
  %1038 = phi i64 [ 0, %1006 ], [ %1051, %1050 ]
  %1039 = shl nuw i64 %1038, 1
  %1040 = add i64 %972, %1039
  %1041 = mul i64 %1040, %181
  %1042 = or i64 %1039, 1
  %1043 = add i64 %972, %1042
  %1044 = mul i64 %1043, %181
  %1045 = mul i64 %640, %1043
  %1046 = mul i64 %640, %1040
  %1047 = add i64 %1040, 2
  %1048 = mul i64 %640, %1047
  %1049 = mul i64 %1038, %99
  br label %1053

1050:                                             ; preds = %1053
  %1051 = add nuw nsw i64 %1038, 1
  %1052 = icmp eq i64 %1051, %996
  br i1 %1052, label %1188, label %1037

1053:                                             ; preds = %1037, %1053
  %1054 = phi i64 [ 0, %1037 ], [ %1186, %1053 ]
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %772)
  %1055 = shl nuw i64 %1054, 1
  %1056 = add i64 %1016, %1055
  %1057 = add i64 %1056, %1041
  %1058 = getelementptr inbounds float, float* %190, i64 %1057
  %1059 = load float, float* %1058, align 8
  store float %1059, float* %14, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %773)
  %1060 = or i64 %1055, 1
  %1061 = add i64 %1016, %1060
  %1062 = add i64 %1061, %1041
  %1063 = getelementptr inbounds float, float* %190, i64 %1062
  %1064 = load float, float* %1063, align 4
  store float %1064, float* %15, align 4
  %1065 = fcmp olt float %1064, %1059
  %1066 = select i1 %1065, float* %15, float* %14
  %1067 = bitcast float* %1066 to i32*
  %1068 = load i32, i32* %1067, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %773)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %772)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %774)
  %1069 = add i64 %1056, %1044
  %1070 = getelementptr inbounds float, float* %190, i64 %1069
  %1071 = load float, float* %1070, align 4
  store float %1071, float* %16, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %775)
  %1072 = add i64 %1061, %1044
  %1073 = getelementptr inbounds float, float* %190, i64 %1072
  %1074 = load float, float* %1073, align 4
  store float %1074, float* %17, align 4
  %1075 = fcmp olt float %1074, %1071
  %1076 = select i1 %1075, float* %17, float* %16
  %1077 = bitcast float* %1076 to i32*
  %1078 = load i32, i32* %1077, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %775)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %774)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %776)
  %1079 = bitcast i32 %1078 to float
  %1080 = bitcast i32 %1068 to float
  %1081 = fcmp olt float %1079, %1080
  %1082 = select i1 %1081, i32 %1078, i32 %1068
  store i32 %1082, i32* %18, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %777)
  %1083 = add i64 %1061, %1045
  %1084 = getelementptr inbounds float, float* %652, i64 %1083
  %1085 = load float, float* %1084, align 4
  store float %1085, float* %19, align 4
  %1086 = bitcast i32 %1082 to float
  %1087 = fcmp olt float %1085, %1086
  %1088 = select i1 %1087, float* %19, float* %778
  %1089 = bitcast float* %1088 to i32*
  %1090 = load i32, i32* %1089, align 4
  store i32 %1090, i32* %18, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %777)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %779)
  %1091 = add i64 %1056, %1046
  %1092 = getelementptr inbounds float, float* %652, i64 %1091
  %1093 = load float, float* %1092, align 8
  store float %1093, float* %20, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %780)
  %1094 = add i64 %1061, %1046
  %1095 = getelementptr inbounds float, float* %652, i64 %1094
  %1096 = load float, float* %1095, align 4
  store float %1096, float* %21, align 4
  %1097 = fcmp olt float %1096, %1093
  %1098 = select i1 %1097, float* %21, float* %20
  %1099 = bitcast float* %1098 to i32*
  %1100 = load i32, i32* %1099, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %780)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %779)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %781)
  %1101 = add nuw nsw i64 %1055, 2
  %1102 = add i64 %1016, %1101
  %1103 = add i64 %1102, %1046
  %1104 = getelementptr inbounds float, float* %652, i64 %1103
  %1105 = load float, float* %1104, align 8
  store float %1105, float* %22, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %782)
  %1106 = add i64 %1056, %1045
  %1107 = getelementptr inbounds float, float* %652, i64 %1106
  %1108 = load float, float* %1107, align 4
  store float %1108, float* %23, align 4
  %1109 = fcmp olt float %1108, %1105
  %1110 = select i1 %1109, float* %23, float* %22
  %1111 = bitcast float* %1110 to i32*
  %1112 = load i32, i32* %1111, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %782)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %781)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %783)
  store float %1085, float* %24, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %784)
  %1113 = add i64 %1102, %1045
  %1114 = getelementptr inbounds float, float* %652, i64 %1113
  %1115 = load float, float* %1114, align 4
  store float %1115, float* %25, align 4
  %1116 = fcmp olt float %1115, %1085
  %1117 = select i1 %1116, float* %25, float* %24
  %1118 = bitcast float* %1117 to i32*
  %1119 = load i32, i32* %1118, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %784)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %783)
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %785)
  %1120 = add i64 %1056, %1048
  %1121 = getelementptr inbounds float, float* %652, i64 %1120
  %1122 = load float, float* %1121, align 8
  store float %1122, float* %26, align 4
  call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %786)
  %1123 = add i64 %1061, %1048
  %1124 = getelementptr inbounds float, float* %652, i64 %1123
  %1125 = load float, float* %1124, align 4
  store float %1125, float* %27, align 4
  %1126 = fcmp olt float %1125, %1122
  %1127 = select i1 %1126, float* %27, float* %26
  %1128 = bitcast float* %1127 to i32*
  %1129 = load i32, i32* %1128, align 4
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %786)
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %785)
  %1130 = bitcast i32 %1112 to float
  %1131 = bitcast i32 %1100 to float
  %1132 = fcmp olt float %1130, %1131
  %1133 = select i1 %1132, i32 %1112, i32 %1100
  %1134 = bitcast i32 %1129 to float
  %1135 = bitcast i32 %1119 to float
  %1136 = fcmp olt float %1134, %1135
  %1137 = select i1 %1136, i32 %1129, i32 %1119
  %1138 = bitcast i32 %1137 to float
  %1139 = bitcast i32 %1133 to float
  %1140 = fcmp olt float %1138, %1139
  %1141 = select i1 %1140, i32 %1137, i32 %1133
  %1142 = add i64 %1102, %1048
  %1143 = getelementptr inbounds float, float* %652, i64 %1142
  %1144 = load float, float* %1143, align 8
  %1145 = bitcast i32 %1141 to float
  %1146 = fcmp olt float %1144, %1145
  %1147 = bitcast i32 %1141 to float
  %1148 = select i1 %1146, float %1144, float %1147
  %1149 = bitcast i32 %1090 to float
  %1150 = fcmp olt float %1148, %1149
  %1151 = load float, float* %778, align 4
  %1152 = select i1 %1150, float %1148, float %1151
  %1153 = fmul float %1149, 1.250000e-01
  %1154 = fmul float %1152, 6.250000e-01
  %1155 = fmul float %1152, 1.500000e+00
  %1156 = fcmp olt float %1085, %1155
  %1157 = select i1 %1156, float %1085, float %1155
  %1158 = fmul float %1157, 1.250000e-01
  %1159 = fmul float %1148, 1.250000e-01
  %1160 = insertelement <2 x float> undef, float %1059, i32 0
  %1161 = insertelement <2 x float> %1160, float %1153, i32 1
  %1162 = insertelement <2 x float> undef, float %1064, i32 0
  %1163 = insertelement <2 x float> %1162, float %1154, i32 1
  %1164 = fadd <2 x float> %1161, %1163
  %1165 = insertelement <2 x float> undef, float %1071, i32 0
  %1166 = insertelement <2 x float> %1165, float %1158, i32 1
  %1167 = fadd <2 x float> %1164, %1166
  %1168 = insertelement <2 x float> undef, float %1074, i32 0
  %1169 = insertelement <2 x float> %1168, float %1159, i32 1
  %1170 = fadd <2 x float> %1167, %1169
  %1171 = extractelement <2 x float> %1170, i32 1
  %1172 = fadd float %1017, %1171
  %1173 = fpext float %1172 to double
  %1174 = fdiv double %1021, %1173
  %1175 = fptrunc double %1174 to float
  %1176 = fcmp ogt float %1175, 0x40099999A0000000
  %1177 = extractelement <2 x float> %1170, i32 0
  %1178 = fadd float %1177, %1171
  %1179 = fmul float %1178, 0x3FC99999A0000000
  %1180 = fcmp olt float %1179, %1022
  %1181 = or i1 %1180, %1176
  %1182 = select i1 %1181, i8 4, i8 0
  %1183 = add i64 %1054, %1049
  %1184 = add i64 %1183, %980
  %1185 = getelementptr inbounds i8, i8* %958, i64 %1184
  store i8 %1182, i8* %1185, align 1
  call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %776)
  %1186 = add nuw nsw i64 %1054, 1
  %1187 = icmp ult i64 %1186, %1009
  br i1 %1187, label %1053, label %1050

1188:                                             ; preds = %1050, %978
  %1189 = add i64 %979, 1
  %1190 = icmp ult i64 %1189, %111
  br i1 %1190, label %978, label %974

1191:                                             ; preds = %1208, %66
  %1192 = phi i64 [ 0, %66 ], [ %1209, %1208 ]
  %1193 = icmp eq i64 %70, 0
  br i1 %1193, label %1205, label %1194

1194:                                             ; preds = %1191
  %1195 = add i64 %1192, %60
  %1196 = load i8*, i8** %67, align 8
  %1197 = load i64, i64* %68, align 8
  %1198 = mul i64 %1197, %1195
  %1199 = getelementptr inbounds i8, i8* %1196, i64 %1198
  %1200 = ptrtoint i8* %1199 to i64
  %1201 = and i64 %1200, 63
  %1202 = icmp eq i64 %1201, 0
  tail call void @llvm.assume(i1 %1202) #7
  br i1 %69, label %1205, label %1203

1203:                                             ; preds = %1194
  %1204 = getelementptr inbounds i8, i8* %1199, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1204, i8 4, i64 %62, i1 false) #7
  br label %1205

1205:                                             ; preds = %1191, %1194, %1203, %56, %944
  ret void

1206:                                             ; preds = %87
  %1207 = getelementptr inbounds i8, i8* %93, i64 %58
  tail call void @llvm.memset.p0i8.i64(i8* align 1 %1207, i8 4, i64 %62, i1 false) #7
  br label %1208

1208:                                             ; preds = %1206, %87
  %1209 = add nuw i64 %75, 2
  %1210 = add i64 %76, -2
  %1211 = icmp eq i64 %1210, 0
  br i1 %1211, label %1191, label %74
}

declare void @_ZN3hwy12ChosenTarget6UpdateEv(%"struct.hwy::ChosenTarget"*) local_unnamed_addr #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #5

declare zeroext i1 @_ZN3jxl5DebugEPKcz(i8*, ...) local_unnamed_addr #4

; Function Attrs: noreturn
declare zeroext i1 @_ZN3jxl5AbortEv() local_unnamed_addr #6

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg) #5

; Function Attrs: nounwind ssp uwtable
define linkonce_odr hidden void @_ZN3jxl24ArControlFieldHeuristics10TempImages8InitOnceEv(%"struct.jxl::ArControlFieldHeuristics::TempImages"*) local_unnamed_addr #0 comdat align 2 {
  %2 = alloca %"class.jxl::Plane", align 8
  %3 = alloca %"class.jxl::Plane", align 8
  %4 = alloca %"class.jxl::Plane", align 8
  %5 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0, i64 0, i32 0, i32 0, i32 0
  %6 = load i32, i32* %5, align 8
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %8, label %74

8:                                                ; preds = %1
  %9 = bitcast %"class.jxl::Plane"* %2 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %9) #7
  %10 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %2, i64 0, i32 0
  call void @_ZN3jxl9PlaneBaseC2Emmm(%"struct.jxl::PlaneBase"* nonnull %10, i64 68, i64 68, i64 4) #7
  %11 = bitcast %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %11, i8* nonnull align 8 %9, i64 24, i1 false) #7
  %12 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0, i64 0, i32 0, i32 0, i32 5
  %13 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %2, i64 0, i32 0, i32 5
  %14 = getelementptr inbounds %"class.std::__1::unique_ptr", %"class.std::__1::unique_ptr"* %13, i64 0, i32 0, i32 0, i32 0
  %15 = bitcast %"class.std::__1::unique_ptr"* %13 to i64*
  %16 = load i64, i64* %15, align 8
  store i8* null, i8** %14, align 8
  %17 = getelementptr inbounds %"class.std::__1::unique_ptr", %"class.std::__1::unique_ptr"* %12, i64 0, i32 0, i32 0, i32 0
  %18 = load i8*, i8** %17, align 8
  %19 = bitcast %"class.std::__1::unique_ptr"* %12 to i64*
  store i64 %16, i64* %19, align 8
  %20 = icmp eq i8* %18, null
  br i1 %20, label %21, label %23

21:                                               ; preds = %8
  %22 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %2, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  store i8* null, i8** %22, align 8
  br label %29

23:                                               ; preds = %8
  call void @_ZN3jxl12CacheAligned4FreeEPKv(i8* nonnull %18) #7
  %24 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %2, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %25 = load i8*, i8** %24, align 8
  %26 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %2, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  store i8* null, i8** %26, align 8
  %27 = icmp eq i8* %25, null
  br i1 %27, label %29, label %28

28:                                               ; preds = %23
  call void @_ZN3jxl12CacheAligned4FreeEPKv(i8* nonnull %25) #7
  br label %29

29:                                               ; preds = %21, %23, %28
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %9) #7
  %30 = bitcast %"class.jxl::Plane"* %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %30) #7
  %31 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %3, i64 0, i32 0
  call void @_ZN3jxl9PlaneBaseC2Emmm(%"struct.jxl::PlaneBase"* nonnull %31, i64 16, i64 16, i64 4) #7
  %32 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0, i64 0, i32 1
  %33 = bitcast %"class.jxl::Plane"* %32 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %33, i8* nonnull align 8 %30, i64 24, i1 false) #7
  %34 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0, i64 0, i32 1, i32 0, i32 5
  %35 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %3, i64 0, i32 0, i32 5
  %36 = getelementptr inbounds %"class.std::__1::unique_ptr", %"class.std::__1::unique_ptr"* %35, i64 0, i32 0, i32 0, i32 0
  %37 = bitcast %"class.std::__1::unique_ptr"* %35 to i64*
  %38 = load i64, i64* %37, align 8
  store i8* null, i8** %36, align 8
  %39 = getelementptr inbounds %"class.std::__1::unique_ptr", %"class.std::__1::unique_ptr"* %34, i64 0, i32 0, i32 0, i32 0
  %40 = load i8*, i8** %39, align 8
  %41 = bitcast %"class.std::__1::unique_ptr"* %34 to i64*
  store i64 %38, i64* %41, align 8
  %42 = icmp eq i8* %40, null
  br i1 %42, label %43, label %45

43:                                               ; preds = %29
  %44 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %3, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  store i8* null, i8** %44, align 8
  br label %51

45:                                               ; preds = %29
  call void @_ZN3jxl12CacheAligned4FreeEPKv(i8* nonnull %40) #7
  %46 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %3, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %47 = load i8*, i8** %46, align 8
  %48 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %3, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  store i8* null, i8** %48, align 8
  %49 = icmp eq i8* %47, null
  br i1 %49, label %51, label %50

50:                                               ; preds = %45
  call void @_ZN3jxl12CacheAligned4FreeEPKv(i8* nonnull %47) #7
  br label %51

51:                                               ; preds = %43, %45, %50
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %30) #7
  %52 = bitcast %"class.jxl::Plane"* %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %52) #7
  %53 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %4, i64 0, i32 0
  call void @_ZN3jxl9PlaneBaseC2Emmm(%"struct.jxl::PlaneBase"* nonnull %53, i64 17, i64 17, i64 4) #7
  %54 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0, i64 0, i32 2
  %55 = bitcast %"class.jxl::Plane"* %54 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %55, i8* nonnull align 8 %52, i64 24, i1 false) #7
  %56 = getelementptr inbounds %"struct.jxl::ArControlFieldHeuristics::TempImages", %"struct.jxl::ArControlFieldHeuristics::TempImages"* %0, i64 0, i32 2, i32 0, i32 5
  %57 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %4, i64 0, i32 0, i32 5
  %58 = getelementptr inbounds %"class.std::__1::unique_ptr", %"class.std::__1::unique_ptr"* %57, i64 0, i32 0, i32 0, i32 0
  %59 = bitcast %"class.std::__1::unique_ptr"* %57 to i64*
  %60 = load i64, i64* %59, align 8
  store i8* null, i8** %58, align 8
  %61 = getelementptr inbounds %"class.std::__1::unique_ptr", %"class.std::__1::unique_ptr"* %56, i64 0, i32 0, i32 0, i32 0
  %62 = load i8*, i8** %61, align 8
  %63 = bitcast %"class.std::__1::unique_ptr"* %56 to i64*
  store i64 %60, i64* %63, align 8
  %64 = icmp eq i8* %62, null
  br i1 %64, label %65, label %67

65:                                               ; preds = %51
  %66 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %4, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  store i8* null, i8** %66, align 8
  br label %73

67:                                               ; preds = %51
  call void @_ZN3jxl12CacheAligned4FreeEPKv(i8* nonnull %62) #7
  %68 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %4, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  %69 = load i8*, i8** %68, align 8
  %70 = getelementptr inbounds %"class.jxl::Plane", %"class.jxl::Plane"* %4, i64 0, i32 0, i32 5, i32 0, i32 0, i32 0
  store i8* null, i8** %70, align 8
  %71 = icmp eq i8* %69, null
  br i1 %71, label %73, label %72

72:                                               ; preds = %67
  call void @_ZN3jxl12CacheAligned4FreeEPKv(i8* nonnull %69) #7
  br label %73

73:                                               ; preds = %65, %67, %72
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %52) #7
  br label %74

74:                                               ; preds = %1, %73
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #5

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg) #5

declare void @_ZN3jxl9PlaneBaseC2Emmm(%"struct.jxl::PlaneBase"*, i64, i64, i64) unnamed_addr #4

declare void @_ZN3jxl12CacheAligned4FreeEPKv(i8*) local_unnamed_addr #4

; Function Attrs: nounwind
declare void @llvm.assume(i1) #7

; Function Attrs: nounwind readnone speculatable
declare <16 x float> @llvm.fma.v16f32(<16 x float>, <16 x float>, <16 x float>) #8

; Function Attrs: nounwind readnone speculatable
declare <4 x float> @llvm.sqrt.v4f32(<4 x float>) #8

; Function Attrs: nofree nounwind
declare float @sqrtf(float) local_unnamed_addr #9

; Function Attrs: nounwind readnone speculatable
declare <8 x float> @llvm.fma.v8f32(<8 x float>, <8 x float>, <8 x float>) #8

; Function Attrs: nounwind readnone speculatable
declare i32 @llvm.cttz.i32(i32, i1 immarg) #8

attributes #0 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="512" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+avx512bw,+avx512dq,+avx512f,+avx512vl,+bmi,+bmi2,+cx8,+f16c,+fma,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="256" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+bmi,+bmi2,+cx8,+f16c,+fma,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="128" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { argmemonly nounwind }
attributes #6 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind }
attributes #8 = { nounwind readnone speculatable }
attributes #9 = { nofree nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "null-pointer-is-valid"="true" "stack-protector-buffer-size"="4" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+sse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { noreturn nounwind }

!llvm.module.flags = !{!0, !1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 2}
!2 = !{i32 0, i32 33}
!3 = !{!4}
!4 = distinct !{!4, !5, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!5 = distinct !{!5, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!6 = !{!7}
!7 = distinct !{!7, !5, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!8 = !{!9}
!9 = distinct !{!9, !10, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!10 = distinct !{!10, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!11 = !{!12}
!12 = distinct !{!12, !10, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!13 = !{!14}
!14 = distinct !{!14, !15, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!15 = distinct !{!15, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!16 = !{!17}
!17 = distinct !{!17, !15, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!18 = !{!19}
!19 = distinct !{!19, !20, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!20 = distinct !{!20, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!21 = !{!22}
!22 = distinct !{!22, !20, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!23 = !{!24}
!24 = distinct !{!24, !25, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!25 = distinct !{!25, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!26 = !{!27}
!27 = distinct !{!27, !25, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!28 = !{!29}
!29 = distinct !{!29, !30, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!30 = distinct !{!30, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!31 = !{!32}
!32 = distinct !{!32, !30, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!33 = !{!34}
!34 = distinct !{!34, !35, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!35 = distinct !{!35, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!36 = !{!37}
!37 = distinct !{!37, !35, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!38 = !{!39}
!39 = distinct !{!39, !40, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!40 = distinct !{!40, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!41 = !{!42}
!42 = distinct !{!42, !40, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!43 = !{!44}
!44 = distinct !{!44, !45, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 1"}
!45 = distinct !{!45, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf"}
!46 = !{!47}
!47 = distinct !{!47, !45, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm16EEEPKf: argument 0"}
!48 = !{!49}
!49 = distinct !{!49, !50, !"_ZN3hwy6N_AVX3L6StoreUENS0_6Vec512IfEENS0_4SimdIfLm16EEEPf: argument 0"}
!50 = distinct !{!50, !"_ZN3hwy6N_AVX3L6StoreUENS0_6Vec512IfEENS0_4SimdIfLm16EEEPf"}
!51 = !{!52}
!52 = distinct !{!52, !53, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!53 = distinct !{!53, !"_ZN3hwy6N_AVX3L5LoadUENS0_4SimdIfLm4EEEPKf"}
!54 = !{!55}
!55 = distinct !{!55, !56, !"_ZN3hwy6N_AVX3L4LoadENS0_4SimdIfLm4EEEPKf: argument 0"}
!56 = distinct !{!56, !"_ZN3hwy6N_AVX3L4LoadENS0_4SimdIfLm4EEEPKf"}
!57 = !{!58}
!58 = distinct !{!58, !59, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!59 = distinct !{!59, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!60 = !{!61}
!61 = distinct !{!61, !59, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!62 = !{!63}
!63 = distinct !{!63, !64, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!64 = distinct !{!64, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!65 = !{!66}
!66 = distinct !{!66, !64, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!67 = !{!68}
!68 = distinct !{!68, !69, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!69 = distinct !{!69, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!70 = !{!71}
!71 = distinct !{!71, !69, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!72 = !{!73}
!73 = distinct !{!73, !74, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!74 = distinct !{!74, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!75 = !{!76}
!76 = distinct !{!76, !74, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!77 = !{!78}
!78 = distinct !{!78, !79, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!79 = distinct !{!79, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!80 = !{!81}
!81 = distinct !{!81, !79, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!82 = !{!83}
!83 = distinct !{!83, !84, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!84 = distinct !{!84, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!85 = !{!86}
!86 = distinct !{!86, !84, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!87 = !{!88}
!88 = distinct !{!88, !89, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!89 = distinct !{!89, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!90 = !{!91}
!91 = distinct !{!91, !89, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!92 = !{!93}
!93 = distinct !{!93, !94, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!94 = distinct !{!94, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!95 = !{!96}
!96 = distinct !{!96, !94, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!97 = !{!98}
!98 = distinct !{!98, !99, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 1"}
!99 = distinct !{!99, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf"}
!100 = !{!101}
!101 = distinct !{!101, !99, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm8EEEPKf: argument 0"}
!102 = !{!103}
!103 = distinct !{!103, !104, !"_ZN3hwy6N_AVX2L6StoreUENS0_6Vec256IfEENS0_4SimdIfLm8EEEPf: argument 0"}
!104 = distinct !{!104, !"_ZN3hwy6N_AVX2L6StoreUENS0_6Vec256IfEENS0_4SimdIfLm8EEEPf"}
!105 = !{!106}
!106 = distinct !{!106, !107, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!107 = distinct !{!107, !"_ZN3hwy6N_AVX2L5LoadUENS0_4SimdIfLm4EEEPKf"}
!108 = !{!109}
!109 = distinct !{!109, !110, !"_ZN3hwy6N_AVX2L4LoadENS0_4SimdIfLm4EEEPKf: argument 0"}
!110 = distinct !{!110, !"_ZN3hwy6N_AVX2L4LoadENS0_4SimdIfLm4EEEPKf"}
!111 = !{!112}
!112 = distinct !{!112, !113, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!113 = distinct !{!113, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!114 = !{!115}
!115 = distinct !{!115, !116, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!116 = distinct !{!116, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!117 = !{!118}
!118 = distinct !{!118, !119, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!119 = distinct !{!119, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!120 = !{!121}
!121 = distinct !{!121, !122, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!122 = distinct !{!122, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!123 = !{!124}
!124 = distinct !{!124, !125, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!125 = distinct !{!125, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!126 = !{!127}
!127 = distinct !{!127, !128, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!128 = distinct !{!128, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!129 = !{!130}
!130 = distinct !{!130, !131, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!131 = distinct !{!131, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!132 = !{!133}
!133 = distinct !{!133, !134, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!134 = distinct !{!134, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!135 = !{!136}
!136 = distinct !{!136, !137, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!137 = distinct !{!137, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!138 = !{!139}
!139 = distinct !{!139, !140, !"_ZN3hwy6N_SSE4L6StoreUENS0_6Vec128IfLm4EEENS0_4SimdIfLm4EEEPf: argument 0"}
!140 = distinct !{!140, !"_ZN3hwy6N_SSE4L6StoreUENS0_6Vec128IfLm4EEENS0_4SimdIfLm4EEEPf"}
!141 = !{!142}
!142 = distinct !{!142, !143, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf: argument 0"}
!143 = distinct !{!143, !"_ZN3hwy6N_SSE4L5LoadUENS0_4SimdIfLm4EEEPKf"}
!144 = !{!145}
!145 = distinct !{!145, !146, !"_ZN3hwy6N_SSE4L4LoadENS0_4SimdIfLm4EEEPKf: argument 0"}
!146 = distinct !{!146, !"_ZN3hwy6N_SSE4L4LoadENS0_4SimdIfLm4EEEPKf"}
!147 = !{!148, !150}
!148 = distinct !{!148, !149, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!149 = distinct !{!149, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!150 = distinct !{!150, !151, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!151 = distinct !{!151, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!152 = !{!153, !155}
!153 = distinct !{!153, !154, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!154 = distinct !{!154, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!155 = distinct !{!155, !156, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!156 = distinct !{!156, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!157 = !{!158, !160}
!158 = distinct !{!158, !159, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!159 = distinct !{!159, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!160 = distinct !{!160, !161, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!161 = distinct !{!161, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!162 = !{!163, !165}
!163 = distinct !{!163, !164, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!164 = distinct !{!164, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!165 = distinct !{!165, !166, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!166 = distinct !{!166, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!167 = !{!168, !170}
!168 = distinct !{!168, !169, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!169 = distinct !{!169, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!170 = distinct !{!170, !171, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!171 = distinct !{!171, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!172 = !{!173, !175}
!173 = distinct !{!173, !174, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!174 = distinct !{!174, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!175 = distinct !{!175, !176, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!176 = distinct !{!176, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!177 = !{!178, !180}
!178 = distinct !{!178, !179, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!179 = distinct !{!179, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!180 = distinct !{!180, !181, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!181 = distinct !{!181, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!182 = !{!183, !185}
!183 = distinct !{!183, !184, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!184 = distinct !{!184, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!185 = distinct !{!185, !186, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!186 = distinct !{!186, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!187 = !{!188, !190}
!188 = distinct !{!188, !189, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!189 = distinct !{!189, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!190 = distinct !{!190, !191, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!191 = distinct !{!191, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!192 = !{!193, !195}
!193 = distinct !{!193, !194, !"_ZN3hwy8N_SCALAR5StoreIfEEvNS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPS3_: argument 0"}
!194 = distinct !{!194, !"_ZN3hwy8N_SCALAR5StoreIfEEvNS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPS3_"}
!195 = distinct !{!195, !196, !"_ZN3hwy8N_SCALAR6StoreUIfEEvNS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPS3_: argument 0"}
!196 = distinct !{!196, !"_ZN3hwy8N_SCALAR6StoreUIfEEvNS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPS3_"}
!197 = !{!198, !200}
!198 = distinct !{!198, !199, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!199 = distinct !{!199, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!200 = distinct !{!200, !201, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!201 = distinct !{!201, !"_ZN3hwy8N_SCALAR5LoadUIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
!202 = !{!203}
!203 = distinct !{!203, !204, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_: argument 0"}
!204 = distinct !{!204, !"_ZN3hwy8N_SCALAR4LoadIfEENS0_4Vec1IT_EENS0_4SimdIS3_Lm1EEEPKS3_"}
